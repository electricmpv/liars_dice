{"version":3,"sources":["file:///D:/editors/liars_dice_demo/client/assets/scripts/utils/bid-validator.ts"],"names":["BidValidator","getEffectiveValue","face","isBidValid","value","count","currentBid","totalDice","currentValueFace","currentCount","validFace","currentValue","newValue","getMinValidCount","selectedValue","getMinValidFace","selectedCount","nextFace","console","error","getFaceLabel"],"mappings":"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","sourcesContent":["import { Bid, Face } from '../../shared/protocols/game-types.d';\n\n/**\n * 叫价验证器\n * 负责验证叫价是否合法，根据用户指定的规则：\n * - 1 被叫时，视为比 6 大的点数。\n * - 数量增加时，点数任意。\n * - 数量相同时，点数必须增加（考虑 1 > 6）。\n * - 达到 X 个 6 或 X 个 1 后，下一个必须是 X+1 个任意点数。\n */\nexport class BidValidator {\n\n    /**\n     * 获取点数的有效比较值 (1 视为 7)\n     * @param face 点数 (1-6) 或 0 (来自 [0,0])\n     * @returns 比较值 (2-6, 或 7 代表 1) ，如果输入无效则返回 0\n     */\n    private static getEffectiveValue(face: Face | 0): number {\n        if (face === 1) return 7; // 1 点视为 7\n        if (face >= 2 && face <= 6) return face; // 2-6 不变\n        return 0; // 处理无效输入或 [0,0] 中的 0\n    }\n\n    /**\n     * 验证叫价是否合法\n     * @param value 要叫的点数 (1-6)\n     * @param count 要叫的数量\n     * @param currentBid 当前最高叫价 [face, count] 或 [0, 0]\n     * @param totalDice 场上总骰子数\n     * @returns 是否合法\n     */\n    public static isBidValid(value: Face, count: number, currentBid: Bid | [0, 0], totalDice: number): boolean {\n        const [currentValueFace, currentCount] = currentBid;\n\n        // 基本验证: 点数必须是 1-6, 数量必须大于 0 且不大于总骰子数\n        if (!this.validFace(value) || count <= 0 || count > totalDice) {\n            return false;\n        }\n\n        // 首次叫价 (currentCount 为 0) 总是有效的\n        if (currentCount === 0) {\n            return true;\n        }\n\n        // 获取当前叫价和新叫价的有效比较值\n        const currentValue = this.getEffectiveValue(currentValueFace);\n        const newValue = this.getEffectiveValue(value);\n\n        // 新规则: 如果数量增加，叫价总是有效的\n        if (count > currentCount) {\n            return true;\n        }\n\n        // 新规则: 如果数量相同，新点数的有效值必须严格大于当前点数的有效值\n        if (count === currentCount && newValue > currentValue) {\n            return true;\n        }\n\n        // 其他情况 (数量更少，或数量相同但点数相同/更低) 均无效\n        return false;\n    }\n\n    /**\n     * 计算给定【选定点数】下，最小合法的叫价数量 (适配旧交互模式)\n     * @param selectedValue 玩家选择的点数 (1-6)\n     * @param currentBid 当前最高叫价 [face, count] 或 [0, 0]\n     * @returns 最小合法数量\n     */\n    public static getMinValidCount(selectedValue: Face, currentBid: Bid | [0, 0]): number {\n        const [currentValueFace, currentCount] = currentBid;\n\n        // 首次叫价，最小数量为 1\n        if (currentCount === 0) {\n            return 1;\n        }\n\n        // 获取当前叫价和选定点数的有效比较值\n        const currentValue = this.getEffectiveValue(currentValueFace);\n        const newValue = this.getEffectiveValue(selectedValue);\n\n        // 新规则: 如果选定点数的有效值 > 当前点数的有效值，可以保持相同数量\n        if (newValue > currentValue) {\n            return currentCount;\n        } else {\n            // 新规则: 如果选定点数的有效值 <= 当前点数的有效值，必须增加数量\n            return currentCount + 1;\n        }\n    }\n\n    /**\n     * 计算给定【选定数量】下，最小合法的叫价点数 (适配新交互模式)\n     * @param selectedCount 玩家选择的数量\n     * @param currentBid 当前最高叫价 [face, count] 或 [0, 0]\n     * @returns 最小合法点数 (1-6)。如果此数量下无合法点数 (意味着必须加数量)，返回 7。\n     */\n    public static getMinValidFace(selectedCount: number, currentBid: Bid | [0, 0]): Face {\n        const [currentValueFace, currentCount] = currentBid;\n\n        // 首次叫价，最小点数是 1\n        if (currentCount === 0) {\n            return 1;\n        }\n\n        // 新规则: 如果选定数量 > 当前数量，可以叫任意点数 (最小是 1)\n        if (selectedCount > currentCount) {\n            return 1;\n        }\n\n        // 新规则: 如果选定数量 === 当前数量，必须叫一个有效值更大的点数\n        if (selectedCount === currentCount) {\n            const currentValue = this.getEffectiveValue(currentValueFace);\n            // 从 1 开始查找第一个有效值大于 currentValue 的点数\n            for (let nextFace = 1; nextFace <= 6; nextFace++) {\n                if (this.getEffectiveValue(nextFace as Face) > currentValue) {\n                    return nextFace as Face; // 找到最小的合法点数\n                }\n            }\n            // 如果循环结束还没找到，说明当前已经是最大有效值 (X 个 1)，必须增加数量\n            return 7 as Face; // 返回 7 表示此数量下无合法点数\n        }\n\n        // 理论上 UI 不会允许选择比当前数量更小的数量\n        console.error(\"getMinValidFace called with selectedCount lower than currentCount\", selectedCount, currentBid);\n        return 7 as Face; // 错误情况\n    }\n\n    /**\n     * 验证值是否为有效的骰子面值 (1-6)\n     * @param value 要验证的值\n     * @returns 是否为有效面值\n     */\n    public static validFace(value: number): value is Face {\n        return value >= 1 && value <= 6;\n    }\n\n    /**\n     * 获取骰子面值标签\n     * @param face 骰子面值 (1-6)\n     * @returns 面值标签\n     */\n    public static getFaceLabel(face: Face): string {\n        // 根据之前的上下文使用中文标签\n        return [\"?\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"][face] || `${face}`;\n    }\n}\n"]}