{"version":3,"sources":["file:///D:/editors/liars_dice_demo/client/assets/scripts/colyseus-cocos-creator.js"],"names":["_cjsLoader","__cjsMetaURL","url","define","exports","require","module","__filename","__dirname","global","factory","amd","globalThis","self","Colyseus","_mergeNamespaces","n","m","forEach","e","Array","isArray","Object","keys","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","freeze","ArrayBuffer","isView","a","buffer","FormData","window","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","rejected","result","done","then","apply","__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","__classPrivateFieldSet","set","SuppressedError","error","suppressed","message","Error","name","CloseCode","ServerError","constructor","code","getDefaultExportFromCjs","x","__esModule","prototype","hasOwnProperty","umd$1","umd","hasRequiredUmd","requireUmd","SWITCH_TO_STRUCTURE","TYPE_ID","OPERATION","Symbol","metadata","for","$track","$encoder","$decoder","$filter","$getByIndex","$deleteByIndex","$changes","$childType","$onEncodeEnd","$onDecodeEnd","$descriptors","$numFields","$refTypeFieldIndexes","$viewFieldIndexes","$fieldIndexesByViewTag","textEncoder","TextEncoder","_convoBuffer$1","_int32$1","Int32Array","_float32$1","Float32Array","_float64$1","Float64Array","_int64$1","BigInt64Array","hasBufferByteLength","Buffer","byteLength","utf8Length","str","_","c","length","i","l","charCodeAt","utf8Write","view","it","offset","int8$1","bytes","uint8$1","int16$1","uint16$1","int32$1","uint32$1","b4","b3","b2","b1","int64$1","high","Math","floor","pow","low","uint64$1","bigint64$1","BigInt","asIntN","biguint64$1","float32$1","float64$1","boolean$1","string$1","size","number$1","isNaN","isFinite","Number","MAX_SAFE_INTEGER","abs","encode","int8","uint8","int16","uint16","int32","uint32","int64","uint64","bigint64","biguint64","float32","float64","boolean","string","number","_convoBuffer","_int32","_float32","_float64","_uint64","BigUint64Array","_int64","utf8Read","chr","end","byte","String","fromCharCode","console","toString","prefix","stringCheck","decode","registeredTypes","identifiers","Map","registerType","identifier","definition","getType","defineCustomTypes","types","t","type","TypeContext","register","target","parent","getPrototypeOf","Schema","inherits","inheritedTypes","Set","add","cache","rootClass","context","cachedContexts","schemas","hasFilters","parentFiltered","discoverTypes","schema","typeid","undefined","Metadata","initialize","getTypeId","klass","parentType","parentIndex","parentHasViewTag","registerFilteredByParent","child","Function","fieldIndex","index","fieldType","fieldHasViewTag","tag","values","key","debug","split","map","pop","reverse","id","txt","join","getNormalizedType","array","addField","descriptor","assign","configurable","writable","push","setTag","fieldName","field","setFields","fields","parentClass","parentMetadata","toJSON","complexTypeKlass","childType","getPropertyDescriptor","isDeprecated","deprecated","init","create","setPrototypeOf","isValidInstance","getFields","hasViewTagAtIndex","includes","createChangeSet","indexes","operations","setOperationAtIndex","changeSet","operationsIndex","deleteOperationAtIndex","at","entries","find","enqueueChangeTree","root","changeTree","queueRootIndex","ChangeTree","ref","isFiltered","indexedOperations","changes","allChanges","isNew","allFilteredChanges","filteredChanges","setRoot","checkIsFiltered","setParent","forEachChild","callback","operation","op","change","ADD","previousOperation","DELETE","DELETE_AND_ADD","shiftChangeIndexes","shiftIndex","newIndexedOperations","newIndexes","shiftAllChangeIndexes","startIndex","_shiftAllChangeIndexes","newKey","indexedOperation","allChangesIndex","getChange","getValue","isEncodeAll","delete","warn","previousValue","remove","endEncode","changeSetName","discard","discardAll","len","ensureRefId","refId","getNextUniqueId","changed","isNewChangeTree","_checkFilteredByParent","refType","parentChangeTree","parentIsCollection","parentConstructor","isVisibilitySharedWithParent","encodeValue","encoder","tryEncodeTypeId","encodeSchemaOperation","__","encodeKeyValueOperation","CLEAR","dynamicIndex","encodeArray","hasView","useOperationByRefId","refOrIndex","DELETE_BY_REFID","ADD_BY_REFID","REVERSE","DEFINITION_MISMATCH","decodeValue","decoder","$root","previousRefId","refIds","removeRef","is","refs","getInstanceType","createInstanceOfType","addRef","typeDef","valueRef","clone","iter","decodeSchemaOperation","first_byte","currentRefId","decodeKeyValueOperation","removeChildRefs","clear","decodeArray","findIndex","itemByRefId","EncodeSchemaError","assertType","typeofTarget","allowNull","log","foundValue","JSON","stringify","assertInstanceType","instance","_a$4","_b$4","DEFAULT_SORT","b","A","B","iterator","species","ArraySchema","isChangeTreeVisible","from","iterable","items","tmpItems","deletedIndexes","isMovingItems","proxy","Proxy","obj","prop","Reflect","setValue","$deleteAt","$changeAt","MOVE_AND_ADD","DELETE_AND_MOVE","MOVE","deleteProperty","newLength","splice","REPLACE","$setAt","unshift","removeChangeFromChangeSet","concat","separator","shift","item","slice","start","sliced","sort","compareFn","sortedItems","deleteCount","insertItems","itemsLength","tmpItemsLength","insertCount","addIndex","indexOf","searchElement","fromIndex","lastIndexOf","every","callbackfn","some","filter","reduce","initialValue","reduceRight","predicate","fill","copyWithin","toLocaleString","flatMap","flat","depth","findLast","arguments","findLastIndex","args","with","copy","toReversed","toSorted","toSpliced","shuffle","move","currentIndex","randomIndex","random","cb","toArray","isDecoding","cloned","_a$3","_b$3","toStringTag","MapSchema","deletedItems","initialValues","$items","$indexes","v","isRef","setIndex","getIndex","DEFAULT_VIEW_TAG","entity","options","definitionAtLine","stack","trim","manual","fieldCached","substring","throws","defineTypes","defaultValues","viewTagFields","extends","getIndent","level","dumpChanges","dump","ops","opName","_a$2","_b$2","defineProperties","tags","props","setDirty","property","discardAllChanges","debugRefIds","showContents","contents","output","childChangeTree","debugChanges","dumpChangeSet","debugChangesDeep","rootChangeTree","changeTrees","instanceRefIds","totalOperations","includeChangeTree","parentChangeTrees","visitedParents","WeakSet","indent","_a$1","_b$1","CollectionSchema","$refId","entry","_a","_b","SetSchema","visible","__decorate","decorators","desc","r","decorate","Root","nextUniqueId","refCount","previousRefCount","changeSetIndex","Encoder","sharedBuffer","allocUnsafe","BUFFER_SIZE","setState","initialOffset","numChangeTrees","invisible","numChanges","ctor","j","newSize","ceil","poolSize","round","alloc","subarray","encodeAll","encodeAllView","sharedOffset","viewOffset","rootChangeSet","encodeView","discardChanges","baseType","targetType","baseTypeId","targetTypeId","hasChanges","spliceOne","arr","DecodingWarning","ReferenceTracker","WeakMap","refCounts","deletedRefs","callbacks","incrementCount","clearRefs","garbageCollectDeletedRefs","childRefId","addCallback","fieldOrOperation","removeCallback","Decoder","totalBytes","nextRef","nextIterator","triggerChanges","defaultType","type_id","needRemoveRef","ReflectionField","ReflectionType","Reflection","reflection","reflectionEncoder","rootType","includedTypeIds","pendingReflectionTypes","addType","extendsId","deps","inheritFrom","reflectionField","childTypeSchema","referencedType","buf","reflectionDecoder","typeContext","reflectionType","addFields","parentFieldIndex","typeInfo","getDecoderStateCallbacks","onAddCalls","currentOnAddCallback","uniqueRefIds","$callbacks","deleteCallbacks","replaceCallbacks","fieldCallbacks","addCallbacks","getProxy","metadataOrType","isCollection","onAddListen","immediate","listen","detachCallback","onInstanceAvailable","existing","onChange","bindTo","targetObject","properties","metadataField","unbind","$","parentInstance","_1","_2","onAdd","onRemove","getRawChangesCallback","StateView","checkIncludeParent","addParentOf","isInvisible","tagAtIndex","_isClear","hasTag","ob","isVisible","umdExports","H3TransportTransport","events","isOpen","lengthPrefixBuffer","Uint8Array","connect","wtOpts","fingerprint","serverCertificateHashes","algorithm","wt","WebTransport","ready","unreliableReader","datagrams","readable","getReader","unreliableWriter","getWriter","incomingBidi","incomingBidirectionalStreams","read","stream","reader","writer","sendSeatReservation","room","roomId","sessionId","reconnectionToken","readIncomingData","readIncomingUnreliableData","catch","_close","closed","onclose","closeCode","reason","onerror","finally","send","data","prefixLength","dataWithPrefixedLength","write","sendUnreliable","close","messages","onmessage","browser","hasRequiredBrowser","requireBrowser","browserExports","NodeWebSocket","WebSocket","WebSocketTransport","ws","headers","protocols","binaryType","onopen","readyState","OPEN","Connection","protocol","transport","Protocol","ErrorCode","serializers","registerSerializer","serializer","getSerializer","createNanoEvents","emit","event","on","EventEmitter","handlers","once","invoke","handler","invokeAsync","all","createSignal","emitter","getStateCallbacks","SchemaSerializer","encodedState","getState","patch","patches","teardown","handshake","TextDecoder","src","srcEnd","position$1","currentUnpackr","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings$1","referenceMap","currentExtensions","dataView","defaultOptions","useRecords","mapsAsObjects","C1Type","C1","sequentialMode","inlineObjectReadThreshold","readStruct","Infinity","Unpackr","sequential","trusted","structures","maxSharedStructures","sharedLength","getStructures","uninitialized","int64AsNumber","int64AsType","unpack","source","saveState","clearSource","DataView","byteOffset","checkedRead","unpackMultiple","lastPosition","defaultUnpackr","_mergeStructures","loadedStructures","existingStructures","isFrozen","structure","isShared","highByte","restoreStructures","randomAccessStructure","postBundlePosition","jsonView","RangeError","startsWith","incomplete","token","loadStructures","createStructureReader","object","readKey","freezeData","shortStringInJS","longStringInJS","readFixedString","position1","position0","readBin","getUint16","getUint32","readExt","getFloat32","useFloat32","multiplier","mult10","getFloat64","getBigUint64","getInt8","getInt16","getInt32","getBigInt64","recordDefinition","extension","noBuffer","readString8","readString16","readString32","readArray","readMap","validName","firstId","readObject","count","test","createSecondByteReader","read0","readStringJS","units","byte1","byte2","byte3","byte4","unit","g","h","o","readOnlyJSString","copyBuffers","readPosition","keyCache","asSafeString","checkPosition","chunk","allowArraysInMapKeys","firstByte","existingStructure","errors","ReferenceError","cause","structuredClone","refEntry","targetProperties","used","typedArrays","glbl","typeCode","typedArrayName","ab","u8","RegExp","TEMP_BUNDLE","dataSize","dataPosition","Date","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedStructuresContents","savedPackr","savedSequentialMode","f32Array","extensions","extensionClasses","hasNodeBuffer","ByteArrayAllocate","allocUnsafeSlow","ByteArray","MAX_BUFFER_SIZE","keysTarget","targetView","position","safeEnd","bundledStrings","writeStructSlots","MAX_BUNDLE_SIZE","hasNonLatin","RECORD_SYMBOL","Packr","hasSharedUpdate","encodeUtf8","encodeInto","written","packr","isSequential","hasSharedStructures","saveStructures","moreTypes","maxOwnStructures","useTwoByteRecords","sharedLimitId","maxStructureId","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","pack","encodeOptions","RESERVE_START_SPACE","bundleStrings","transitions","nextTransition","transition","lastNamedStructuresLength","nextId","encodingError","writeStruct","lastBundle","writeBundles","idsToInsert","incrementPosition","insertionPoint","stringsPosition","setUint32","previous","makeRoom","serialized","insertIds","REUSE_BUFFER_MODE","resetStructures","returnBuffer","newSharedData","prepareStructures","isCompatible","RESET_BUFFER_MODE","packArray","strLength","extStart","maxBytes","setUint16","twoByte","headerSize","c1","c2","strPosition","setInt16","setInt32","setFloat32","xShifted","setFloat64","referee","writeObject","mapAsEmptyObject","entryValue","extensionClass","writeResult","currentTarget","currentTargetView","currentPosition","writeExtensionData","json","writeFunction","setBigInt64","setBigUint64","largeBigIntToFloat","largeBigIntToString","useBigIntExtension","alignedSign","encodeUndefinedAsNil","writePlainObject","variableMapSize","coercibleKeyAsNumber","skipValues","num","objectOffset","writeRecord","progressiveRecords","wroteKeys","lastTransition","newTransitions","newRecord","insertNewRecord","recordId","__keys__","checkUseRecords","min","max","newBuffer","shouldShareStructure","nextOwnId","insertionOffset","mainTarget","mainPosition","mainSafeEnd","mainStart","keysPosition","newEnd","insertionPosition","newPosition","notifySharedUpdate","startTarget","useBuffer","clearSharedData","typedStructs","date","allocateForWrite","seconds","getTime","useTimestamp32","getMilliseconds","onInvalidDate","setAsEmptyObject","regex","flags","arrayBuffer","writeExtBuffer","writeBuffer","typedArray","distanceToMove","lastEnd","writeStrings","compatible","defaultPackr","Room","rootSchema","onStateChange","onError","onLeave","onJoin","hasJoined","onMessageHandlers","removeAllListeners","endpoint","devModeCloseCallback","connection","onMessageCallback","bind","DEVMODE_RESTART","destroy","URL","origin","leave","consented","LEAVE_ROOM","CONSENTED","onMessage","getMessageHandlerKey","ROOM_DATA","sendBytes","ROOM_DATA_BYTES","JOIN_ROOM","serializerId","ERROR","ROOM_STATE","ROOM_STATE_PATCH","dispatchMessage","messageType","xhr","hasRequiredXhr","requireXhr","tar","statusMessage","statusText","statusCode","status","response","method","uri","opts","res","rej","req","XMLHttpRequest","tmp","body","timeout","ontimeout","err","open","href","onload","getAllResponseHeaders","toLowerCase","parse","reviver","withCredentials","setRequestHeader","post","del","put","xhrExports","httpie","__proto__","default","HTTP","client","path","request","getOptions","authToken","cc","sys","isNative","storage","getStorage","localStorage","indexedDB","IndexedDBStorage","setItem","getItem","removeItem","dbPromise","onupgradeneeded","createObjectStore","onsuccess","tx","mode","fn","db","store","transaction","objectStore","_Auth__initialized","_Auth__initializationPromise","_Auth__signInWindow","_Auth__events","Auth","http","settings","unbindChange","getUserData","userData","emitChange","user","registerWithEmailAndPassword","email","password","signInWithEmailAndPassword","signInAnonymously","sendPasswordResetEmail","signInWithProvider","providerName_1","providerName","w","width","height","upgradingToken","title","toUpperCase","left","screen","top","clearInterval","rejectionChecker","removeEventListener","setInterval","addEventListener","signOut","authData","discordURLBuilder","localHostname","location","hostname","remoteHostnameSplitted","subdomain","pathname","search","MatchMakeError","DEFAULT_ENDPOINT","replace","port","Client","secure","endsWith","auth","urlBuilder","joinOrCreate","roomName_1","roomName","createMatchMakeRequest","joinById","roomId_1","reconnect","consumeSeatReservation","reuseRoomInstance","createRoom","targetRoom","buildEndpoint","devMode","info","fromCodePoint","retryCount","retryMaxRetries","retryReconnection","setTimeout","method_1","params","publicAddress","getEndpointPort","endpointURL","processId","getHttpEndpoint","segments","VERSION","NoneSerializer","rawState","_cjsExports","_OPERATION","_$changes","_$childType","_$decoder","_$deleteByIndex","_$encoder","_$filter","_$getByIndex","_$track","_ArraySchema","_ChangeTree","_CollectionSchema","_Decoder","_Encoder","_MapSchema","_Metadata","_Reflection","_ReflectionField","_ReflectionType","_Schema","_SetSchema","_StateView","_TypeContext","_decode","_decodeKeyValueOperation","_decodeSchemaOperation","_defineCustomTypes","_defineTypes","_deprecated","_dumpChanges","_encode","_encodeArray","_encodeKeyValueOperation","_encodeSchemaOperation","_entity","_getDecoderStateCallbacks","_getRawChangesCallback","_registerType","_schema","_type","_view","_Protocol","_ErrorCode","_Auth","_Client","_MatchMakeError","_Room","_SchemaSerializer","_ServerError","_getStateCallbacks","_registerSerializer"],"mappings":"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ACyB,KAAD,EAAQ2M,GAAR,KAAgB;AACzB,4BAAI3M,KAAK,CAACqD,QAAD,CAAT,EAAqB;AACjBsY,0BAAAA,MAAM,CAACta,GAAP,CAAWsL,GAAX,EAAgB3M,KAAK,CAAC,OAAD,CAAL,EAAhB;AACH,yBAFD,MAGK;AACD2b,0BAAAA,MAAM,CAACta,GAAP,CAAWsL,GAAX,EAAgB3M,KAAhB;AACH;AACJ,uBAPD;AAQH;;AACD,2BAAO2b,MAAP;AACH;;AAxLW;;AA5gFQ,0BA4gFlBI,SA5gFkB;AA6gFX,wBAAKH,IAAL,IAAanI,uBAAb;AACA,wBAAKoI,IAAL,IAAavG,uBAAb;AAwLbxL,gBAAAA,YAAY,CAAC,KAAD,EAAQ;AAAEhI,kBAAAA,WAAW,EAAEia;AAAf,iBAAR,CAAZ;AAEA,sBAAMS,gBAAgB,GAAG,CAAC,CAA1B;;AACA,yBAASC,MAAT,CAAgB3a,WAAhB,EAA6B;AACzBwI,kBAAAA,WAAW,CAACC,QAAZ,CAAqBzI,WAArB;AACA,yBAAOA,WAAP;AACH;AACD;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACW;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","sourcesContent":["import _cjsLoader from 'cce:/internal/ml/cjs-loader.mjs';\nlet _cjsExports;\nlet _OPERATION;\nlet _$changes;\nlet _$childType;\nlet _$decoder;\nlet _$deleteByIndex;\nlet _$encoder;\nlet _$filter;\nlet _$getByIndex;\nlet _$track;\nlet _ArraySchema;\nlet _ChangeTree;\nlet _CollectionSchema;\nlet _Decoder;\nlet _Encoder;\nlet _MapSchema;\nlet _Metadata;\nlet _Reflection;\nlet _ReflectionField;\nlet _ReflectionType;\nlet _Schema;\nlet _SetSchema;\nlet _StateView;\nlet _TypeContext;\nlet _decode;\nlet _decodeKeyValueOperation;\nlet _decodeSchemaOperation;\nlet _defineCustomTypes;\nlet _defineTypes;\nlet _deprecated;\nlet _dumpChanges;\nlet _encode;\nlet _encodeArray;\nlet _encodeKeyValueOperation;\nlet _encodeSchemaOperation;\nlet _entity;\nlet _getDecoderStateCallbacks;\nlet _getRawChangesCallback;\nlet _registerType;\nlet _schema;\nlet _type;\nlet _view;\nlet _Protocol;\nlet _ErrorCode;\nlet _Auth;\nlet _Client;\nlet _MatchMakeError;\nlet _Room;\nlet _SchemaSerializer;\nlet _ServerError;\nlet _getStateCallbacks;\nlet _registerSerializer;\nconst __cjsMetaURL = import.meta.url;\n_cjsLoader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {\n// #region ORIGINAL CODE\n\n\n // THIS VERSION USES \"XMLHttpRequest\" INSTEAD OF \"fetch\" FOR COMPATIBILITY WITH COCOS CREATOR\n // colyseus.js@0.16.16 (@colyseus/schema 3.0.33)\n (function (global, factory) {\n     typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n     typeof define === 'function' && define.amd ? define('colyseus.js', ['exports'], factory) :\n     (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Colyseus = {}));\n })(this, (function (exports) { 'use strict';\n\n     function _mergeNamespaces(n, m) {\n         m.forEach(function (e) {\n             e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n                 if (k !== 'default' && !(k in n)) {\n                     var d = Object.getOwnPropertyDescriptor(e, k);\n                     Object.defineProperty(n, k, d.get ? d : {\n                         enumerable: true,\n                         get: function () { return e[k]; }\n                     });\n                 }\n             });\n         });\n         return Object.freeze(n);\n     }\n\n     //\n     // Polyfills for legacy environments\n     //\n     /*\n      * Support Android 4.4.x\n      */\n     if (!ArrayBuffer.isView) {\n         ArrayBuffer.isView = (a) => {\n             return a !== null && typeof (a) === 'object' && a.buffer instanceof ArrayBuffer;\n         };\n     }\n     // Cocos Creator does not provide \"FormData\"\n     // Define a dummy implementation so it doesn't crash\n     if (typeof (FormData) === \"undefined\") {\n         // @ts-ignore\n         global['FormData'] = class {\n         };\n     }\n     // Define globalThis if not available.\n     // https://github.com/colyseus/colyseus.js/issues/86\n     if (typeof (globalThis) === \"undefined\" &&\n         typeof (window) !== \"undefined\") {\n         // @ts-ignore\n         window['globalThis'] = window;\n     }\n\n     /******************************************************************************\r\n     Copyright (c) Microsoft Corporation.\r\n\r\n     Permission to use, copy, modify, and/or distribute this software for any\r\n     purpose with or without fee is hereby granted.\r\n\r\n     THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n     REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n     AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n     INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n     LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n     OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n     PERFORMANCE OF THIS SOFTWARE.\r\n     ***************************************************************************** */\r\n     /* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\n     function __awaiter(thisArg, _arguments, P, generator) {\r\n         function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n         return new (P || (P = Promise))(function (resolve, reject) {\r\n             function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n             function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n             function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n             step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n         });\r\n     }\r\n\r\n     function __classPrivateFieldGet(receiver, state, kind, f) {\r\n         if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n         if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n         return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n     }\r\n\r\n     function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n         if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n         if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n         if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n         return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n     }\r\n\r\n     typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n         var e = new Error(message);\r\n         return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n     };\n\n     var CloseCode;\n     (function (CloseCode) {\n         CloseCode[CloseCode[\"CONSENTED\"] = 4000] = \"CONSENTED\";\n         CloseCode[CloseCode[\"DEVMODE_RESTART\"] = 4010] = \"DEVMODE_RESTART\";\n     })(CloseCode || (CloseCode = {}));\n     class ServerError extends Error {\n         constructor(code, message) {\n             super(message);\n             this.name = \"ServerError\";\n             this.code = code;\n         }\n     }\n\n     function getDefaultExportFromCjs (x) {\n     \treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n     }\n\n     var umd$1 = {exports: {}};\n\n     var umd = umd$1.exports;\n\n     var hasRequiredUmd;\n\n     function requireUmd () {\n     \tif (hasRequiredUmd) return umd$1.exports;\n     \thasRequiredUmd = 1;\n     \t(function (module, exports) {\n     \t\t(function (global, factory) {\n     \t\t    factory(exports) ;\n     \t\t})(umd, (function (exports) {\n     \t\t    const SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)\n     \t\t    const TYPE_ID = 213;\n     \t\t    /**\n     \t\t     * Encoding Schema field operations.\n     \t\t     */\n     \t\t    exports.OPERATION = void 0;\n     \t\t    (function (OPERATION) {\n     \t\t        OPERATION[OPERATION[\"ADD\"] = 128] = \"ADD\";\n     \t\t        OPERATION[OPERATION[\"REPLACE\"] = 0] = \"REPLACE\";\n     \t\t        OPERATION[OPERATION[\"DELETE\"] = 64] = \"DELETE\";\n     \t\t        OPERATION[OPERATION[\"DELETE_AND_MOVE\"] = 96] = \"DELETE_AND_MOVE\";\n     \t\t        OPERATION[OPERATION[\"MOVE_AND_ADD\"] = 160] = \"MOVE_AND_ADD\";\n     \t\t        OPERATION[OPERATION[\"DELETE_AND_ADD\"] = 192] = \"DELETE_AND_ADD\";\n     \t\t        /**\n     \t\t         * Collection operations\n     \t\t         */\n     \t\t        OPERATION[OPERATION[\"CLEAR\"] = 10] = \"CLEAR\";\n     \t\t        /**\n     \t\t         * ArraySchema operations\n     \t\t         */\n     \t\t        OPERATION[OPERATION[\"REVERSE\"] = 15] = \"REVERSE\";\n     \t\t        OPERATION[OPERATION[\"MOVE\"] = 32] = \"MOVE\";\n     \t\t        OPERATION[OPERATION[\"DELETE_BY_REFID\"] = 33] = \"DELETE_BY_REFID\";\n     \t\t        OPERATION[OPERATION[\"ADD_BY_REFID\"] = 129] = \"ADD_BY_REFID\";\n     \t\t    })(exports.OPERATION || (exports.OPERATION = {}));\n\n     \t\t    Symbol.metadata ??= Symbol.for(\"Symbol.metadata\");\n\n     \t\t    const $track = Symbol(\"$track\");\n     \t\t    const $encoder = Symbol(\"$encoder\");\n     \t\t    const $decoder = Symbol(\"$decoder\");\n     \t\t    const $filter = Symbol(\"$filter\");\n     \t\t    const $getByIndex = Symbol(\"$getByIndex\");\n     \t\t    const $deleteByIndex = Symbol(\"$deleteByIndex\");\n     \t\t    /**\n     \t\t     * Used to hold ChangeTree instances whitin the structures\n     \t\t     */\n     \t\t    const $changes = Symbol('$changes');\n     \t\t    /**\n     \t\t     * Used to keep track of the type of the child elements of a collection\n     \t\t     * (MapSchema, ArraySchema, etc.)\n     \t\t     */\n     \t\t    const $childType = Symbol('$childType');\n     \t\t    /**\n     \t\t     * Optional \"discard\" method for custom types (ArraySchema)\n     \t\t     * (Discards changes for next serialization)\n     \t\t     */\n     \t\t    const $onEncodeEnd = Symbol('$onEncodeEnd');\n     \t\t    /**\n     \t\t     * When decoding, this method is called after the instance is fully decoded\n     \t\t     */\n     \t\t    const $onDecodeEnd = Symbol(\"$onDecodeEnd\");\n     \t\t    /**\n     \t\t     * Metadata\n     \t\t     */\n     \t\t    const $descriptors = Symbol(\"$descriptors\");\n     \t\t    const $numFields = \"$__numFields\";\n     \t\t    const $refTypeFieldIndexes = \"$__refTypeFieldIndexes\";\n     \t\t    const $viewFieldIndexes = \"$__viewFieldIndexes\";\n     \t\t    const $fieldIndexesByViewTag = \"$__fieldIndexesByViewTag\";\n\n     \t\t    /**\n     \t\t     * Copyright (c) 2018 Endel Dreyer\n     \t\t     * Copyright (c) 2014 Ion Drive Software Ltd.\n     \t\t     *\n     \t\t     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     \t\t     * of this software and associated documentation files (the \"Software\"), to deal\n     \t\t     * in the Software without restriction, including without limitation the rights\n     \t\t     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     \t\t     * copies of the Software, and to permit persons to whom the Software is\n     \t\t     * furnished to do so, subject to the following conditions:\n     \t\t     *\n     \t\t     * The above copyright notice and this permission notice shall be included in all\n     \t\t     * copies or substantial portions of the Software.\n     \t\t     *\n     \t\t     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     \t\t     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     \t\t     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     \t\t     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     \t\t     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     \t\t     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     \t\t     * SOFTWARE\n     \t\t     */\n     \t\t    /**\n     \t\t     * msgpack implementation highly based on notepack.io\n     \t\t     * https://github.com/darrachequesne/notepack\n     \t\t     */\n     \t\t    let textEncoder;\n     \t\t    // @ts-ignore\n     \t\t    try {\n     \t\t        textEncoder = new TextEncoder();\n     \t\t    }\n     \t\t    catch (e) { }\n     \t\t    const _convoBuffer$1 = new ArrayBuffer(8);\n     \t\t    const _int32$1 = new Int32Array(_convoBuffer$1);\n     \t\t    const _float32$1 = new Float32Array(_convoBuffer$1);\n     \t\t    const _float64$1 = new Float64Array(_convoBuffer$1);\n     \t\t    const _int64$1 = new BigInt64Array(_convoBuffer$1);\n     \t\t    const hasBufferByteLength = (typeof Buffer !== 'undefined' && Buffer.byteLength);\n     \t\t    const utf8Length = (hasBufferByteLength)\n     \t\t        ? Buffer.byteLength // node\n     \t\t        : function (str, _) {\n     \t\t            var c = 0, length = 0;\n     \t\t            for (var i = 0, l = str.length; i < l; i++) {\n     \t\t                c = str.charCodeAt(i);\n     \t\t                if (c < 0x80) {\n     \t\t                    length += 1;\n     \t\t                }\n     \t\t                else if (c < 0x800) {\n     \t\t                    length += 2;\n     \t\t                }\n     \t\t                else if (c < 0xd800 || c >= 0xe000) {\n     \t\t                    length += 3;\n     \t\t                }\n     \t\t                else {\n     \t\t                    i++;\n     \t\t                    length += 4;\n     \t\t                }\n     \t\t            }\n     \t\t            return length;\n     \t\t        };\n     \t\t    function utf8Write(view, str, it) {\n     \t\t        var c = 0;\n     \t\t        for (var i = 0, l = str.length; i < l; i++) {\n     \t\t            c = str.charCodeAt(i);\n     \t\t            if (c < 0x80) {\n     \t\t                view[it.offset++] = c;\n     \t\t            }\n     \t\t            else if (c < 0x800) {\n     \t\t                view[it.offset] = 0xc0 | (c >> 6);\n     \t\t                view[it.offset + 1] = 0x80 | (c & 0x3f);\n     \t\t                it.offset += 2;\n     \t\t            }\n     \t\t            else if (c < 0xd800 || c >= 0xe000) {\n     \t\t                view[it.offset] = 0xe0 | (c >> 12);\n     \t\t                view[it.offset + 1] = 0x80 | (c >> 6 & 0x3f);\n     \t\t                view[it.offset + 2] = 0x80 | (c & 0x3f);\n     \t\t                it.offset += 3;\n     \t\t            }\n     \t\t            else {\n     \t\t                i++;\n     \t\t                c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n     \t\t                view[it.offset] = 0xf0 | (c >> 18);\n     \t\t                view[it.offset + 1] = 0x80 | (c >> 12 & 0x3f);\n     \t\t                view[it.offset + 2] = 0x80 | (c >> 6 & 0x3f);\n     \t\t                view[it.offset + 3] = 0x80 | (c & 0x3f);\n     \t\t                it.offset += 4;\n     \t\t            }\n     \t\t        }\n     \t\t    }\n     \t\t    function int8$1(bytes, value, it) {\n     \t\t        bytes[it.offset++] = value & 255;\n     \t\t    }\n     \t\t    function uint8$1(bytes, value, it) {\n     \t\t        bytes[it.offset++] = value & 255;\n     \t\t    }\n     \t\t    function int16$1(bytes, value, it) {\n     \t\t        bytes[it.offset++] = value & 255;\n     \t\t        bytes[it.offset++] = (value >> 8) & 255;\n     \t\t    }\n     \t\t    function uint16$1(bytes, value, it) {\n     \t\t        bytes[it.offset++] = value & 255;\n     \t\t        bytes[it.offset++] = (value >> 8) & 255;\n     \t\t    }\n     \t\t    function int32$1(bytes, value, it) {\n     \t\t        bytes[it.offset++] = value & 255;\n     \t\t        bytes[it.offset++] = (value >> 8) & 255;\n     \t\t        bytes[it.offset++] = (value >> 16) & 255;\n     \t\t        bytes[it.offset++] = (value >> 24) & 255;\n     \t\t    }\n     \t\t    function uint32$1(bytes, value, it) {\n     \t\t        const b4 = value >> 24;\n     \t\t        const b3 = value >> 16;\n     \t\t        const b2 = value >> 8;\n     \t\t        const b1 = value;\n     \t\t        bytes[it.offset++] = b1 & 255;\n     \t\t        bytes[it.offset++] = b2 & 255;\n     \t\t        bytes[it.offset++] = b3 & 255;\n     \t\t        bytes[it.offset++] = b4 & 255;\n     \t\t    }\n     \t\t    function int64$1(bytes, value, it) {\n     \t\t        const high = Math.floor(value / Math.pow(2, 32));\n     \t\t        const low = value >>> 0;\n     \t\t        uint32$1(bytes, low, it);\n     \t\t        uint32$1(bytes, high, it);\n     \t\t    }\n     \t\t    function uint64$1(bytes, value, it) {\n     \t\t        const high = (value / Math.pow(2, 32)) >> 0;\n     \t\t        const low = value >>> 0;\n     \t\t        uint32$1(bytes, low, it);\n     \t\t        uint32$1(bytes, high, it);\n     \t\t    }\n     \t\t    function bigint64$1(bytes, value, it) {\n     \t\t        _int64$1[0] = BigInt.asIntN(64, value);\n     \t\t        int32$1(bytes, _int32$1[0], it);\n     \t\t        int32$1(bytes, _int32$1[1], it);\n     \t\t    }\n     \t\t    function biguint64$1(bytes, value, it) {\n     \t\t        _int64$1[0] = BigInt.asIntN(64, value);\n     \t\t        int32$1(bytes, _int32$1[0], it);\n     \t\t        int32$1(bytes, _int32$1[1], it);\n     \t\t    }\n     \t\t    function float32$1(bytes, value, it) {\n     \t\t        _float32$1[0] = value;\n     \t\t        int32$1(bytes, _int32$1[0], it);\n     \t\t    }\n     \t\t    function float64$1(bytes, value, it) {\n     \t\t        _float64$1[0] = value;\n     \t\t        int32$1(bytes, _int32$1[0 ], it);\n     \t\t        int32$1(bytes, _int32$1[1 ], it);\n     \t\t    }\n     \t\t    function boolean$1(bytes, value, it) {\n     \t\t        bytes[it.offset++] = value ? 1 : 0; // uint8\n     \t\t    }\n     \t\t    function string$1(bytes, value, it) {\n     \t\t        // encode `null` strings as empty.\n     \t\t        if (!value) {\n     \t\t            value = \"\";\n     \t\t        }\n     \t\t        let length = utf8Length(value, \"utf8\");\n     \t\t        let size = 0;\n     \t\t        // fixstr\n     \t\t        if (length < 0x20) {\n     \t\t            bytes[it.offset++] = length | 0xa0;\n     \t\t            size = 1;\n     \t\t        }\n     \t\t        // str 8\n     \t\t        else if (length < 0x100) {\n     \t\t            bytes[it.offset++] = 0xd9;\n     \t\t            bytes[it.offset++] = length % 255;\n     \t\t            size = 2;\n     \t\t        }\n     \t\t        // str 16\n     \t\t        else if (length < 0x10000) {\n     \t\t            bytes[it.offset++] = 0xda;\n     \t\t            uint16$1(bytes, length, it);\n     \t\t            size = 3;\n     \t\t        }\n     \t\t        // str 32\n     \t\t        else if (length < 0x100000000) {\n     \t\t            bytes[it.offset++] = 0xdb;\n     \t\t            uint32$1(bytes, length, it);\n     \t\t            size = 5;\n     \t\t        }\n     \t\t        else {\n     \t\t            throw new Error('String too long');\n     \t\t        }\n     \t\t        utf8Write(bytes, value, it);\n     \t\t        return size + length;\n     \t\t    }\n     \t\t    function number$1(bytes, value, it) {\n     \t\t        if (isNaN(value)) {\n     \t\t            return number$1(bytes, 0, it);\n     \t\t        }\n     \t\t        else if (!isFinite(value)) {\n     \t\t            return number$1(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER, it);\n     \t\t        }\n     \t\t        else if (value !== (value | 0)) {\n     \t\t            if (Math.abs(value) <= 3.4028235e+38) { // range check\n     \t\t                _float32$1[0] = value;\n     \t\t                if (Math.abs(Math.abs(_float32$1[0]) - Math.abs(value)) < 1e-4) { // precision check; adjust 1e-n (n = precision) to in-/decrease acceptable precision loss\n     \t\t                    // now we know value is in range for f32 and has acceptable precision for f32\n     \t\t                    bytes[it.offset++] = 0xca;\n     \t\t                    float32$1(bytes, value, it);\n     \t\t                    return 5;\n     \t\t                }\n     \t\t            }\n     \t\t            bytes[it.offset++] = 0xcb;\n     \t\t            float64$1(bytes, value, it);\n     \t\t            return 9;\n     \t\t        }\n     \t\t        if (value >= 0) {\n     \t\t            // positive fixnum\n     \t\t            if (value < 0x80) {\n     \t\t                bytes[it.offset++] = value & 255; // uint8\n     \t\t                return 1;\n     \t\t            }\n     \t\t            // uint 8\n     \t\t            if (value < 0x100) {\n     \t\t                bytes[it.offset++] = 0xcc;\n     \t\t                bytes[it.offset++] = value & 255; // uint8\n     \t\t                return 2;\n     \t\t            }\n     \t\t            // uint 16\n     \t\t            if (value < 0x10000) {\n     \t\t                bytes[it.offset++] = 0xcd;\n     \t\t                uint16$1(bytes, value, it);\n     \t\t                return 3;\n     \t\t            }\n     \t\t            // uint 32\n     \t\t            if (value < 0x100000000) {\n     \t\t                bytes[it.offset++] = 0xce;\n     \t\t                uint32$1(bytes, value, it);\n     \t\t                return 5;\n     \t\t            }\n     \t\t            // uint 64\n     \t\t            bytes[it.offset++] = 0xcf;\n     \t\t            uint64$1(bytes, value, it);\n     \t\t            return 9;\n     \t\t        }\n     \t\t        else {\n     \t\t            // negative fixnum\n     \t\t            if (value >= -32) {\n     \t\t                bytes[it.offset++] = 0xe0 | (value + 0x20);\n     \t\t                return 1;\n     \t\t            }\n     \t\t            // int 8\n     \t\t            if (value >= -128) {\n     \t\t                bytes[it.offset++] = 0xd0;\n     \t\t                int8$1(bytes, value, it);\n     \t\t                return 2;\n     \t\t            }\n     \t\t            // int 16\n     \t\t            if (value >= -32768) {\n     \t\t                bytes[it.offset++] = 0xd1;\n     \t\t                int16$1(bytes, value, it);\n     \t\t                return 3;\n     \t\t            }\n     \t\t            // int 32\n     \t\t            if (value >= -2147483648) {\n     \t\t                bytes[it.offset++] = 0xd2;\n     \t\t                int32$1(bytes, value, it);\n     \t\t                return 5;\n     \t\t            }\n     \t\t            // int 64\n     \t\t            bytes[it.offset++] = 0xd3;\n     \t\t            int64$1(bytes, value, it);\n     \t\t            return 9;\n     \t\t        }\n     \t\t    }\n     \t\t    const encode = {\n     \t\t        int8: int8$1,\n     \t\t        uint8: uint8$1,\n     \t\t        int16: int16$1,\n     \t\t        uint16: uint16$1,\n     \t\t        int32: int32$1,\n     \t\t        uint32: uint32$1,\n     \t\t        int64: int64$1,\n     \t\t        uint64: uint64$1,\n     \t\t        bigint64: bigint64$1,\n     \t\t        biguint64: biguint64$1,\n     \t\t        float32: float32$1,\n     \t\t        float64: float64$1,\n     \t\t        boolean: boolean$1,\n     \t\t        string: string$1,\n     \t\t        number: number$1,\n     \t\t        utf8Write,\n     \t\t        utf8Length,\n     \t\t    };\n\n     \t\t    /**\n     \t\t     * Copyright (c) 2018 Endel Dreyer\n     \t\t     * Copyright (c) 2014 Ion Drive Software Ltd.\n     \t\t     *\n     \t\t     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     \t\t     * of this software and associated documentation files (the \"Software\"), to deal\n     \t\t     * in the Software without restriction, including without limitation the rights\n     \t\t     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     \t\t     * copies of the Software, and to permit persons to whom the Software is\n     \t\t     * furnished to do so, subject to the following conditions:\n     \t\t     *\n     \t\t     * The above copyright notice and this permission notice shall be included in all\n     \t\t     * copies or substantial portions of the Software.\n     \t\t     *\n     \t\t     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     \t\t     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     \t\t     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     \t\t     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     \t\t     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     \t\t     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     \t\t     * SOFTWARE\n     \t\t     */\n     \t\t    // force little endian to facilitate decoding on multiple implementations\n     \t\t    const _convoBuffer = new ArrayBuffer(8);\n     \t\t    const _int32 = new Int32Array(_convoBuffer);\n     \t\t    const _float32 = new Float32Array(_convoBuffer);\n     \t\t    const _float64 = new Float64Array(_convoBuffer);\n     \t\t    const _uint64 = new BigUint64Array(_convoBuffer);\n     \t\t    const _int64 = new BigInt64Array(_convoBuffer);\n     \t\t    function utf8Read(bytes, it, length) {\n     \t\t        var string = '', chr = 0;\n     \t\t        for (var i = it.offset, end = it.offset + length; i < end; i++) {\n     \t\t            var byte = bytes[i];\n     \t\t            if ((byte & 0x80) === 0x00) {\n     \t\t                string += String.fromCharCode(byte);\n     \t\t                continue;\n     \t\t            }\n     \t\t            if ((byte & 0xe0) === 0xc0) {\n     \t\t                string += String.fromCharCode(((byte & 0x1f) << 6) |\n     \t\t                    (bytes[++i] & 0x3f));\n     \t\t                continue;\n     \t\t            }\n     \t\t            if ((byte & 0xf0) === 0xe0) {\n     \t\t                string += String.fromCharCode(((byte & 0x0f) << 12) |\n     \t\t                    ((bytes[++i] & 0x3f) << 6) |\n     \t\t                    ((bytes[++i] & 0x3f) << 0));\n     \t\t                continue;\n     \t\t            }\n     \t\t            if ((byte & 0xf8) === 0xf0) {\n     \t\t                chr = ((byte & 0x07) << 18) |\n     \t\t                    ((bytes[++i] & 0x3f) << 12) |\n     \t\t                    ((bytes[++i] & 0x3f) << 6) |\n     \t\t                    ((bytes[++i] & 0x3f) << 0);\n     \t\t                if (chr >= 0x010000) { // surrogate pair\n     \t\t                    chr -= 0x010000;\n     \t\t                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n     \t\t                }\n     \t\t                else {\n     \t\t                    string += String.fromCharCode(chr);\n     \t\t                }\n     \t\t                continue;\n     \t\t            }\n     \t\t            console.error('Invalid byte ' + byte.toString(16));\n     \t\t            // (do not throw error to avoid server/client from crashing due to hack attemps)\n     \t\t            // throw new Error('Invalid byte ' + byte.toString(16));\n     \t\t        }\n     \t\t        it.offset += length;\n     \t\t        return string;\n     \t\t    }\n     \t\t    function int8(bytes, it) {\n     \t\t        return uint8(bytes, it) << 24 >> 24;\n     \t\t    }\n     \t\t    function uint8(bytes, it) {\n     \t\t        return bytes[it.offset++];\n     \t\t    }\n     \t\t    function int16(bytes, it) {\n     \t\t        return uint16(bytes, it) << 16 >> 16;\n     \t\t    }\n     \t\t    function uint16(bytes, it) {\n     \t\t        return bytes[it.offset++] | bytes[it.offset++] << 8;\n     \t\t    }\n     \t\t    function int32(bytes, it) {\n     \t\t        return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;\n     \t\t    }\n     \t\t    function uint32(bytes, it) {\n     \t\t        return int32(bytes, it) >>> 0;\n     \t\t    }\n     \t\t    function float32(bytes, it) {\n     \t\t        _int32[0] = int32(bytes, it);\n     \t\t        return _float32[0];\n     \t\t    }\n     \t\t    function float64(bytes, it) {\n     \t\t        _int32[0 ] = int32(bytes, it);\n     \t\t        _int32[1 ] = int32(bytes, it);\n     \t\t        return _float64[0];\n     \t\t    }\n     \t\t    function int64(bytes, it) {\n     \t\t        const low = uint32(bytes, it);\n     \t\t        const high = int32(bytes, it) * Math.pow(2, 32);\n     \t\t        return high + low;\n     \t\t    }\n     \t\t    function uint64(bytes, it) {\n     \t\t        const low = uint32(bytes, it);\n     \t\t        const high = uint32(bytes, it) * Math.pow(2, 32);\n     \t\t        return high + low;\n     \t\t    }\n     \t\t    function bigint64(bytes, it) {\n     \t\t        _int32[0] = int32(bytes, it);\n     \t\t        _int32[1] = int32(bytes, it);\n     \t\t        return _int64[0];\n     \t\t    }\n     \t\t    function biguint64(bytes, it) {\n     \t\t        _int32[0] = int32(bytes, it);\n     \t\t        _int32[1] = int32(bytes, it);\n     \t\t        return _uint64[0];\n     \t\t    }\n     \t\t    function boolean(bytes, it) {\n     \t\t        return uint8(bytes, it) > 0;\n     \t\t    }\n     \t\t    function string(bytes, it) {\n     \t\t        const prefix = bytes[it.offset++];\n     \t\t        let length;\n     \t\t        if (prefix < 0xc0) {\n     \t\t            // fixstr\n     \t\t            length = prefix & 0x1f;\n     \t\t        }\n     \t\t        else if (prefix === 0xd9) {\n     \t\t            length = uint8(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xda) {\n     \t\t            length = uint16(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xdb) {\n     \t\t            length = uint32(bytes, it);\n     \t\t        }\n     \t\t        return utf8Read(bytes, it, length);\n     \t\t    }\n     \t\t    function number(bytes, it) {\n     \t\t        const prefix = bytes[it.offset++];\n     \t\t        if (prefix < 0x80) {\n     \t\t            // positive fixint\n     \t\t            return prefix;\n     \t\t        }\n     \t\t        else if (prefix === 0xca) {\n     \t\t            // float 32\n     \t\t            return float32(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xcb) {\n     \t\t            // float 64\n     \t\t            return float64(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xcc) {\n     \t\t            // uint 8\n     \t\t            return uint8(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xcd) {\n     \t\t            // uint 16\n     \t\t            return uint16(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xce) {\n     \t\t            // uint 32\n     \t\t            return uint32(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xcf) {\n     \t\t            // uint 64\n     \t\t            return uint64(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xd0) {\n     \t\t            // int 8\n     \t\t            return int8(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xd1) {\n     \t\t            // int 16\n     \t\t            return int16(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xd2) {\n     \t\t            // int 32\n     \t\t            return int32(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix === 0xd3) {\n     \t\t            // int 64\n     \t\t            return int64(bytes, it);\n     \t\t        }\n     \t\t        else if (prefix > 0xdf) {\n     \t\t            // negative fixint\n     \t\t            return (0xff - prefix + 1) * -1;\n     \t\t        }\n     \t\t    }\n     \t\t    function stringCheck(bytes, it) {\n     \t\t        const prefix = bytes[it.offset];\n     \t\t        return (\n     \t\t        // fixstr\n     \t\t        (prefix < 0xc0 && prefix > 0xa0) ||\n     \t\t            // str 8\n     \t\t            prefix === 0xd9 ||\n     \t\t            // str 16\n     \t\t            prefix === 0xda ||\n     \t\t            // str 32\n     \t\t            prefix === 0xdb);\n     \t\t    }\n     \t\t    const decode = {\n     \t\t        utf8Read,\n     \t\t        int8,\n     \t\t        uint8,\n     \t\t        int16,\n     \t\t        uint16,\n     \t\t        int32,\n     \t\t        uint32,\n     \t\t        float32,\n     \t\t        float64,\n     \t\t        int64,\n     \t\t        uint64,\n     \t\t        bigint64,\n     \t\t        biguint64,\n     \t\t        boolean,\n     \t\t        string,\n     \t\t        number,\n     \t\t        stringCheck,\n     \t\t    };\n\n     \t\t    const registeredTypes = {};\n     \t\t    const identifiers = new Map();\n     \t\t    function registerType(identifier, definition) {\n     \t\t        if (definition.constructor) {\n     \t\t            identifiers.set(definition.constructor, identifier);\n     \t\t            registeredTypes[identifier] = definition;\n     \t\t        }\n     \t\t        if (definition.encode) {\n     \t\t            encode[identifier] = definition.encode;\n     \t\t        }\n     \t\t        if (definition.decode) {\n     \t\t            decode[identifier] = definition.decode;\n     \t\t        }\n     \t\t    }\n     \t\t    function getType(identifier) {\n     \t\t        return registeredTypes[identifier];\n     \t\t    }\n     \t\t    function defineCustomTypes(types) {\n     \t\t        for (const identifier in types) {\n     \t\t            registerType(identifier, types[identifier]);\n     \t\t        }\n     \t\t        return (t) => type(t);\n     \t\t    }\n\n     \t\t    class TypeContext {\n     \t\t        /**\n     \t\t         * For inheritance support\n     \t\t         * Keeps track of which classes extends which. (parent -> children)\n     \t\t         */\n     \t\t        static { this.inheritedTypes = new Map(); }\n     \t\t        static { this.cachedContexts = new Map(); }\n     \t\t        static register(target) {\n     \t\t            const parent = Object.getPrototypeOf(target);\n     \t\t            if (parent !== Schema) {\n     \t\t                let inherits = TypeContext.inheritedTypes.get(parent);\n     \t\t                if (!inherits) {\n     \t\t                    inherits = new Set();\n     \t\t                    TypeContext.inheritedTypes.set(parent, inherits);\n     \t\t                }\n     \t\t                inherits.add(target);\n     \t\t            }\n     \t\t        }\n     \t\t        static cache(rootClass) {\n     \t\t            let context = TypeContext.cachedContexts.get(rootClass);\n     \t\t            if (!context) {\n     \t\t                context = new TypeContext(rootClass);\n     \t\t                TypeContext.cachedContexts.set(rootClass, context);\n     \t\t            }\n     \t\t            return context;\n     \t\t        }\n     \t\t        constructor(rootClass) {\n     \t\t            this.types = {};\n     \t\t            this.schemas = new Map();\n     \t\t            this.hasFilters = false;\n     \t\t            this.parentFiltered = {};\n     \t\t            if (rootClass) {\n     \t\t                this.discoverTypes(rootClass);\n     \t\t            }\n     \t\t        }\n     \t\t        has(schema) {\n     \t\t            return this.schemas.has(schema);\n     \t\t        }\n     \t\t        get(typeid) {\n     \t\t            return this.types[typeid];\n     \t\t        }\n     \t\t        add(schema, typeid = this.schemas.size) {\n     \t\t            // skip if already registered\n     \t\t            if (this.schemas.has(schema)) {\n     \t\t                return false;\n     \t\t            }\n     \t\t            this.types[typeid] = schema;\n     \t\t            //\n     \t\t            // Workaround to allow using an empty Schema (with no `@type()` fields)\n     \t\t            //\n     \t\t            if (schema[Symbol.metadata] === undefined) {\n     \t\t                Metadata.initialize(schema);\n     \t\t            }\n     \t\t            this.schemas.set(schema, typeid);\n     \t\t            return true;\n     \t\t        }\n     \t\t        getTypeId(klass) {\n     \t\t            return this.schemas.get(klass);\n     \t\t        }\n     \t\t        discoverTypes(klass, parentType, parentIndex, parentHasViewTag) {\n     \t\t            if (parentHasViewTag) {\n     \t\t                this.registerFilteredByParent(klass, parentType, parentIndex);\n     \t\t            }\n     \t\t            // skip if already registered\n     \t\t            if (!this.add(klass)) {\n     \t\t                return;\n     \t\t            }\n     \t\t            // add classes inherited from this base class\n     \t\t            TypeContext.inheritedTypes.get(klass)?.forEach((child) => {\n     \t\t                this.discoverTypes(child, parentType, parentIndex, parentHasViewTag);\n     \t\t            });\n     \t\t            // add parent classes\n     \t\t            let parent = klass;\n     \t\t            while ((parent = Object.getPrototypeOf(parent)) &&\n     \t\t                parent !== Schema && // stop at root (Schema)\n     \t\t                parent !== Function.prototype // stop at root (non-Schema)\n     \t\t            ) {\n     \t\t                this.discoverTypes(parent);\n     \t\t            }\n     \t\t            const metadata = (klass[Symbol.metadata] ??= {});\n     \t\t            // if any schema/field has filters, mark \"context\" as having filters.\n     \t\t            if (metadata[$viewFieldIndexes]) {\n     \t\t                this.hasFilters = true;\n     \t\t            }\n     \t\t            for (const fieldIndex in metadata) {\n     \t\t                const index = fieldIndex;\n     \t\t                const fieldType = metadata[index].type;\n     \t\t                const fieldHasViewTag = (metadata[index].tag !== undefined);\n     \t\t                if (typeof (fieldType) === \"string\") {\n     \t\t                    continue;\n     \t\t                }\n     \t\t                if (Array.isArray(fieldType)) {\n     \t\t                    const type = fieldType[0];\n     \t\t                    // skip primitive types\n     \t\t                    if (type === \"string\") {\n     \t\t                        continue;\n     \t\t                    }\n     \t\t                    this.discoverTypes(type, klass, index, parentHasViewTag || fieldHasViewTag);\n     \t\t                }\n     \t\t                else if (typeof (fieldType) === \"function\") {\n     \t\t                    this.discoverTypes(fieldType, klass, index, parentHasViewTag || fieldHasViewTag);\n     \t\t                }\n     \t\t                else {\n     \t\t                    const type = Object.values(fieldType)[0];\n     \t\t                    // skip primitive types\n     \t\t                    if (typeof (type) === \"string\") {\n     \t\t                        continue;\n     \t\t                    }\n     \t\t                    this.discoverTypes(type, klass, index, parentHasViewTag || fieldHasViewTag);\n     \t\t                }\n     \t\t            }\n     \t\t        }\n     \t\t        /**\n     \t\t         * Keep track of which classes have filters applied.\n     \t\t         * Format: `${typeid}-${parentTypeid}-${parentIndex}`\n     \t\t         */\n     \t\t        registerFilteredByParent(schema, parentType, parentIndex) {\n     \t\t            const typeid = this.schemas.get(schema) ?? this.schemas.size;\n     \t\t            let key = `${typeid}`;\n     \t\t            if (parentType) {\n     \t\t                key += `-${this.schemas.get(parentType)}`;\n     \t\t            }\n     \t\t            key += `-${parentIndex}`;\n     \t\t            this.parentFiltered[key] = true;\n     \t\t        }\n     \t\t        debug() {\n     \t\t            let parentFiltered = \"\";\n     \t\t            for (const key in this.parentFiltered) {\n     \t\t                const keys = key.split(\"-\").map(Number);\n     \t\t                const fieldIndex = keys.pop();\n     \t\t                parentFiltered += `\\n\\t\\t`;\n     \t\t                parentFiltered += `${key}: ${keys.reverse().map((id, i) => {\n \t\t                const klass = this.types[id];\n \t\t                const metadata = klass[Symbol.metadata];\n \t\t                let txt = klass.name;\n \t\t                if (i === 0) {\n \t\t                    txt += `[${metadata[fieldIndex].name}]`;\n \t\t                }\n \t\t                return `${txt}`;\n \t\t            }).join(\" -> \")}`;\n     \t\t            }\n     \t\t            return `TypeContext ->\\n` +\n     \t\t                `\\tSchema types: ${this.schemas.size}\\n` +\n     \t\t                `\\thasFilters: ${this.hasFilters}\\n` +\n     \t\t                `\\tparentFiltered:${parentFiltered}`;\n     \t\t        }\n     \t\t    }\n\n     \t\t    function getNormalizedType(type) {\n     \t\t        return (Array.isArray(type))\n     \t\t            ? { array: type[0] }\n     \t\t            : (typeof (type['type']) !== \"undefined\")\n     \t\t                ? type['type']\n     \t\t                : type;\n     \t\t    }\n     \t\t    const Metadata = {\n     \t\t        addField(metadata, index, name, type, descriptor) {\n     \t\t            if (index > 64) {\n     \t\t                throw new Error(`Can't define field '${name}'.\\nSchema instances may only have up to 64 fields.`);\n     \t\t            }\n     \t\t            metadata[index] = Object.assign(metadata[index] || {}, // avoid overwriting previous field metadata (@owned / @deprecated)\n     \t\t            {\n     \t\t                type: getNormalizedType(type),\n     \t\t                index,\n     \t\t                name,\n     \t\t            });\n     \t\t            // create \"descriptors\" map\n     \t\t            Object.defineProperty(metadata, $descriptors, {\n     \t\t                value: metadata[$descriptors] || {},\n     \t\t                enumerable: false,\n     \t\t                configurable: true,\n     \t\t            });\n     \t\t            if (descriptor) {\n     \t\t                // for encoder\n     \t\t                metadata[$descriptors][name] = descriptor;\n     \t\t                metadata[$descriptors][`_${name}`] = {\n     \t\t                    value: undefined,\n     \t\t                    writable: true,\n     \t\t                    enumerable: false,\n     \t\t                    configurable: true,\n     \t\t                };\n     \t\t            }\n     \t\t            else {\n     \t\t                // for decoder\n     \t\t                metadata[$descriptors][name] = {\n     \t\t                    value: undefined,\n     \t\t                    writable: true,\n     \t\t                    enumerable: true,\n     \t\t                    configurable: true,\n     \t\t                };\n     \t\t            }\n     \t\t            // map -1 as last field index\n     \t\t            Object.defineProperty(metadata, $numFields, {\n     \t\t                value: index,\n     \t\t                enumerable: false,\n     \t\t                configurable: true\n     \t\t            });\n     \t\t            // map field name => index (non enumerable)\n     \t\t            Object.defineProperty(metadata, name, {\n     \t\t                value: index,\n     \t\t                enumerable: false,\n     \t\t                configurable: true,\n     \t\t            });\n     \t\t            // if child Ref/complex type, add to -4\n     \t\t            if (typeof (metadata[index].type) !== \"string\") {\n     \t\t                if (metadata[$refTypeFieldIndexes] === undefined) {\n     \t\t                    Object.defineProperty(metadata, $refTypeFieldIndexes, {\n     \t\t                        value: [],\n     \t\t                        enumerable: false,\n     \t\t                        configurable: true,\n     \t\t                    });\n     \t\t                }\n     \t\t                metadata[$refTypeFieldIndexes].push(index);\n     \t\t            }\n     \t\t        },\n     \t\t        setTag(metadata, fieldName, tag) {\n     \t\t            const index = metadata[fieldName];\n     \t\t            const field = metadata[index];\n     \t\t            // add 'tag' to the field\n     \t\t            field.tag = tag;\n     \t\t            if (!metadata[$viewFieldIndexes]) {\n     \t\t                // -2: all field indexes with \"view\" tag\n     \t\t                Object.defineProperty(metadata, $viewFieldIndexes, {\n     \t\t                    value: [],\n     \t\t                    enumerable: false,\n     \t\t                    configurable: true\n     \t\t                });\n     \t\t                // -3: field indexes by \"view\" tag\n     \t\t                Object.defineProperty(metadata, $fieldIndexesByViewTag, {\n     \t\t                    value: {},\n     \t\t                    enumerable: false,\n     \t\t                    configurable: true\n     \t\t                });\n     \t\t            }\n     \t\t            metadata[$viewFieldIndexes].push(index);\n     \t\t            if (!metadata[$fieldIndexesByViewTag][tag]) {\n     \t\t                metadata[$fieldIndexesByViewTag][tag] = [];\n     \t\t            }\n     \t\t            metadata[$fieldIndexesByViewTag][tag].push(index);\n     \t\t        },\n     \t\t        setFields(target, fields) {\n     \t\t            // for inheritance support\n     \t\t            const constructor = target.prototype.constructor;\n     \t\t            TypeContext.register(constructor);\n     \t\t            const parentClass = Object.getPrototypeOf(constructor);\n     \t\t            const parentMetadata = parentClass && parentClass[Symbol.metadata];\n     \t\t            const metadata = Metadata.initialize(constructor);\n     \t\t            // Use Schema's methods if not defined in the class\n     \t\t            if (!constructor[$track]) {\n     \t\t                constructor[$track] = Schema[$track];\n     \t\t            }\n     \t\t            if (!constructor[$encoder]) {\n     \t\t                constructor[$encoder] = Schema[$encoder];\n     \t\t            }\n     \t\t            if (!constructor[$decoder]) {\n     \t\t                constructor[$decoder] = Schema[$decoder];\n     \t\t            }\n     \t\t            if (!constructor.prototype.toJSON) {\n     \t\t                constructor.prototype.toJSON = Schema.prototype.toJSON;\n     \t\t            }\n     \t\t            //\n     \t\t            // detect index for this field, considering inheritance\n     \t\t            //\n     \t\t            let fieldIndex = metadata[$numFields] // current structure already has fields defined\n     \t\t                ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n     \t\t                ?? -1; // no fields defined\n     \t\t            fieldIndex++;\n     \t\t            for (const field in fields) {\n     \t\t                const type = fields[field];\n     \t\t                // FIXME: this code is duplicated from @type() annotation\n     \t\t                const complexTypeKlass = (Array.isArray(type))\n     \t\t                    ? getType(\"array\")\n     \t\t                    : (typeof (Object.keys(type)[0]) === \"string\") && getType(Object.keys(type)[0]);\n     \t\t                const childType = (complexTypeKlass)\n     \t\t                    ? Object.values(type)[0]\n     \t\t                    : getNormalizedType(type);\n     \t\t                Metadata.addField(metadata, fieldIndex, field, type, getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass));\n     \t\t                fieldIndex++;\n     \t\t            }\n     \t\t            return target;\n     \t\t        },\n     \t\t        isDeprecated(metadata, field) {\n     \t\t            return metadata[field].deprecated === true;\n     \t\t        },\n     \t\t        init(klass) {\n     \t\t            //\n     \t\t            // Used only to initialize an empty Schema (Encoder#constructor)\n     \t\t            // TODO: remove/refactor this...\n     \t\t            //\n     \t\t            const metadata = {};\n     \t\t            klass[Symbol.metadata] = metadata;\n     \t\t            Object.defineProperty(metadata, $numFields, {\n     \t\t                value: 0,\n     \t\t                enumerable: false,\n     \t\t                configurable: true,\n     \t\t            });\n     \t\t        },\n     \t\t        initialize(constructor) {\n     \t\t            const parentClass = Object.getPrototypeOf(constructor);\n     \t\t            const parentMetadata = parentClass[Symbol.metadata];\n     \t\t            let metadata = constructor[Symbol.metadata] ?? Object.create(null);\n     \t\t            // make sure inherited classes have their own metadata object.\n     \t\t            if (parentClass !== Schema && metadata === parentMetadata) {\n     \t\t                metadata = Object.create(null);\n     \t\t                if (parentMetadata) {\n     \t\t                    //\n     \t\t                    // assign parent metadata to current\n     \t\t                    //\n     \t\t                    Object.setPrototypeOf(metadata, parentMetadata);\n     \t\t                    // $numFields\n     \t\t                    Object.defineProperty(metadata, $numFields, {\n     \t\t                        value: parentMetadata[$numFields],\n     \t\t                        enumerable: false,\n     \t\t                        configurable: true,\n     \t\t                        writable: true,\n     \t\t                    });\n     \t\t                    // $viewFieldIndexes / $fieldIndexesByViewTag\n     \t\t                    if (parentMetadata[$viewFieldIndexes] !== undefined) {\n     \t\t                        Object.defineProperty(metadata, $viewFieldIndexes, {\n     \t\t                            value: [...parentMetadata[$viewFieldIndexes]],\n     \t\t                            enumerable: false,\n     \t\t                            configurable: true,\n     \t\t                            writable: true,\n     \t\t                        });\n     \t\t                        Object.defineProperty(metadata, $fieldIndexesByViewTag, {\n     \t\t                            value: { ...parentMetadata[$fieldIndexesByViewTag] },\n     \t\t                            enumerable: false,\n     \t\t                            configurable: true,\n     \t\t                            writable: true,\n     \t\t                        });\n     \t\t                    }\n     \t\t                    // $refTypeFieldIndexes\n     \t\t                    if (parentMetadata[$refTypeFieldIndexes] !== undefined) {\n     \t\t                        Object.defineProperty(metadata, $refTypeFieldIndexes, {\n     \t\t                            value: [...parentMetadata[$refTypeFieldIndexes]],\n     \t\t                            enumerable: false,\n     \t\t                            configurable: true,\n     \t\t                            writable: true,\n     \t\t                        });\n     \t\t                    }\n     \t\t                    // $descriptors\n     \t\t                    Object.defineProperty(metadata, $descriptors, {\n     \t\t                        value: { ...parentMetadata[$descriptors] },\n     \t\t                        enumerable: false,\n     \t\t                        configurable: true,\n     \t\t                        writable: true,\n     \t\t                    });\n     \t\t                }\n     \t\t            }\n     \t\t            constructor[Symbol.metadata] = metadata;\n     \t\t            return metadata;\n     \t\t        },\n     \t\t        isValidInstance(klass) {\n     \t\t            return (klass.constructor[Symbol.metadata] &&\n     \t\t                Object.prototype.hasOwnProperty.call(klass.constructor[Symbol.metadata], $numFields));\n     \t\t        },\n     \t\t        getFields(klass) {\n     \t\t            const metadata = klass[Symbol.metadata];\n     \t\t            const fields = {};\n     \t\t            for (let i = 0; i <= metadata[$numFields]; i++) {\n     \t\t                fields[metadata[i].name] = metadata[i].type;\n     \t\t            }\n     \t\t            return fields;\n     \t\t        },\n     \t\t        hasViewTagAtIndex(metadata, index) {\n     \t\t            return metadata?.[$viewFieldIndexes]?.includes(index);\n     \t\t        }\n     \t\t    };\n\n     \t\t    function createChangeSet() {\n     \t\t        return { indexes: {}, operations: [] };\n     \t\t    }\n     \t\t    function setOperationAtIndex(changeSet, index) {\n     \t\t        const operationsIndex = changeSet.indexes[index];\n     \t\t        if (operationsIndex === undefined) {\n     \t\t            changeSet.indexes[index] = changeSet.operations.push(index) - 1;\n     \t\t        }\n     \t\t        else {\n     \t\t            changeSet.operations[operationsIndex] = index;\n     \t\t        }\n     \t\t    }\n     \t\t    function deleteOperationAtIndex(changeSet, index) {\n     \t\t        let operationsIndex = changeSet.indexes[index];\n     \t\t        if (operationsIndex === undefined) {\n     \t\t            //\n     \t\t            // if index is not found, we need to find the last operation\n     \t\t            // FIXME: this is not very efficient\n     \t\t            //\n     \t\t            // > See \"should allow consecutive splices (same place)\" tests\n     \t\t            //\n     \t\t            operationsIndex = Object.values(changeSet.indexes).at(-1);\n     \t\t            index = Object.entries(changeSet.indexes).find(([_, value]) => value === operationsIndex)?.[0];\n     \t\t        }\n     \t\t        changeSet.operations[operationsIndex] = undefined;\n     \t\t        delete changeSet.indexes[index];\n     \t\t    }\n     \t\t    function enqueueChangeTree(root, changeTree, changeSet, queueRootIndex = changeTree[changeSet].queueRootIndex) {\n     \t\t        if (!root) {\n     \t\t            // skip\n     \t\t            return;\n     \t\t        }\n     \t\t        else if (root[changeSet][queueRootIndex] !== changeTree) {\n     \t\t            changeTree[changeSet].queueRootIndex = root[changeSet].push(changeTree) - 1;\n     \t\t        }\n     \t\t    }\n     \t\t    class ChangeTree {\n     \t\t        constructor(ref) {\n     \t\t            /**\n     \t\t             * Whether this structure is parent of a filtered structure.\n     \t\t             */\n     \t\t            this.isFiltered = false;\n     \t\t            this.indexedOperations = {};\n     \t\t            //\n     \t\t            // TODO:\n     \t\t            //   try storing the index + operation per item.\n     \t\t            //   example: 1024 & 1025 => ADD, 1026 => DELETE\n     \t\t            //\n     \t\t            // => https://chatgpt.com/share/67107d0c-bc20-8004-8583-83b17dd7c196\n     \t\t            //\n     \t\t            this.changes = { indexes: {}, operations: [] };\n     \t\t            this.allChanges = { indexes: {}, operations: [] };\n     \t\t            /**\n     \t\t             * Is this a new instance? Used on ArraySchema to determine OPERATION.MOVE_AND_ADD operation.\n     \t\t             */\n     \t\t            this.isNew = true;\n     \t\t            this.ref = ref;\n     \t\t            //\n     \t\t            // Does this structure have \"filters\" declared?\n     \t\t            //\n     \t\t            const metadata = ref.constructor[Symbol.metadata];\n     \t\t            if (metadata?.[$viewFieldIndexes]) {\n     \t\t                this.allFilteredChanges = { indexes: {}, operations: [] };\n     \t\t                this.filteredChanges = { indexes: {}, operations: [] };\n     \t\t            }\n     \t\t        }\n     \t\t        setRoot(root) {\n     \t\t            this.root = root;\n     \t\t            this.checkIsFiltered(this.parent, this.parentIndex);\n     \t\t            // Recursively set root on child structures\n     \t\t            const metadata = this.ref.constructor[Symbol.metadata];\n     \t\t            if (metadata) {\n     \t\t                metadata[$refTypeFieldIndexes]?.forEach((index) => {\n     \t\t                    const field = metadata[index];\n     \t\t                    const value = this.ref[field.name];\n     \t\t                    value?.[$changes].setRoot(root);\n     \t\t                });\n     \t\t            }\n     \t\t            else if (this.ref[$childType] && typeof (this.ref[$childType]) !== \"string\") {\n     \t\t                // MapSchema / ArraySchema, etc.\n     \t\t                this.ref.forEach((value, key) => {\n     \t\t                    value[$changes].setRoot(root);\n     \t\t                });\n     \t\t            }\n     \t\t        }\n     \t\t        setParent(parent, root, parentIndex) {\n     \t\t            this.parent = parent;\n     \t\t            this.parentIndex = parentIndex;\n     \t\t            // avoid setting parents with empty `root`\n     \t\t            if (!root) {\n     \t\t                return;\n     \t\t            }\n     \t\t            // skip if parent is already set\n     \t\t            if (root !== this.root) {\n     \t\t                this.root = root;\n     \t\t                this.checkIsFiltered(parent, parentIndex);\n     \t\t            }\n     \t\t            else {\n     \t\t                root.add(this);\n     \t\t            }\n     \t\t            // assign same parent on child structures\n     \t\t            const metadata = this.ref.constructor[Symbol.metadata];\n     \t\t            if (metadata) {\n     \t\t                metadata[$refTypeFieldIndexes]?.forEach((index) => {\n     \t\t                    const field = metadata[index];\n     \t\t                    const value = this.ref[field.name];\n     \t\t                    value?.[$changes].setParent(this.ref, root, index);\n     \t\t                });\n     \t\t            }\n     \t\t            else if (this.ref[$childType] && typeof (this.ref[$childType]) !== \"string\") {\n     \t\t                // MapSchema / ArraySchema, etc.\n     \t\t                this.ref.forEach((value, key) => {\n     \t\t                    value[$changes].setParent(this.ref, root, this.indexes[key] ?? key);\n     \t\t                });\n     \t\t            }\n     \t\t        }\n     \t\t        forEachChild(callback) {\n     \t\t            //\n     \t\t            // assign same parent on child structures\n     \t\t            //\n     \t\t            const metadata = this.ref.constructor[Symbol.metadata];\n     \t\t            if (metadata) {\n     \t\t                metadata[$refTypeFieldIndexes]?.forEach((index) => {\n     \t\t                    const field = metadata[index];\n     \t\t                    const value = this.ref[field.name];\n     \t\t                    if (value) {\n     \t\t                        callback(value[$changes], index);\n     \t\t                    }\n     \t\t                });\n     \t\t            }\n     \t\t            else if (this.ref[$childType] && typeof (this.ref[$childType]) !== \"string\") {\n     \t\t                // MapSchema / ArraySchema, etc.\n     \t\t                this.ref.forEach((value, key) => {\n     \t\t                    callback(value[$changes], this.indexes[key] ?? key);\n     \t\t                });\n     \t\t            }\n     \t\t        }\n     \t\t        operation(op) {\n     \t\t            // operations without index use negative values to represent them\n     \t\t            // this is checked during .encode() time.\n     \t\t            if (this.filteredChanges !== undefined) {\n     \t\t                this.filteredChanges.operations.push(-op);\n     \t\t                enqueueChangeTree(this.root, this, 'filteredChanges');\n     \t\t            }\n     \t\t            else {\n     \t\t                this.changes.operations.push(-op);\n     \t\t                enqueueChangeTree(this.root, this, 'changes');\n     \t\t            }\n     \t\t        }\n     \t\t        change(index, operation = exports.OPERATION.ADD) {\n     \t\t            const metadata = this.ref.constructor[Symbol.metadata];\n     \t\t            const isFiltered = this.isFiltered || (metadata?.[index]?.tag !== undefined);\n     \t\t            const changeSet = (isFiltered)\n     \t\t                ? this.filteredChanges\n     \t\t                : this.changes;\n     \t\t            const previousOperation = this.indexedOperations[index];\n     \t\t            if (!previousOperation || previousOperation === exports.OPERATION.DELETE) {\n     \t\t                const op = (!previousOperation)\n     \t\t                    ? operation\n     \t\t                    : (previousOperation === exports.OPERATION.DELETE)\n     \t\t                        ? exports.OPERATION.DELETE_AND_ADD\n     \t\t                        : operation;\n     \t\t                //\n     \t\t                // TODO: are DELETE operations being encoded as ADD here ??\n     \t\t                //\n     \t\t                this.indexedOperations[index] = op;\n     \t\t            }\n     \t\t            setOperationAtIndex(changeSet, index);\n     \t\t            if (isFiltered) {\n     \t\t                setOperationAtIndex(this.allFilteredChanges, index);\n     \t\t                if (this.root) {\n     \t\t                    enqueueChangeTree(this.root, this, 'filteredChanges');\n     \t\t                    enqueueChangeTree(this.root, this, 'allFilteredChanges');\n     \t\t                }\n     \t\t            }\n     \t\t            else {\n     \t\t                setOperationAtIndex(this.allChanges, index);\n     \t\t                enqueueChangeTree(this.root, this, 'changes');\n     \t\t            }\n     \t\t        }\n     \t\t        shiftChangeIndexes(shiftIndex) {\n     \t\t            //\n     \t\t            // Used only during:\n     \t\t            //\n     \t\t            // - ArraySchema#unshift()\n     \t\t            //\n     \t\t            const changeSet = (this.isFiltered)\n     \t\t                ? this.filteredChanges\n     \t\t                : this.changes;\n     \t\t            const newIndexedOperations = {};\n     \t\t            const newIndexes = {};\n     \t\t            for (const index in this.indexedOperations) {\n     \t\t                newIndexedOperations[Number(index) + shiftIndex] = this.indexedOperations[index];\n     \t\t                newIndexes[Number(index) + shiftIndex] = changeSet.indexes[index];\n     \t\t            }\n     \t\t            this.indexedOperations = newIndexedOperations;\n     \t\t            changeSet.indexes = newIndexes;\n     \t\t            changeSet.operations = changeSet.operations.map((index) => index + shiftIndex);\n     \t\t        }\n     \t\t        shiftAllChangeIndexes(shiftIndex, startIndex = 0) {\n     \t\t            //\n     \t\t            // Used only during:\n     \t\t            //\n     \t\t            // - ArraySchema#splice()\n     \t\t            //\n     \t\t            if (this.filteredChanges !== undefined) {\n     \t\t                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allFilteredChanges);\n     \t\t                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);\n     \t\t            }\n     \t\t            else {\n     \t\t                this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);\n     \t\t            }\n     \t\t        }\n     \t\t        _shiftAllChangeIndexes(shiftIndex, startIndex = 0, changeSet) {\n     \t\t            const newIndexes = {};\n     \t\t            let newKey = 0;\n     \t\t            for (const key in changeSet.indexes) {\n     \t\t                newIndexes[newKey++] = changeSet.indexes[key];\n     \t\t            }\n     \t\t            changeSet.indexes = newIndexes;\n     \t\t            for (let i = 0; i < changeSet.operations.length; i++) {\n     \t\t                const index = changeSet.operations[i];\n     \t\t                if (index > startIndex) {\n     \t\t                    changeSet.operations[i] = index + shiftIndex;\n     \t\t                }\n     \t\t            }\n     \t\t        }\n     \t\t        indexedOperation(index, operation, allChangesIndex = index) {\n     \t\t            this.indexedOperations[index] = operation;\n     \t\t            if (this.filteredChanges !== undefined) {\n     \t\t                setOperationAtIndex(this.allFilteredChanges, allChangesIndex);\n     \t\t                setOperationAtIndex(this.filteredChanges, index);\n     \t\t                enqueueChangeTree(this.root, this, 'filteredChanges');\n     \t\t            }\n     \t\t            else {\n     \t\t                setOperationAtIndex(this.allChanges, allChangesIndex);\n     \t\t                setOperationAtIndex(this.changes, index);\n     \t\t                enqueueChangeTree(this.root, this, 'changes');\n     \t\t            }\n     \t\t        }\n     \t\t        getType(index) {\n     \t\t            if (Metadata.isValidInstance(this.ref)) {\n     \t\t                const metadata = this.ref.constructor[Symbol.metadata];\n     \t\t                return metadata[index].type;\n     \t\t            }\n     \t\t            else {\n     \t\t                //\n     \t\t                // Get the child type from parent structure.\n     \t\t                // - [\"string\"] => \"string\"\n     \t\t                // - { map: \"string\" } => \"string\"\n     \t\t                // - { set: \"string\" } => \"string\"\n     \t\t                //\n     \t\t                return this.ref[$childType];\n     \t\t            }\n     \t\t        }\n     \t\t        getChange(index) {\n     \t\t            return this.indexedOperations[index];\n     \t\t        }\n     \t\t        //\n     \t\t        // used during `.encode()`\n     \t\t        //\n     \t\t        getValue(index, isEncodeAll = false) {\n     \t\t            //\n     \t\t            // `isEncodeAll` param is only used by ArraySchema\n     \t\t            //\n     \t\t            return this.ref[$getByIndex](index, isEncodeAll);\n     \t\t        }\n     \t\t        delete(index, operation, allChangesIndex = index) {\n     \t\t            if (index === undefined) {\n     \t\t                try {\n     \t\t                    throw new Error(`@colyseus/schema ${this.ref.constructor.name}: trying to delete non-existing index '${index}'`);\n     \t\t                }\n     \t\t                catch (e) {\n     \t\t                    console.warn(e);\n     \t\t                }\n     \t\t                return;\n     \t\t            }\n     \t\t            const changeSet = (this.filteredChanges !== undefined)\n     \t\t                ? this.filteredChanges\n     \t\t                : this.changes;\n     \t\t            this.indexedOperations[index] = operation ?? exports.OPERATION.DELETE;\n     \t\t            setOperationAtIndex(changeSet, index);\n     \t\t            deleteOperationAtIndex(this.allChanges, allChangesIndex);\n     \t\t            const previousValue = this.getValue(index);\n     \t\t            // remove `root` reference\n     \t\t            if (previousValue && previousValue[$changes]) {\n     \t\t                //\n     \t\t                // FIXME: this.root is \"undefined\"\n     \t\t                //\n     \t\t                // This method is being called at decoding time when a DELETE operation is found.\n     \t\t                //\n     \t\t                // - This is due to using the concrete Schema class at decoding time.\n     \t\t                // - \"Reflected\" structures do not have this problem.\n     \t\t                //\n     \t\t                // (The property descriptors should NOT be used at decoding time. only at encoding time.)\n     \t\t                //\n     \t\t                this.root?.remove(previousValue[$changes]);\n     \t\t            }\n     \t\t            //\n     \t\t            // FIXME: this is looking a ugly and repeated\n     \t\t            //\n     \t\t            if (this.filteredChanges !== undefined) {\n     \t\t                deleteOperationAtIndex(this.allFilteredChanges, allChangesIndex);\n     \t\t                enqueueChangeTree(this.root, this, 'filteredChanges');\n     \t\t            }\n     \t\t            else {\n     \t\t                enqueueChangeTree(this.root, this, 'changes');\n     \t\t            }\n     \t\t            return previousValue;\n     \t\t        }\n     \t\t        endEncode(changeSetName) {\n     \t\t            this.indexedOperations = {};\n     \t\t            // clear changeset\n     \t\t            this[changeSetName].indexes = {};\n     \t\t            this[changeSetName].operations.length = 0;\n     \t\t            this[changeSetName].queueRootIndex = undefined;\n     \t\t            // ArraySchema and MapSchema have a custom \"encode end\" method\n     \t\t            this.ref[$onEncodeEnd]?.();\n     \t\t            // Not a new instance anymore\n     \t\t            this.isNew = false;\n     \t\t        }\n     \t\t        discard(discardAll = false) {\n     \t\t            //\n     \t\t            // > MapSchema:\n     \t\t            //      Remove cached key to ensure ADD operations is unsed instead of\n     \t\t            //      REPLACE in case same key is used on next patches.\n     \t\t            //\n     \t\t            this.ref[$onEncodeEnd]?.();\n     \t\t            this.indexedOperations = {};\n     \t\t            this.changes.indexes = {};\n     \t\t            this.changes.operations.length = 0;\n     \t\t            this.changes.queueRootIndex = undefined;\n     \t\t            if (this.filteredChanges !== undefined) {\n     \t\t                this.filteredChanges.indexes = {};\n     \t\t                this.filteredChanges.operations.length = 0;\n     \t\t                this.filteredChanges.queueRootIndex = undefined;\n     \t\t            }\n     \t\t            if (discardAll) {\n     \t\t                this.allChanges.indexes = {};\n     \t\t                this.allChanges.operations.length = 0;\n     \t\t                if (this.allFilteredChanges !== undefined) {\n     \t\t                    this.allFilteredChanges.indexes = {};\n     \t\t                    this.allFilteredChanges.operations.length = 0;\n     \t\t                }\n     \t\t                // remove children references\n     \t\t                this.forEachChild((changeTree, _) => this.root?.remove(changeTree));\n     \t\t            }\n     \t\t        }\n     \t\t        /**\n     \t\t         * Recursively discard all changes from this, and child structures.\n     \t\t         */\n     \t\t        discardAll() {\n     \t\t            const keys = Object.keys(this.indexedOperations);\n     \t\t            for (let i = 0, len = keys.length; i < len; i++) {\n     \t\t                const value = this.getValue(Number(keys[i]));\n     \t\t                if (value && value[$changes]) {\n     \t\t                    value[$changes].discardAll();\n     \t\t                }\n     \t\t            }\n     \t\t            this.discard();\n     \t\t        }\n     \t\t        ensureRefId() {\n     \t\t            // skip if refId is already set.\n     \t\t            if (this.refId !== undefined) {\n     \t\t                return;\n     \t\t            }\n     \t\t            this.refId = this.root.getNextUniqueId();\n     \t\t        }\n     \t\t        get changed() {\n     \t\t            return (Object.entries(this.indexedOperations).length > 0);\n     \t\t        }\n     \t\t        checkIsFiltered(parent, parentIndex) {\n     \t\t            const isNewChangeTree = this.root.add(this);\n     \t\t            if (this.root.types.hasFilters) {\n     \t\t                //\n     \t\t                // At Schema initialization, the \"root\" structure might not be available\n     \t\t                // yet, as it only does once the \"Encoder\" has been set up.\n     \t\t                //\n     \t\t                // So the \"parent\" may be already set without a \"root\".\n     \t\t                //\n     \t\t                this._checkFilteredByParent(parent, parentIndex);\n     \t\t                if (this.filteredChanges !== undefined) {\n     \t\t                    enqueueChangeTree(this.root, this, 'filteredChanges');\n     \t\t                    if (isNewChangeTree) {\n     \t\t                        this.root.allFilteredChanges.push(this);\n     \t\t                    }\n     \t\t                }\n     \t\t            }\n     \t\t            if (!this.isFiltered) {\n     \t\t                enqueueChangeTree(this.root, this, 'changes');\n     \t\t                if (isNewChangeTree) {\n     \t\t                    this.root.allChanges.push(this);\n     \t\t                }\n     \t\t            }\n     \t\t        }\n     \t\t        _checkFilteredByParent(parent, parentIndex) {\n     \t\t            // skip if parent is not set\n     \t\t            if (!parent) {\n     \t\t                return;\n     \t\t            }\n     \t\t            //\n     \t\t            // ArraySchema | MapSchema - get the child type\n     \t\t            // (if refType is typeof string, the parentFiltered[key] below will always be invalid)\n     \t\t            //\n     \t\t            const refType = Metadata.isValidInstance(this.ref)\n     \t\t                ? this.ref.constructor\n     \t\t                : this.ref[$childType];\n     \t\t            let parentChangeTree;\n     \t\t            let parentIsCollection = !Metadata.isValidInstance(parent);\n     \t\t            if (parentIsCollection) {\n     \t\t                parentChangeTree = parent[$changes];\n     \t\t                parent = parentChangeTree.parent;\n     \t\t                parentIndex = parentChangeTree.parentIndex;\n     \t\t            }\n     \t\t            else {\n     \t\t                parentChangeTree = parent[$changes];\n     \t\t            }\n     \t\t            const parentConstructor = parent.constructor;\n     \t\t            let key = `${this.root.types.getTypeId(refType)}`;\n     \t\t            if (parentConstructor) {\n     \t\t                key += `-${this.root.types.schemas.get(parentConstructor)}`;\n     \t\t            }\n     \t\t            key += `-${parentIndex}`;\n     \t\t            const fieldHasViewTag = Metadata.hasViewTagAtIndex(parentConstructor?.[Symbol.metadata], parentIndex);\n     \t\t            this.isFiltered = parent[$changes].isFiltered // in case parent is already filtered\n     \t\t                || this.root.types.parentFiltered[key]\n     \t\t                || fieldHasViewTag;\n     \t\t            //\n     \t\t            // \"isFiltered\" may not be imedialely available during `change()` due to the instance not being attached to the root yet.\n     \t\t            // when it's available, we need to enqueue the \"changes\" changeset into the \"filteredChanges\" changeset.\n     \t\t            //\n     \t\t            if (this.isFiltered) {\n     \t\t                this.isVisibilitySharedWithParent = (parentChangeTree.isFiltered &&\n     \t\t                    typeof (refType) !== \"string\" &&\n     \t\t                    !fieldHasViewTag &&\n     \t\t                    parentIsCollection);\n     \t\t                if (!this.filteredChanges) {\n     \t\t                    this.filteredChanges = createChangeSet();\n     \t\t                    this.allFilteredChanges = createChangeSet();\n     \t\t                }\n     \t\t                if (this.changes.operations.length > 0) {\n     \t\t                    this.changes.operations.forEach((index) => setOperationAtIndex(this.filteredChanges, index));\n     \t\t                    this.allChanges.operations.forEach((index) => setOperationAtIndex(this.allFilteredChanges, index));\n     \t\t                    this.changes = createChangeSet();\n     \t\t                    this.allChanges = createChangeSet();\n     \t\t                }\n     \t\t            }\n     \t\t        }\n     \t\t    }\n\n     \t\t    function encodeValue(encoder, bytes, type, value, operation, it) {\n     \t\t        if (typeof (type) === \"string\") {\n     \t\t            encode[type]?.(bytes, value, it);\n     \t\t        }\n     \t\t        else if (type[Symbol.metadata] !== undefined) {\n     \t\t            //\n     \t\t            // Encode refId for this instance.\n     \t\t            // The actual instance is going to be encoded on next `changeTree` iteration.\n     \t\t            //\n     \t\t            encode.number(bytes, value[$changes].refId, it);\n     \t\t            // Try to encode inherited TYPE_ID if it's an ADD operation.\n     \t\t            if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) {\n     \t\t                encoder.tryEncodeTypeId(bytes, type, value.constructor, it);\n     \t\t            }\n     \t\t        }\n     \t\t        else {\n     \t\t            //\n     \t\t            // Encode refId for this instance.\n     \t\t            // The actual instance is going to be encoded on next `changeTree` iteration.\n     \t\t            //\n     \t\t            encode.number(bytes, value[$changes].refId, it);\n     \t\t        }\n     \t\t    }\n     \t\t    /**\n     \t\t     * Used for Schema instances.\n     \t\t     * @private\n     \t\t     */\n     \t\t    const encodeSchemaOperation = function (encoder, bytes, changeTree, index, operation, it, _, __, metadata) {\n     \t\t        // \"compress\" field index + operation\n     \t\t        bytes[it.offset++] = (index | operation) & 255;\n     \t\t        // Do not encode value for DELETE operations\n     \t\t        if (operation === exports.OPERATION.DELETE) {\n     \t\t            return;\n     \t\t        }\n     \t\t        const ref = changeTree.ref;\n     \t\t        const field = metadata[index];\n     \t\t        // TODO: inline this function call small performance gain\n     \t\t        encodeValue(encoder, bytes, metadata[index].type, ref[field.name], operation, it);\n     \t\t    };\n     \t\t    /**\n     \t\t     * Used for collections (MapSchema, CollectionSchema, SetSchema)\n     \t\t     * @private\n     \t\t     */\n     \t\t    const encodeKeyValueOperation = function (encoder, bytes, changeTree, index, operation, it) {\n     \t\t        // encode operation\n     \t\t        bytes[it.offset++] = operation & 255;\n     \t\t        // custom operations\n     \t\t        if (operation === exports.OPERATION.CLEAR) {\n     \t\t            return;\n     \t\t        }\n     \t\t        // encode index\n     \t\t        encode.number(bytes, index, it);\n     \t\t        // Do not encode value for DELETE operations\n     \t\t        if (operation === exports.OPERATION.DELETE) {\n     \t\t            return;\n     \t\t        }\n     \t\t        const ref = changeTree.ref;\n     \t\t        //\n     \t\t        // encode \"alias\" for dynamic fields (maps)\n     \t\t        //\n     \t\t        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD\n     \t\t            if (typeof (ref['set']) === \"function\") {\n     \t\t                //\n     \t\t                // MapSchema dynamic key\n     \t\t                //\n     \t\t                const dynamicIndex = changeTree.ref['$indexes'].get(index);\n     \t\t                encode.string(bytes, dynamicIndex, it);\n     \t\t            }\n     \t\t        }\n     \t\t        const type = ref[$childType];\n     \t\t        const value = ref[$getByIndex](index);\n     \t\t        // try { throw new Error(); } catch (e) {\n     \t\t        //     // only print if not coming from Reflection.ts\n     \t\t        //     if (!e.stack.includes(\"src/Reflection.ts\")) {\n     \t\t        //         console.log(\"encodeKeyValueOperation -> \", {\n     \t\t        //             ref: changeTree.ref.constructor.name,\n     \t\t        //             field,\n     \t\t        //             operation: OPERATION[operation],\n     \t\t        //             value: value?.toJSON(),\n     \t\t        //             items: ref.toJSON(),\n     \t\t        //         });\n     \t\t        //     }\n     \t\t        // }\n     \t\t        // TODO: inline this function call small performance gain\n     \t\t        encodeValue(encoder, bytes, type, value, operation, it);\n     \t\t    };\n     \t\t    /**\n     \t\t     * Used for collections (MapSchema, ArraySchema, etc.)\n     \t\t     * @private\n     \t\t     */\n     \t\t    const encodeArray = function (encoder, bytes, changeTree, field, operation, it, isEncodeAll, hasView) {\n     \t\t        const ref = changeTree.ref;\n     \t\t        const useOperationByRefId = hasView && changeTree.isFiltered && (typeof (changeTree.getType(field)) !== \"string\");\n     \t\t        let refOrIndex;\n     \t\t        if (useOperationByRefId) {\n     \t\t            refOrIndex = ref['tmpItems'][field][$changes].refId;\n     \t\t            if (operation === exports.OPERATION.DELETE) {\n     \t\t                operation = exports.OPERATION.DELETE_BY_REFID;\n     \t\t            }\n     \t\t            else if (operation === exports.OPERATION.ADD) {\n     \t\t                operation = exports.OPERATION.ADD_BY_REFID;\n     \t\t            }\n     \t\t        }\n     \t\t        else {\n     \t\t            refOrIndex = field;\n     \t\t        }\n     \t\t        // encode operation\n     \t\t        bytes[it.offset++] = operation & 255;\n     \t\t        // custom operations\n     \t\t        if (operation === exports.OPERATION.CLEAR ||\n     \t\t            operation === exports.OPERATION.REVERSE) {\n     \t\t            return;\n     \t\t        }\n     \t\t        // encode index\n     \t\t        encode.number(bytes, refOrIndex, it);\n     \t\t        // Do not encode value for DELETE operations\n     \t\t        if (operation === exports.OPERATION.DELETE || operation === exports.OPERATION.DELETE_BY_REFID) {\n     \t\t            return;\n     \t\t        }\n     \t\t        const type = changeTree.getType(field);\n     \t\t        const value = changeTree.getValue(field, isEncodeAll);\n     \t\t        // console.log({ type, field, value });\n     \t\t        // console.log(\"encodeArray -> \", {\n     \t\t        //     ref: changeTree.ref.constructor.name,\n     \t\t        //     field,\n     \t\t        //     operation: OPERATION[operation],\n     \t\t        //     value: value?.toJSON(),\n     \t\t        //     items: ref.toJSON(),\n     \t\t        // });\n     \t\t        // TODO: inline this function call small performance gain\n     \t\t        encodeValue(encoder, bytes, type, value, operation, it);\n     \t\t    };\n\n     \t\t    const DEFINITION_MISMATCH = -1;\n     \t\t    function decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges) {\n     \t\t        const $root = decoder.root;\n     \t\t        const previousValue = ref[$getByIndex](index);\n     \t\t        let value;\n     \t\t        if ((operation & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {\n     \t\t            // Flag `refId` for garbage collection.\n     \t\t            const previousRefId = $root.refIds.get(previousValue);\n     \t\t            if (previousRefId !== undefined) {\n     \t\t                $root.removeRef(previousRefId);\n     \t\t            }\n     \t\t            //\n     \t\t            // Delete operations\n     \t\t            //\n     \t\t            if (operation !== exports.OPERATION.DELETE_AND_ADD) {\n     \t\t                ref[$deleteByIndex](index);\n     \t\t            }\n     \t\t            value = undefined;\n     \t\t        }\n     \t\t        if (operation === exports.OPERATION.DELETE) ;\n     \t\t        else if (Schema.is(type)) {\n     \t\t            const refId = decode.number(bytes, it);\n     \t\t            value = $root.refs.get(refId);\n     \t\t            if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) {\n     \t\t                const childType = decoder.getInstanceType(bytes, it, type);\n     \t\t                if (!value) {\n     \t\t                    value = decoder.createInstanceOfType(childType);\n     \t\t                }\n     \t\t                $root.addRef(refId, value, (value !== previousValue || // increment ref count if value has changed\n     \t\t                    (operation === exports.OPERATION.DELETE_AND_ADD && value === previousValue) // increment ref count if the same instance is being added again\n     \t\t                ));\n     \t\t            }\n     \t\t        }\n     \t\t        else if (typeof (type) === \"string\") {\n     \t\t            //\n     \t\t            // primitive value (number, string, boolean, etc)\n     \t\t            //\n     \t\t            value = decode[type](bytes, it);\n     \t\t        }\n     \t\t        else {\n     \t\t            const typeDef = getType(Object.keys(type)[0]);\n     \t\t            const refId = decode.number(bytes, it);\n     \t\t            const valueRef = ($root.refs.has(refId))\n     \t\t                ? previousValue || $root.refs.get(refId)\n     \t\t                : new typeDef.constructor();\n     \t\t            value = valueRef.clone(true);\n     \t\t            value[$childType] = Object.values(type)[0]; // cache childType for ArraySchema and MapSchema\n     \t\t            if (previousValue) {\n     \t\t                let previousRefId = $root.refIds.get(previousValue);\n     \t\t                if (previousRefId !== undefined && refId !== previousRefId) {\n     \t\t                    //\n     \t\t                    // enqueue onRemove if structure has been replaced.\n     \t\t                    //\n     \t\t                    const entries = previousValue.entries();\n     \t\t                    let iter;\n     \t\t                    while ((iter = entries.next()) && !iter.done) {\n     \t\t                        const [key, value] = iter.value;\n     \t\t                        // if value is a schema, remove its reference\n     \t\t                        if (typeof (value) === \"object\") {\n     \t\t                            previousRefId = $root.refIds.get(value);\n     \t\t                            $root.removeRef(previousRefId);\n     \t\t                        }\n     \t\t                        allChanges.push({\n     \t\t                            ref: previousValue,\n     \t\t                            refId: previousRefId,\n     \t\t                            op: exports.OPERATION.DELETE,\n     \t\t                            field: key,\n     \t\t                            value: undefined,\n     \t\t                            previousValue: value,\n     \t\t                        });\n     \t\t                    }\n     \t\t                }\n     \t\t            }\n     \t\t            $root.addRef(refId, value, (valueRef !== previousValue ||\n     \t\t                (operation === exports.OPERATION.DELETE_AND_ADD && valueRef === previousValue)));\n     \t\t        }\n     \t\t        return { value, previousValue };\n     \t\t    }\n     \t\t    const decodeSchemaOperation = function (decoder, bytes, it, ref, allChanges) {\n     \t\t        const first_byte = bytes[it.offset++];\n     \t\t        const metadata = ref.constructor[Symbol.metadata];\n     \t\t        // \"compressed\" index + operation\n     \t\t        const operation = (first_byte >> 6) << 6;\n     \t\t        const index = first_byte % (operation || 255);\n     \t\t        // skip early if field is not defined\n     \t\t        const field = metadata[index];\n     \t\t        if (field === undefined) {\n     \t\t            console.warn(\"@colyseus/schema: field not defined at\", { index, ref: ref.constructor.name, metadata });\n     \t\t            return DEFINITION_MISMATCH;\n     \t\t        }\n     \t\t        const { value, previousValue } = decodeValue(decoder, operation, ref, index, field.type, bytes, it, allChanges);\n     \t\t        if (value !== null && value !== undefined) {\n     \t\t            ref[field.name] = value;\n     \t\t        }\n     \t\t        // add change\n     \t\t        if (previousValue !== value) {\n     \t\t            allChanges.push({\n     \t\t                ref,\n     \t\t                refId: decoder.currentRefId,\n     \t\t                op: operation,\n     \t\t                field: field.name,\n     \t\t                value,\n     \t\t                previousValue,\n     \t\t            });\n     \t\t        }\n     \t\t    };\n     \t\t    const decodeKeyValueOperation = function (decoder, bytes, it, ref, allChanges) {\n     \t\t        // \"uncompressed\" index + operation (array/map items)\n     \t\t        const operation = bytes[it.offset++];\n     \t\t        if (operation === exports.OPERATION.CLEAR) {\n     \t\t            //\n     \t\t            // When decoding:\n     \t\t            // - enqueue items for DELETE callback.\n     \t\t            // - flag child items for garbage collection.\n     \t\t            //\n     \t\t            decoder.removeChildRefs(ref, allChanges);\n     \t\t            ref.clear();\n     \t\t            return;\n     \t\t        }\n     \t\t        const index = decode.number(bytes, it);\n     \t\t        const type = ref[$childType];\n     \t\t        let dynamicIndex;\n     \t\t        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD\n     \t\t            if (typeof (ref['set']) === \"function\") {\n     \t\t                dynamicIndex = decode.string(bytes, it); // MapSchema\n     \t\t                ref['setIndex'](index, dynamicIndex);\n     \t\t            }\n     \t\t            else {\n     \t\t                dynamicIndex = index; // ArraySchema\n     \t\t            }\n     \t\t        }\n     \t\t        else {\n     \t\t            // get dynamic index from \"ref\"\n     \t\t            dynamicIndex = ref['getIndex'](index);\n     \t\t        }\n     \t\t        const { value, previousValue } = decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges);\n     \t\t        if (value !== null && value !== undefined) {\n     \t\t            if (typeof (ref['set']) === \"function\") {\n     \t\t                // MapSchema\n     \t\t                ref['$items'].set(dynamicIndex, value);\n     \t\t            }\n     \t\t            else if (typeof (ref['$setAt']) === \"function\") {\n     \t\t                // ArraySchema\n     \t\t                ref['$setAt'](index, value, operation);\n     \t\t            }\n     \t\t            else if (typeof (ref['add']) === \"function\") {\n     \t\t                // CollectionSchema && SetSchema\n     \t\t                const index = ref.add(value);\n     \t\t                if (typeof (index) === \"number\") {\n     \t\t                    ref['setIndex'](index, index);\n     \t\t                }\n     \t\t            }\n     \t\t        }\n     \t\t        // add change\n     \t\t        if (previousValue !== value) {\n     \t\t            allChanges.push({\n     \t\t                ref,\n     \t\t                refId: decoder.currentRefId,\n     \t\t                op: operation,\n     \t\t                field: \"\", // FIXME: remove this\n     \t\t                dynamicIndex,\n     \t\t                value,\n     \t\t                previousValue,\n     \t\t            });\n     \t\t        }\n     \t\t    };\n     \t\t    const decodeArray = function (decoder, bytes, it, ref, allChanges) {\n     \t\t        // \"uncompressed\" index + operation (array/map items)\n     \t\t        let operation = bytes[it.offset++];\n     \t\t        let index;\n     \t\t        if (operation === exports.OPERATION.CLEAR) {\n     \t\t            //\n     \t\t            // When decoding:\n     \t\t            // - enqueue items for DELETE callback.\n     \t\t            // - flag child items for garbage collection.\n     \t\t            //\n     \t\t            decoder.removeChildRefs(ref, allChanges);\n     \t\t            ref.clear();\n     \t\t            return;\n     \t\t        }\n     \t\t        else if (operation === exports.OPERATION.REVERSE) {\n     \t\t            ref.reverse();\n     \t\t            return;\n     \t\t        }\n     \t\t        else if (operation === exports.OPERATION.DELETE_BY_REFID) {\n     \t\t            // TODO: refactor here, try to follow same flow as below\n     \t\t            const refId = decode.number(bytes, it);\n     \t\t            const previousValue = decoder.root.refs.get(refId);\n     \t\t            index = ref.findIndex((value) => value === previousValue);\n     \t\t            ref[$deleteByIndex](index);\n     \t\t            allChanges.push({\n     \t\t                ref,\n     \t\t                refId: decoder.currentRefId,\n     \t\t                op: exports.OPERATION.DELETE,\n     \t\t                field: \"\", // FIXME: remove this\n     \t\t                dynamicIndex: index,\n     \t\t                value: undefined,\n     \t\t                previousValue,\n     \t\t            });\n     \t\t            return;\n     \t\t        }\n     \t\t        else if (operation === exports.OPERATION.ADD_BY_REFID) {\n     \t\t            const refId = decode.number(bytes, it);\n     \t\t            const itemByRefId = decoder.root.refs.get(refId);\n     \t\t            // if item already exists, use existing index\n     \t\t            if (itemByRefId) {\n     \t\t                index = ref.findIndex((value) => value === itemByRefId);\n     \t\t            }\n     \t\t            // fallback to use last index\n     \t\t            if (index === -1 || index === undefined) {\n     \t\t                index = ref.length;\n     \t\t            }\n     \t\t        }\n     \t\t        else {\n     \t\t            index = decode.number(bytes, it);\n     \t\t        }\n     \t\t        const type = ref[$childType];\n     \t\t        let dynamicIndex = index;\n     \t\t        const { value, previousValue } = decodeValue(decoder, operation, ref, index, type, bytes, it, allChanges);\n     \t\t        if (value !== null && value !== undefined &&\n     \t\t            value !== previousValue // avoid setting same value twice (if index === 0 it will result in a \"unshift\" for ArraySchema)\n     \t\t        ) {\n     \t\t            // ArraySchema\n     \t\t            ref['$setAt'](index, value, operation);\n     \t\t        }\n     \t\t        // add change\n     \t\t        if (previousValue !== value) {\n     \t\t            allChanges.push({\n     \t\t                ref,\n     \t\t                refId: decoder.currentRefId,\n     \t\t                op: operation,\n     \t\t                field: \"\", // FIXME: remove this\n     \t\t                dynamicIndex,\n     \t\t                value,\n     \t\t                previousValue,\n     \t\t            });\n     \t\t        }\n     \t\t    };\n\n     \t\t    class EncodeSchemaError extends Error {\n     \t\t    }\n     \t\t    function assertType(value, type, klass, field) {\n     \t\t        let typeofTarget;\n     \t\t        let allowNull = false;\n     \t\t        switch (type) {\n     \t\t            case \"number\":\n     \t\t            case \"int8\":\n     \t\t            case \"uint8\":\n     \t\t            case \"int16\":\n     \t\t            case \"uint16\":\n     \t\t            case \"int32\":\n     \t\t            case \"uint32\":\n     \t\t            case \"int64\":\n     \t\t            case \"uint64\":\n     \t\t            case \"float32\":\n     \t\t            case \"float64\":\n     \t\t                typeofTarget = \"number\";\n     \t\t                if (isNaN(value)) {\n     \t\t                    console.log(`trying to encode \"NaN\" in ${klass.constructor.name}#${field}`);\n     \t\t                }\n     \t\t                break;\n     \t\t            case \"bigint64\":\n     \t\t            case \"biguint64\":\n     \t\t                typeofTarget = \"bigint\";\n     \t\t                break;\n     \t\t            case \"string\":\n     \t\t                typeofTarget = \"string\";\n     \t\t                allowNull = true;\n     \t\t                break;\n     \t\t            case \"boolean\":\n     \t\t                // boolean is always encoded as true/false based on truthiness\n     \t\t                return;\n     \t\t            default:\n     \t\t                // skip assertion for custom types\n     \t\t                // TODO: allow custom types to define their own assertions\n     \t\t                return;\n     \t\t        }\n     \t\t        if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n     \t\t            let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;\n     \t\t            throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);\n     \t\t        }\n     \t\t    }\n     \t\t    function assertInstanceType(value, type, instance, field) {\n     \t\t        if (!(value instanceof type)) {\n     \t\t            throw new EncodeSchemaError(`a '${type.name}' was expected, but '${value && value.constructor.name}' was provided in ${instance.constructor.name}#${field}`);\n     \t\t        }\n     \t\t    }\n\n     \t\t    var _a$4, _b$4;\n     \t\t    const DEFAULT_SORT = (a, b) => {\n     \t\t        const A = a.toString();\n     \t\t        const B = b.toString();\n     \t\t        if (A < B)\n     \t\t            return -1;\n     \t\t        else if (A > B)\n     \t\t            return 1;\n     \t\t        else\n     \t\t            return 0;\n     \t\t    };\n     \t\t    class ArraySchema {\n     \t\t        static { this[_a$4] = encodeArray; }\n     \t\t        static { this[_b$4] = decodeArray; }\n     \t\t        /**\n     \t\t         * Determine if a property must be filtered.\n     \t\t         * - If returns false, the property is NOT going to be encoded.\n     \t\t         * - If returns true, the property is going to be encoded.\n     \t\t         *\n     \t\t         * Encoding with \"filters\" happens in two steps:\n     \t\t         * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     \t\t         * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     \t\t         */\n     \t\t        static [(_a$4 = $encoder, _b$4 = $decoder, $filter)](ref, index, view) {\n     \t\t            return (!view ||\n     \t\t                typeof (ref[$childType]) === \"string\" ||\n     \t\t                view.isChangeTreeVisible(ref['tmpItems'][index]?.[$changes]));\n     \t\t        }\n     \t\t        static is(type) {\n     \t\t            return (\n     \t\t            // type format: [\"string\"]\n     \t\t            Array.isArray(type) ||\n     \t\t                // type format: { array: \"string\" }\n     \t\t                (type['array'] !== undefined));\n     \t\t        }\n     \t\t        static from(iterable) {\n     \t\t            return new ArraySchema(...Array.from(iterable));\n     \t\t        }\n     \t\t        constructor(...items) {\n     \t\t            this.items = [];\n     \t\t            this.tmpItems = [];\n     \t\t            this.deletedIndexes = {};\n     \t\t            this.isMovingItems = false;\n     \t\t            Object.defineProperty(this, $childType, {\n     \t\t                value: undefined,\n     \t\t                enumerable: false,\n     \t\t                writable: true,\n     \t\t                configurable: true,\n     \t\t            });\n     \t\t            const proxy = new Proxy(this, {\n     \t\t                get: (obj, prop) => {\n     \t\t                    if (typeof (prop) !== \"symbol\" &&\n     \t\t                        // FIXME: d8 accuses this as low performance\n     \t\t                        !isNaN(prop) // https://stackoverflow.com/a/175787/892698\n     \t\t                    ) {\n     \t\t                        return this.items[prop];\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        return Reflect.get(obj, prop);\n     \t\t                    }\n     \t\t                },\n     \t\t                set: (obj, key, setValue) => {\n     \t\t                    if (typeof (key) !== \"symbol\" && !isNaN(key)) {\n     \t\t                        if (setValue === undefined || setValue === null) {\n     \t\t                            obj.$deleteAt(key);\n     \t\t                        }\n     \t\t                        else {\n     \t\t                            if (setValue[$changes]) {\n     \t\t                                assertInstanceType(setValue, obj[$childType], obj, key);\n     \t\t                                const previousValue = obj.items[key];\n     \t\t                                if (!obj.isMovingItems) {\n     \t\t                                    obj.$changeAt(Number(key), setValue);\n     \t\t                                }\n     \t\t                                else {\n     \t\t                                    if (previousValue !== undefined) {\n     \t\t                                        if (setValue[$changes].isNew) {\n     \t\t                                            obj[$changes].indexedOperation(Number(key), exports.OPERATION.MOVE_AND_ADD);\n     \t\t                                        }\n     \t\t                                        else {\n     \t\t                                            if ((obj[$changes].getChange(Number(key)) & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {\n     \t\t                                                obj[$changes].indexedOperation(Number(key), exports.OPERATION.DELETE_AND_MOVE);\n     \t\t                                            }\n     \t\t                                            else {\n     \t\t                                                obj[$changes].indexedOperation(Number(key), exports.OPERATION.MOVE);\n     \t\t                                            }\n     \t\t                                        }\n     \t\t                                    }\n     \t\t                                    else if (setValue[$changes].isNew) {\n     \t\t                                        obj[$changes].indexedOperation(Number(key), exports.OPERATION.ADD);\n     \t\t                                    }\n     \t\t                                    setValue[$changes].setParent(this, obj[$changes].root, key);\n     \t\t                                }\n     \t\t                                if (previousValue !== undefined) {\n     \t\t                                    // remove root reference from previous value\n     \t\t                                    previousValue[$changes].root?.remove(previousValue[$changes]);\n     \t\t                                }\n     \t\t                            }\n     \t\t                            else {\n     \t\t                                obj.$changeAt(Number(key), setValue);\n     \t\t                            }\n     \t\t                            obj.items[key] = setValue;\n     \t\t                            obj.tmpItems[key] = setValue;\n     \t\t                        }\n     \t\t                        return true;\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        return Reflect.set(obj, key, setValue);\n     \t\t                    }\n     \t\t                },\n     \t\t                deleteProperty: (obj, prop) => {\n     \t\t                    if (typeof (prop) === \"number\") {\n     \t\t                        obj.$deleteAt(prop);\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        delete obj[prop];\n     \t\t                    }\n     \t\t                    return true;\n     \t\t                },\n     \t\t                has: (obj, key) => {\n     \t\t                    if (typeof (key) !== \"symbol\" && !isNaN(Number(key))) {\n     \t\t                        return Reflect.has(this.items, key);\n     \t\t                    }\n     \t\t                    return Reflect.has(obj, key);\n     \t\t                }\n     \t\t            });\n     \t\t            this[$changes] = new ChangeTree(proxy);\n     \t\t            this[$changes].indexes = {};\n     \t\t            if (items.length > 0) {\n     \t\t                this.push(...items);\n     \t\t            }\n     \t\t            return proxy;\n     \t\t        }\n     \t\t        set length(newLength) {\n     \t\t            if (newLength === 0) {\n     \t\t                this.clear();\n     \t\t            }\n     \t\t            else if (newLength < this.items.length) {\n     \t\t                this.splice(newLength, this.length - newLength);\n     \t\t            }\n     \t\t            else {\n     \t\t                console.warn(\"ArraySchema: can't set .length to a higher value than its length.\");\n     \t\t            }\n     \t\t        }\n     \t\t        get length() {\n     \t\t            return this.items.length;\n     \t\t        }\n     \t\t        push(...values) {\n     \t\t            let length = this.tmpItems.length;\n     \t\t            const changeTree = this[$changes];\n     \t\t            // values.forEach((value, i) => {\n     \t\t            for (let i = 0, l = values.length; i < values.length; i++, length++) {\n     \t\t                const value = values[i];\n     \t\t                if (value === undefined || value === null) {\n     \t\t                    // skip null values\n     \t\t                    return;\n     \t\t                }\n     \t\t                else if (typeof (value) === \"object\" && this[$childType]) {\n     \t\t                    assertInstanceType(value, this[$childType], this, i);\n     \t\t                    // TODO: move value[$changes]?.setParent() to this block.\n     \t\t                }\n     \t\t                changeTree.indexedOperation(length, exports.OPERATION.ADD, this.items.length);\n     \t\t                this.items.push(value);\n     \t\t                this.tmpItems.push(value);\n     \t\t                //\n     \t\t                // set value's parent after the value is set\n     \t\t                // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\n     \t\t                //\n     \t\t                value[$changes]?.setParent(this, changeTree.root, length);\n     \t\t            }\n     \t\t            //     length++;\n     \t\t            // });\n     \t\t            return length;\n     \t\t        }\n     \t\t        /**\n     \t\t         * Removes the last element from an array and returns it.\n     \t\t         */\n     \t\t        pop() {\n     \t\t            let index = -1;\n     \t\t            // find last non-undefined index\n     \t\t            for (let i = this.tmpItems.length - 1; i >= 0; i--) {\n     \t\t                // if (this.tmpItems[i] !== undefined) {\n     \t\t                if (this.deletedIndexes[i] !== true) {\n     \t\t                    index = i;\n     \t\t                    break;\n     \t\t                }\n     \t\t            }\n     \t\t            if (index < 0) {\n     \t\t                return undefined;\n     \t\t            }\n     \t\t            this[$changes].delete(index, undefined, this.items.length - 1);\n     \t\t            this.deletedIndexes[index] = true;\n     \t\t            return this.items.pop();\n     \t\t        }\n     \t\t        at(index) {\n     \t\t            // Allow negative indexing from the end\n     \t\t            if (index < 0)\n     \t\t                index += this.length;\n     \t\t            return this.items[index];\n     \t\t        }\n     \t\t        // encoding only\n     \t\t        $changeAt(index, value) {\n     \t\t            if (value === undefined || value === null) {\n     \t\t                console.error(\"ArraySchema items cannot be null nor undefined; Use `deleteAt(index)` instead.\");\n     \t\t                return;\n     \t\t            }\n     \t\t            // skip if the value is the same as cached.\n     \t\t            if (this.items[index] === value) {\n     \t\t                return;\n     \t\t            }\n     \t\t            const operation = (this.items[index] !== undefined)\n     \t\t                ? typeof (value) === \"object\"\n     \t\t                    ? exports.OPERATION.DELETE_AND_ADD // schema child\n     \t\t                    : exports.OPERATION.REPLACE // primitive\n     \t\t                : exports.OPERATION.ADD;\n     \t\t            const changeTree = this[$changes];\n     \t\t            changeTree.change(index, operation);\n     \t\t            //\n     \t\t            // set value's parent after the value is set\n     \t\t            // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\n     \t\t            //\n     \t\t            value[$changes]?.setParent(this, changeTree.root, index);\n     \t\t        }\n     \t\t        // encoding only\n     \t\t        $deleteAt(index, operation) {\n     \t\t            this[$changes].delete(index, operation);\n     \t\t        }\n     \t\t        // decoding only\n     \t\t        $setAt(index, value, operation) {\n     \t\t            if (index === 0 &&\n     \t\t                operation === exports.OPERATION.ADD &&\n     \t\t                this.items[index] !== undefined) {\n     \t\t                // handle decoding unshift\n     \t\t                this.items.unshift(value);\n     \t\t            }\n     \t\t            else if (operation === exports.OPERATION.DELETE_AND_MOVE) {\n     \t\t                this.items.splice(index, 1);\n     \t\t                this.items[index] = value;\n     \t\t            }\n     \t\t            else {\n     \t\t                this.items[index] = value;\n     \t\t            }\n     \t\t        }\n     \t\t        clear() {\n     \t\t            // skip if already clear\n     \t\t            if (this.items.length === 0) {\n     \t\t                return;\n     \t\t            }\n     \t\t            // discard previous operations.\n     \t\t            const changeTree = this[$changes];\n     \t\t            // discard children\n     \t\t            changeTree.forEachChild((changeTree, _) => {\n     \t\t                changeTree.discard(true);\n     \t\t                //\n     \t\t                // TODO: add tests with instance sharing + .clear()\n     \t\t                // FIXME: this.root? is required because it is being called at decoding time.\n     \t\t                //\n     \t\t                // TODO: do not use [$changes] at decoding time.\n     \t\t                //\n     \t\t                const root = changeTree.root;\n     \t\t                if (root !== undefined) {\n     \t\t                    root.removeChangeFromChangeSet(\"changes\", changeTree);\n     \t\t                    root.removeChangeFromChangeSet(\"allChanges\", changeTree);\n     \t\t                    root.removeChangeFromChangeSet(\"allFilteredChanges\", changeTree);\n     \t\t                }\n     \t\t            });\n     \t\t            changeTree.discard(true);\n     \t\t            changeTree.operation(exports.OPERATION.CLEAR);\n     \t\t            this.items.length = 0;\n     \t\t            this.tmpItems.length = 0;\n     \t\t        }\n     \t\t        /**\n     \t\t         * Combines two or more arrays.\n     \t\t         * @param items Additional items to add to the end of array1.\n     \t\t         */\n     \t\t        // @ts-ignore\n     \t\t        concat(...items) {\n     \t\t            return new ArraySchema(...this.items.concat(...items));\n     \t\t        }\n     \t\t        /**\n     \t\t         * Adds all the elements of an array separated by the specified separator string.\n     \t\t         * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n     \t\t         */\n     \t\t        join(separator) {\n     \t\t            return this.items.join(separator);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Reverses the elements in an Array.\n     \t\t         */\n     \t\t        // @ts-ignore\n     \t\t        reverse() {\n     \t\t            this[$changes].operation(exports.OPERATION.REVERSE);\n     \t\t            this.items.reverse();\n     \t\t            this.tmpItems.reverse();\n     \t\t            return this;\n     \t\t        }\n     \t\t        /**\n     \t\t         * Removes the first element from an array and returns it.\n     \t\t         */\n     \t\t        shift() {\n     \t\t            if (this.items.length === 0) {\n     \t\t                return undefined;\n     \t\t            }\n     \t\t            // const index = Number(Object.keys(changeTree.indexes)[0]);\n     \t\t            const changeTree = this[$changes];\n     \t\t            const index = this.tmpItems.findIndex(item => item === this.items[0]);\n     \t\t            const allChangesIndex = this.items.findIndex(item => item === this.items[0]);\n     \t\t            changeTree.delete(index, exports.OPERATION.DELETE, allChangesIndex);\n     \t\t            changeTree.shiftAllChangeIndexes(-1, allChangesIndex);\n     \t\t            // this.deletedIndexes[index] = true;\n     \t\t            return this.items.shift();\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns a section of an array.\n     \t\t         * @param start The beginning of the specified portion of the array.\n     \t\t         * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\n     \t\t         */\n     \t\t        slice(start, end) {\n     \t\t            const sliced = new ArraySchema();\n     \t\t            sliced.push(...this.items.slice(start, end));\n     \t\t            return sliced;\n     \t\t        }\n     \t\t        /**\n     \t\t         * Sorts an array.\n     \t\t         * @param compareFn Function used to determine the order of the elements. It is expected to return\n     \t\t         * a negative value if first argument is less than second argument, zero if they're equal and a positive\n     \t\t         * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.\n     \t\t         * ```ts\n     \t\t         * [11,2,22,1].sort((a, b) => a - b)\n     \t\t         * ```\n     \t\t         */\n     \t\t        sort(compareFn = DEFAULT_SORT) {\n     \t\t            this.isMovingItems = true;\n     \t\t            const changeTree = this[$changes];\n     \t\t            const sortedItems = this.items.sort(compareFn);\n     \t\t            // wouldn't OPERATION.MOVE make more sense here?\n     \t\t            sortedItems.forEach((_, i) => changeTree.change(i, exports.OPERATION.REPLACE));\n     \t\t            this.tmpItems.sort(compareFn);\n     \t\t            this.isMovingItems = false;\n     \t\t            return this;\n     \t\t        }\n     \t\t        /**\n     \t\t         * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n     \t\t         * @param start The zero-based location in the array from which to start removing elements.\n     \t\t         * @param deleteCount The number of elements to remove.\n     \t\t         * @param insertItems Elements to insert into the array in place of the deleted elements.\n     \t\t         */\n     \t\t        splice(start, deleteCount, ...insertItems) {\n     \t\t            const changeTree = this[$changes];\n     \t\t            const itemsLength = this.items.length;\n     \t\t            const tmpItemsLength = this.tmpItems.length;\n     \t\t            const insertCount = insertItems.length;\n     \t\t            // build up-to-date list of indexes, excluding removed values.\n     \t\t            const indexes = [];\n     \t\t            for (let i = 0; i < tmpItemsLength; i++) {\n     \t\t                if (this.deletedIndexes[i] !== true) {\n     \t\t                    indexes.push(i);\n     \t\t                }\n     \t\t            }\n     \t\t            if (itemsLength > start) {\n     \t\t                // if deleteCount is not provided, delete all items from start to end\n     \t\t                if (deleteCount === undefined) {\n     \t\t                    deleteCount = itemsLength - start;\n     \t\t                }\n     \t\t                //\n     \t\t                // delete operations at correct index\n     \t\t                //\n     \t\t                for (let i = start; i < start + deleteCount; i++) {\n     \t\t                    const index = indexes[i];\n     \t\t                    changeTree.delete(index, exports.OPERATION.DELETE);\n     \t\t                    this.deletedIndexes[index] = true;\n     \t\t                }\n     \t\t            }\n     \t\t            else {\n     \t\t                // not enough items to delete\n     \t\t                deleteCount = 0;\n     \t\t            }\n     \t\t            // insert operations\n     \t\t            if (insertCount > 0) {\n     \t\t                if (insertCount > deleteCount) {\n     \t\t                    console.error(\"Inserting more elements than deleting during ArraySchema#splice()\");\n     \t\t                    throw new Error(\"ArraySchema#splice(): insertCount must be equal or lower than deleteCount.\");\n     \t\t                }\n     \t\t                for (let i = 0; i < insertCount; i++) {\n     \t\t                    const addIndex = (indexes[start] ?? itemsLength) + i;\n     \t\t                    changeTree.indexedOperation(addIndex, (this.deletedIndexes[addIndex])\n     \t\t                        ? exports.OPERATION.DELETE_AND_ADD\n     \t\t                        : exports.OPERATION.ADD);\n     \t\t                    // set value's parent/root\n     \t\t                    insertItems[i][$changes]?.setParent(this, changeTree.root, addIndex);\n     \t\t                }\n     \t\t            }\n     \t\t            //\n     \t\t            // delete exceeding indexes from \"allChanges\"\n     \t\t            // (prevent .encodeAll() from encoding non-existing items)\n     \t\t            //\n     \t\t            if (deleteCount > insertCount) {\n     \t\t                changeTree.shiftAllChangeIndexes(-(deleteCount - insertCount), indexes[start + insertCount]);\n     \t\t                // debugChangeSet(\"AFTER SHIFT indexes\", changeTree.allChanges);\n     \t\t            }\n     \t\t            //\n     \t\t            // FIXME: this code block is duplicated on ChangeTree\n     \t\t            //\n     \t\t            if (changeTree.filteredChanges !== undefined) {\n     \t\t                enqueueChangeTree(changeTree.root, changeTree, 'filteredChanges');\n     \t\t            }\n     \t\t            else {\n     \t\t                enqueueChangeTree(changeTree.root, changeTree, 'changes');\n     \t\t            }\n     \t\t            return this.items.splice(start, deleteCount, ...insertItems);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Inserts new elements at the start of an array.\n     \t\t         * @param items  Elements to insert at the start of the Array.\n     \t\t         */\n     \t\t        unshift(...items) {\n     \t\t            const changeTree = this[$changes];\n     \t\t            // shift indexes\n     \t\t            changeTree.shiftChangeIndexes(items.length);\n     \t\t            // new index\n     \t\t            if (changeTree.isFiltered) {\n     \t\t                setOperationAtIndex(changeTree.filteredChanges, this.items.length);\n     \t\t                // changeTree.filteredChanges[this.items.length] = OPERATION.ADD;\n     \t\t            }\n     \t\t            else {\n     \t\t                setOperationAtIndex(changeTree.allChanges, this.items.length);\n     \t\t                // changeTree.allChanges[this.items.length] = OPERATION.ADD;\n     \t\t            }\n     \t\t            // FIXME: should we use OPERATION.MOVE here instead?\n     \t\t            items.forEach((_, index) => {\n     \t\t                changeTree.change(index, exports.OPERATION.ADD);\n     \t\t            });\n     \t\t            this.tmpItems.unshift(...items);\n     \t\t            return this.items.unshift(...items);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns the index of the first occurrence of a value in an array.\n     \t\t         * @param searchElement The value to locate in the array.\n     \t\t         * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n     \t\t         */\n     \t\t        indexOf(searchElement, fromIndex) {\n     \t\t            return this.items.indexOf(searchElement, fromIndex);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns the index of the last occurrence of a specified value in an array.\n     \t\t         * @param searchElement The value to locate in the array.\n     \t\t         * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n     \t\t         */\n     \t\t        lastIndexOf(searchElement, fromIndex = this.length - 1) {\n     \t\t            return this.items.lastIndexOf(searchElement, fromIndex);\n     \t\t        }\n     \t\t        every(callbackfn, thisArg) {\n     \t\t            return this.items.every(callbackfn, thisArg);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Determines whether the specified callback function returns true for any element of an array.\n     \t\t         * @param callbackfn A function that accepts up to three arguments. The some method calls\n     \t\t         * the callbackfn function for each element in the array until the callbackfn returns a value\n     \t\t         * which is coercible to the Boolean value true, or until the end of the array.\n     \t\t         * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     \t\t         * If thisArg is omitted, undefined is used as the this value.\n     \t\t         */\n     \t\t        some(callbackfn, thisArg) {\n     \t\t            return this.items.some(callbackfn, thisArg);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Performs the specified action for each element in an array.\n     \t\t         * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n     \t\t         * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     \t\t         */\n     \t\t        forEach(callbackfn, thisArg) {\n     \t\t            return this.items.forEach(callbackfn, thisArg);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n     \t\t         * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n     \t\t         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     \t\t         */\n     \t\t        map(callbackfn, thisArg) {\n     \t\t            return this.items.map(callbackfn, thisArg);\n     \t\t        }\n     \t\t        filter(callbackfn, thisArg) {\n     \t\t            return this.items.filter(callbackfn, thisArg);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     \t\t         * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n     \t\t         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     \t\t         */\n     \t\t        reduce(callbackfn, initialValue) {\n     \t\t            return this.items.reduce(callbackfn, initialValue);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     \t\t         * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n     \t\t         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     \t\t         */\n     \t\t        reduceRight(callbackfn, initialValue) {\n     \t\t            return this.items.reduceRight(callbackfn, initialValue);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns the value of the first element in the array where predicate is true, and undefined\n     \t\t         * otherwise.\n     \t\t         * @param predicate find calls predicate once for each element of the array, in ascending\n     \t\t         * order, until it finds one where predicate returns true. If such an element is found, find\n     \t\t         * immediately returns that element value. Otherwise, find returns undefined.\n     \t\t         * @param thisArg If provided, it will be used as the this value for each invocation of\n     \t\t         * predicate. If it is not provided, undefined is used instead.\n     \t\t         */\n     \t\t        find(predicate, thisArg) {\n     \t\t            return this.items.find(predicate, thisArg);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns the index of the first element in the array where predicate is true, and -1\n     \t\t         * otherwise.\n     \t\t         * @param predicate find calls predicate once for each element of the array, in ascending\n     \t\t         * order, until it finds one where predicate returns true. If such an element is found,\n     \t\t         * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     \t\t         * @param thisArg If provided, it will be used as the this value for each invocation of\n     \t\t         * predicate. If it is not provided, undefined is used instead.\n     \t\t         */\n     \t\t        findIndex(predicate, thisArg) {\n     \t\t            return this.items.findIndex(predicate, thisArg);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns the this object after filling the section identified by start and end with value\n     \t\t         * @param value value to fill array section with\n     \t\t         * @param start index to start filling the array at. If start is negative, it is treated as\n     \t\t         * length+start where length is the length of the array.\n     \t\t         * @param end index to stop filling the array at. If end is negative, it is treated as\n     \t\t         * length+end.\n     \t\t         */\n     \t\t        fill(value, start, end) {\n     \t\t            //\n     \t\t            // TODO\n     \t\t            //\n     \t\t            throw new Error(\"ArraySchema#fill() not implemented\");\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns the this object after copying a section of the array identified by start and end\n     \t\t         * to the same array starting at position target\n     \t\t         * @param target If target is negative, it is treated as length+target where length is the\n     \t\t         * length of the array.\n     \t\t         * @param start If start is negative, it is treated as length+start. If end is negative, it\n     \t\t         * is treated as length+end.\n     \t\t         * @param end If not specified, length of the this object is used as its default value.\n     \t\t         */\n     \t\t        copyWithin(target, start, end) {\n     \t\t            //\n     \t\t            // TODO\n     \t\t            //\n     \t\t            throw new Error(\"ArraySchema#copyWithin() not implemented\");\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns a string representation of an array.\n     \t\t         */\n     \t\t        toString() {\n     \t\t            return this.items.toString();\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n     \t\t         */\n     \t\t        toLocaleString() {\n     \t\t            return this.items.toLocaleString();\n     \t\t        }\n     \t\t        ;\n     \t\t        /** Iterator */\n     \t\t        [Symbol.iterator]() {\n     \t\t            return this.items[Symbol.iterator]();\n     \t\t        }\n     \t\t        static get [Symbol.species]() {\n     \t\t            return ArraySchema;\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns an iterable of key, value pairs for every entry in the array\n     \t\t         */\n     \t\t        entries() { return this.items.entries(); }\n     \t\t        /**\n     \t\t         * Returns an iterable of keys in the array\n     \t\t         */\n     \t\t        keys() { return this.items.keys(); }\n     \t\t        /**\n     \t\t         * Returns an iterable of values in the array\n     \t\t         */\n     \t\t        values() { return this.items.values(); }\n     \t\t        /**\n     \t\t         * Determines whether an array includes a certain element, returning true or false as appropriate.\n     \t\t         * @param searchElement The element to search for.\n     \t\t         * @param fromIndex The position in this array at which to begin searching for searchElement.\n     \t\t         */\n     \t\t        includes(searchElement, fromIndex) {\n     \t\t            return this.items.includes(searchElement, fromIndex);\n     \t\t        }\n     \t\t        //\n     \t\t        // ES2022\n     \t\t        //\n     \t\t        /**\n     \t\t         * Calls a defined callback function on each element of an array. Then, flattens the result into\n     \t\t         * a new array.\n     \t\t         * This is identical to a map followed by flat with depth 1.\n     \t\t         *\n     \t\t         * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     \t\t         * callback function one time for each element in the array.\n     \t\t         * @param thisArg An object to which the this keyword can refer in the callback function. If\n     \t\t         * thisArg is omitted, undefined is used as the this value.\n     \t\t         */\n     \t\t        // @ts-ignore\n     \t\t        flatMap(callback, thisArg) {\n     \t\t            // @ts-ignore\n     \t\t            throw new Error(\"ArraySchema#flatMap() is not supported.\");\n     \t\t        }\n     \t\t        /**\n     \t\t         * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     \t\t         * specified depth.\n     \t\t         *\n     \t\t         * @param depth The maximum recursion depth\n     \t\t         */\n     \t\t        // @ts-ignore\n     \t\t        flat(depth) {\n     \t\t            throw new Error(\"ArraySchema#flat() is not supported.\");\n     \t\t        }\n     \t\t        findLast() {\n     \t\t            // @ts-ignore\n     \t\t            return this.items.findLast.apply(this.items, arguments);\n     \t\t        }\n     \t\t        findLastIndex(...args) {\n     \t\t            // @ts-ignore\n     \t\t            return this.items.findLastIndex.apply(this.items, arguments);\n     \t\t        }\n     \t\t        //\n     \t\t        // ES2023\n     \t\t        //\n     \t\t        with(index, value) {\n     \t\t            const copy = this.items.slice();\n     \t\t            // Allow negative indexing from the end\n     \t\t            if (index < 0)\n     \t\t                index += this.length;\n     \t\t            copy[index] = value;\n     \t\t            return new ArraySchema(...copy);\n     \t\t        }\n     \t\t        toReversed() {\n     \t\t            return this.items.slice().reverse();\n     \t\t        }\n     \t\t        toSorted(compareFn) {\n     \t\t            return this.items.slice().sort(compareFn);\n     \t\t        }\n     \t\t        // @ts-ignore\n     \t\t        toSpliced(start, deleteCount, ...items) {\n     \t\t            // @ts-ignore\n     \t\t            return this.items.toSpliced.apply(copy, arguments);\n     \t\t        }\n     \t\t        shuffle() {\n     \t\t            return this.move((_) => {\n     \t\t                let currentIndex = this.items.length;\n     \t\t                while (currentIndex != 0) {\n     \t\t                    let randomIndex = Math.floor(Math.random() * currentIndex);\n     \t\t                    currentIndex--;\n     \t\t                    [this[currentIndex], this[randomIndex]] = [this[randomIndex], this[currentIndex]];\n     \t\t                }\n     \t\t            });\n     \t\t        }\n     \t\t        /**\n     \t\t         * Allows to move items around in the array.\n     \t\t         *\n     \t\t         * Example:\n     \t\t         *     state.cards.move((cards) => {\n     \t\t         *         [cards[4], cards[3]] = [cards[3], cards[4]];\n     \t\t         *         [cards[3], cards[2]] = [cards[2], cards[3]];\n     \t\t         *         [cards[2], cards[0]] = [cards[0], cards[2]];\n     \t\t         *         [cards[1], cards[1]] = [cards[1], cards[1]];\n     \t\t         *         [cards[0], cards[0]] = [cards[0], cards[0]];\n     \t\t         *     })\n     \t\t         *\n     \t\t         * @param cb\n     \t\t         * @returns\n     \t\t         */\n     \t\t        move(cb) {\n     \t\t            this.isMovingItems = true;\n     \t\t            cb(this);\n     \t\t            this.isMovingItems = false;\n     \t\t            return this;\n     \t\t        }\n     \t\t        [($getByIndex)](index, isEncodeAll = false) {\n     \t\t            //\n     \t\t            // TODO: avoid unecessary `this.tmpItems` check during decoding.\n     \t\t            //\n     \t\t            //    ENCODING uses `this.tmpItems` (or `this.items` if `isEncodeAll` is true)\n     \t\t            //    DECODING uses `this.items`\n     \t\t            //\n     \t\t            return (isEncodeAll)\n     \t\t                ? this.items[index]\n     \t\t                : this.deletedIndexes[index]\n     \t\t                    ? this.items[index]\n     \t\t                    : this.tmpItems[index] || this.items[index];\n     \t\t        }\n     \t\t        [$deleteByIndex](index) {\n     \t\t            this.items[index] = undefined;\n     \t\t            this.tmpItems[index] = undefined; // TODO: do not try to get \"tmpItems\" at decoding time.\n     \t\t        }\n     \t\t        [$onEncodeEnd]() {\n     \t\t            this.tmpItems = this.items.slice();\n     \t\t            this.deletedIndexes = {};\n     \t\t        }\n     \t\t        [$onDecodeEnd]() {\n     \t\t            this.items = this.items.filter((item) => item !== undefined);\n     \t\t            this.tmpItems = this.items.slice(); // TODO: do no use \"tmpItems\" at decoding time.\n     \t\t        }\n     \t\t        toArray() {\n     \t\t            return this.items.slice(0);\n     \t\t        }\n     \t\t        toJSON() {\n     \t\t            return this.toArray().map((value) => {\n     \t\t                return (typeof (value['toJSON']) === \"function\")\n     \t\t                    ? value['toJSON']()\n     \t\t                    : value;\n     \t\t            });\n     \t\t        }\n     \t\t        //\n     \t\t        // Decoding utilities\n     \t\t        //\n     \t\t        clone(isDecoding) {\n     \t\t            let cloned;\n     \t\t            if (isDecoding) {\n     \t\t                cloned = new ArraySchema();\n     \t\t                cloned.push(...this.items);\n     \t\t            }\n     \t\t            else {\n     \t\t                cloned = new ArraySchema(...this.map(item => ((item[$changes])\n     \t\t                    ? item.clone()\n     \t\t                    : item)));\n     \t\t            }\n     \t\t            return cloned;\n     \t\t        }\n     \t\t        ;\n     \t\t    }\n     \t\t    registerType(\"array\", { constructor: ArraySchema });\n\n     \t\t    var _a$3, _b$3;\n     \t\t    class MapSchema {\n     \t\t        static { this[_a$3] = encodeKeyValueOperation; }\n     \t\t        static { this[_b$3] = decodeKeyValueOperation; }\n     \t\t        /**\n     \t\t         * Determine if a property must be filtered.\n     \t\t         * - If returns false, the property is NOT going to be encoded.\n     \t\t         * - If returns true, the property is going to be encoded.\n     \t\t         *\n     \t\t         * Encoding with \"filters\" happens in two steps:\n     \t\t         * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     \t\t         * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     \t\t         */\n     \t\t        static [(_a$3 = $encoder, _b$3 = $decoder, $filter)](ref, index, view) {\n     \t\t            return (!view ||\n     \t\t                typeof (ref[$childType]) === \"string\" ||\n     \t\t                view.isChangeTreeVisible((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));\n     \t\t        }\n     \t\t        static is(type) {\n     \t\t            return type['map'] !== undefined;\n     \t\t        }\n     \t\t        constructor(initialValues) {\n     \t\t            this.$items = new Map();\n     \t\t            this.$indexes = new Map();\n     \t\t            this.deletedItems = {};\n     \t\t            this[$changes] = new ChangeTree(this);\n     \t\t            this[$changes].indexes = {};\n     \t\t            if (initialValues) {\n     \t\t                if (initialValues instanceof Map ||\n     \t\t                    initialValues instanceof MapSchema) {\n     \t\t                    initialValues.forEach((v, k) => this.set(k, v));\n     \t\t                }\n     \t\t                else {\n     \t\t                    for (const k in initialValues) {\n     \t\t                        this.set(k, initialValues[k]);\n     \t\t                    }\n     \t\t                }\n     \t\t            }\n     \t\t            Object.defineProperty(this, $childType, {\n     \t\t                value: undefined,\n     \t\t                enumerable: false,\n     \t\t                writable: true,\n     \t\t                configurable: true,\n     \t\t            });\n     \t\t        }\n     \t\t        /** Iterator */\n     \t\t        [Symbol.iterator]() { return this.$items[Symbol.iterator](); }\n     \t\t        get [Symbol.toStringTag]() { return this.$items[Symbol.toStringTag]; }\n     \t\t        static get [Symbol.species]() { return MapSchema; }\n     \t\t        set(key, value) {\n     \t\t            if (value === undefined || value === null) {\n     \t\t                throw new Error(`MapSchema#set('${key}', ${value}): trying to set ${value} value on '${key}'.`);\n     \t\t            }\n     \t\t            else if (typeof (value) === \"object\" && this[$childType]) {\n     \t\t                assertInstanceType(value, this[$childType], this, key);\n     \t\t            }\n     \t\t            // Force \"key\" as string\n     \t\t            // See: https://github.com/colyseus/colyseus/issues/561#issuecomment-1646733468\n     \t\t            key = key.toString();\n     \t\t            const changeTree = this[$changes];\n     \t\t            const isRef = (value[$changes]) !== undefined;\n     \t\t            let index;\n     \t\t            let operation;\n     \t\t            // IS REPLACE?\n     \t\t            if (typeof (changeTree.indexes[key]) !== \"undefined\") {\n     \t\t                index = changeTree.indexes[key];\n     \t\t                operation = exports.OPERATION.REPLACE;\n     \t\t                const previousValue = this.$items.get(key);\n     \t\t                if (previousValue === value) {\n     \t\t                    // if value is the same, avoid re-encoding it.\n     \t\t                    return;\n     \t\t                }\n     \t\t                else if (isRef) {\n     \t\t                    // if is schema, force ADD operation if value differ from previous one.\n     \t\t                    operation = exports.OPERATION.DELETE_AND_ADD;\n     \t\t                    // remove reference from previous value\n     \t\t                    if (previousValue !== undefined) {\n     \t\t                        previousValue[$changes].root?.remove(previousValue[$changes]);\n     \t\t                    }\n     \t\t                }\n     \t\t            }\n     \t\t            else {\n     \t\t                index = changeTree.indexes[$numFields] ?? 0;\n     \t\t                operation = exports.OPERATION.ADD;\n     \t\t                this.$indexes.set(index, key);\n     \t\t                changeTree.indexes[key] = index;\n     \t\t                changeTree.indexes[$numFields] = index + 1;\n     \t\t            }\n     \t\t            this.$items.set(key, value);\n     \t\t            changeTree.change(index, operation);\n     \t\t            //\n     \t\t            // set value's parent after the value is set\n     \t\t            // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\n     \t\t            //\n     \t\t            if (isRef) {\n     \t\t                value[$changes].setParent(this, changeTree.root, index);\n     \t\t            }\n     \t\t            return this;\n     \t\t        }\n     \t\t        get(key) {\n     \t\t            return this.$items.get(key);\n     \t\t        }\n     \t\t        delete(key) {\n     \t\t            const index = this[$changes].indexes[key];\n     \t\t            this.deletedItems[index] = this[$changes].delete(index);\n     \t\t            return this.$items.delete(key);\n     \t\t        }\n     \t\t        clear() {\n     \t\t            const changeTree = this[$changes];\n     \t\t            // discard previous operations.\n     \t\t            changeTree.discard(true);\n     \t\t            changeTree.indexes = {};\n     \t\t            // clear previous indexes\n     \t\t            this.$indexes.clear();\n     \t\t            // clear items\n     \t\t            this.$items.clear();\n     \t\t            changeTree.operation(exports.OPERATION.CLEAR);\n     \t\t        }\n     \t\t        has(key) {\n     \t\t            return this.$items.has(key);\n     \t\t        }\n     \t\t        forEach(callbackfn) {\n     \t\t            this.$items.forEach(callbackfn);\n     \t\t        }\n     \t\t        entries() {\n     \t\t            return this.$items.entries();\n     \t\t        }\n     \t\t        keys() {\n     \t\t            return this.$items.keys();\n     \t\t        }\n     \t\t        values() {\n     \t\t            return this.$items.values();\n     \t\t        }\n     \t\t        get size() {\n     \t\t            return this.$items.size;\n     \t\t        }\n     \t\t        setIndex(index, key) {\n     \t\t            this.$indexes.set(index, key);\n     \t\t        }\n     \t\t        getIndex(index) {\n     \t\t            return this.$indexes.get(index);\n     \t\t        }\n     \t\t        [$getByIndex](index) {\n     \t\t            return this.$items.get(this.$indexes.get(index));\n     \t\t        }\n     \t\t        [$deleteByIndex](index) {\n     \t\t            const key = this.$indexes.get(index);\n     \t\t            this.$items.delete(key);\n     \t\t            this.$indexes.delete(index);\n     \t\t        }\n     \t\t        [$onEncodeEnd]() {\n     \t\t            this.deletedItems = {};\n     \t\t        }\n     \t\t        toJSON() {\n     \t\t            const map = {};\n     \t\t            this.forEach((value, key) => {\n     \t\t                map[key] = (typeof (value['toJSON']) === \"function\")\n     \t\t                    ? value['toJSON']()\n     \t\t                    : value;\n     \t\t            });\n     \t\t            return map;\n     \t\t        }\n     \t\t        //\n     \t\t        // Decoding utilities\n     \t\t        //\n     \t\t        // @ts-ignore\n     \t\t        clone(isDecoding) {\n     \t\t            let cloned;\n     \t\t            if (isDecoding) {\n     \t\t                // client-side\n     \t\t                cloned = Object.assign(new MapSchema(), this);\n     \t\t            }\n     \t\t            else {\n     \t\t                // server-side\n     \t\t                cloned = new MapSchema();\n     \t\t                this.forEach((value, key) => {\n     \t\t                    if (value[$changes]) {\n     \t\t                        cloned.set(key, value['clone']());\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        cloned.set(key, value);\n     \t\t                    }\n     \t\t                });\n     \t\t            }\n     \t\t            return cloned;\n     \t\t        }\n     \t\t    }\n     \t\t    registerType(\"map\", { constructor: MapSchema });\n\n     \t\t    const DEFAULT_VIEW_TAG = -1;\n     \t\t    function entity(constructor) {\n     \t\t        TypeContext.register(constructor);\n     \t\t        return constructor;\n     \t\t    }\n     \t\t    /**\n     \t\t     * [See documentation](https://docs.colyseus.io/state/schema/)\n     \t\t     *\n     \t\t     * Annotate a Schema property to be serializeable.\n     \t\t     * \\@type()'d fields are automatically flagged as \"dirty\" for the next patch.\n     \t\t     *\n     \t\t     * @example Standard usage, with automatic change tracking.\n     \t\t     * ```\n     \t\t     * \\@type(\"string\") propertyName: string;\n     \t\t     * ```\n     \t\t     *\n     \t\t     * @example You can provide the \"manual\" option if you'd like to manually control your patches via .setDirty().\n     \t\t     * ```\n     \t\t     * \\@type(\"string\", { manual: true })\n     \t\t     * ```\n     \t\t     */\n     \t\t    // export function type(type: DefinitionType, options?: TypeOptions) {\n     \t\t    //     return function ({ get, set }, context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<Schema, any> {\n     \t\t    //         if (context.kind !== \"accessor\") {\n     \t\t    //             throw new Error(\"@type() is only supported for class accessor properties\");\n     \t\t    //         }\n     \t\t    //         const field = context.name.toString();\n     \t\t    //         //\n     \t\t    //         // detect index for this field, considering inheritance\n     \t\t    //         //\n     \t\t    //         const parent = Object.getPrototypeOf(context.metadata);\n     \t\t    //         let fieldIndex: number = context.metadata[$numFields] // current structure already has fields defined\n     \t\t    //             ?? (parent && parent[$numFields]) // parent structure has fields defined\n     \t\t    //             ?? -1; // no fields defined\n     \t\t    //         fieldIndex++;\n     \t\t    //         if (\n     \t\t    //             !parent && // the parent already initializes the `$changes` property\n     \t\t    //             !Metadata.hasFields(context.metadata)\n     \t\t    //         ) {\n     \t\t    //             context.addInitializer(function (this: Ref) {\n     \t\t    //                 Object.defineProperty(this, $changes, {\n     \t\t    //                     value: new ChangeTree(this),\n     \t\t    //                     enumerable: false,\n     \t\t    //                     writable: true\n     \t\t    //                 });\n     \t\t    //             });\n     \t\t    //         }\n     \t\t    //         Metadata.addField(context.metadata, fieldIndex, field, type);\n     \t\t    //         const isArray = ArraySchema.is(type);\n     \t\t    //         const isMap = !isArray && MapSchema.is(type);\n     \t\t    //         // if (options && options.manual) {\n     \t\t    //         //     // do not declare getter/setter descriptor\n     \t\t    //         //     definition.descriptors[field] = {\n     \t\t    //         //         enumerable: true,\n     \t\t    //         //         configurable: true,\n     \t\t    //         //         writable: true,\n     \t\t    //         //     };\n     \t\t    //         //     return;\n     \t\t    //         // }\n     \t\t    //         return {\n     \t\t    //             init(value) {\n     \t\t    //                 // TODO: may need to convert ArraySchema/MapSchema here\n     \t\t    //                 // do not flag change if value is undefined.\n     \t\t    //                 if (value !== undefined) {\n     \t\t    //                     this[$changes].change(fieldIndex);\n     \t\t    //                     // automaticallty transform Array into ArraySchema\n     \t\t    //                     if (isArray) {\n     \t\t    //                         if (!(value instanceof ArraySchema)) {\n     \t\t    //                             value = new ArraySchema(...value);\n     \t\t    //                         }\n     \t\t    //                         value[$childType] = Object.values(type)[0];\n     \t\t    //                     }\n     \t\t    //                     // automaticallty transform Map into MapSchema\n     \t\t    //                     if (isMap) {\n     \t\t    //                         if (!(value instanceof MapSchema)) {\n     \t\t    //                             value = new MapSchema(value);\n     \t\t    //                         }\n     \t\t    //                         value[$childType] = Object.values(type)[0];\n     \t\t    //                     }\n     \t\t    //                     // try to turn provided structure into a Proxy\n     \t\t    //                     if (value['$proxy'] === undefined) {\n     \t\t    //                         if (isMap) {\n     \t\t    //                             value = getMapProxy(value);\n     \t\t    //                         }\n     \t\t    //                     }\n     \t\t    //                 }\n     \t\t    //                 return value;\n     \t\t    //             },\n     \t\t    //             get() {\n     \t\t    //                 return get.call(this);\n     \t\t    //             },\n     \t\t    //             set(value: any) {\n     \t\t    //                 /**\n     \t\t    //                  * Create Proxy for array or map items\n     \t\t    //                  */\n     \t\t    //                 // skip if value is the same as cached.\n     \t\t    //                 if (value === get.call(this)) {\n     \t\t    //                     return;\n     \t\t    //                 }\n     \t\t    //                 if (\n     \t\t    //                     value !== undefined &&\n     \t\t    //                     value !== null\n     \t\t    //                 ) {\n     \t\t    //                     // automaticallty transform Array into ArraySchema\n     \t\t    //                     if (isArray) {\n     \t\t    //                         if (!(value instanceof ArraySchema)) {\n     \t\t    //                             value = new ArraySchema(...value);\n     \t\t    //                         }\n     \t\t    //                         value[$childType] = Object.values(type)[0];\n     \t\t    //                     }\n     \t\t    //                     // automaticallty transform Map into MapSchema\n     \t\t    //                     if (isMap) {\n     \t\t    //                         if (!(value instanceof MapSchema)) {\n     \t\t    //                             value = new MapSchema(value);\n     \t\t    //                         }\n     \t\t    //                         value[$childType] = Object.values(type)[0];\n     \t\t    //                     }\n     \t\t    //                     // try to turn provided structure into a Proxy\n     \t\t    //                     if (value['$proxy'] === undefined) {\n     \t\t    //                         if (isMap) {\n     \t\t    //                             value = getMapProxy(value);\n     \t\t    //                         }\n     \t\t    //                     }\n     \t\t    //                     // flag the change for encoding.\n     \t\t    //                     this[$changes].change(fieldIndex);\n     \t\t    //                     //\n     \t\t    //                     // call setParent() recursively for this and its child\n     \t\t    //                     // structures.\n     \t\t    //                     //\n     \t\t    //                     if (value[$changes]) {\n     \t\t    //                         value[$changes].setParent(\n     \t\t    //                             this,\n     \t\t    //                             this[$changes].root,\n     \t\t    //                             Metadata.getIndex(context.metadata, field),\n     \t\t    //                         );\n     \t\t    //                     }\n     \t\t    //                 } else if (get.call(this)) {\n     \t\t    //                     //\n     \t\t    //                     // Setting a field to `null` or `undefined` will delete it.\n     \t\t    //                     //\n     \t\t    //                     this[$changes].delete(field);\n     \t\t    //                 }\n     \t\t    //                 set.call(this, value);\n     \t\t    //             },\n     \t\t    //         };\n     \t\t    //     }\n     \t\t    // }\n     \t\t    function view(tag = DEFAULT_VIEW_TAG) {\n     \t\t        return function (target, fieldName) {\n     \t\t            const constructor = target.constructor;\n     \t\t            const parentClass = Object.getPrototypeOf(constructor);\n     \t\t            const parentMetadata = parentClass[Symbol.metadata];\n     \t\t            // TODO: use Metadata.initialize()\n     \t\t            const metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n     \t\t            // const fieldIndex = metadata[fieldName];\n     \t\t            // if (!metadata[fieldIndex]) {\n     \t\t            //     //\n     \t\t            //     // detect index for this field, considering inheritance\n     \t\t            //     //\n     \t\t            //     metadata[fieldIndex] = {\n     \t\t            //         type: undefined,\n     \t\t            //         index: (metadata[$numFields] // current structure already has fields defined\n     \t\t            //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n     \t\t            //             ?? -1) + 1 // no fields defined\n     \t\t            //     }\n     \t\t            // }\n     \t\t            Metadata.setTag(metadata, fieldName, tag);\n     \t\t        };\n     \t\t    }\n     \t\t    function type(type, options) {\n     \t\t        return function (target, field) {\n     \t\t            const constructor = target.constructor;\n     \t\t            if (!type) {\n     \t\t                throw new Error(`${constructor.name}: @type() reference provided for \"${field}\" is undefined. Make sure you don't have any circular dependencies.`);\n     \t\t            }\n     \t\t            // for inheritance support\n     \t\t            TypeContext.register(constructor);\n     \t\t            const parentClass = Object.getPrototypeOf(constructor);\n     \t\t            const parentMetadata = parentClass[Symbol.metadata];\n     \t\t            const metadata = Metadata.initialize(constructor);\n     \t\t            let fieldIndex = metadata[field];\n     \t\t            /**\n     \t\t             * skip if descriptor already exists for this field (`@deprecated()`)\n     \t\t             */\n     \t\t            if (metadata[fieldIndex] !== undefined) {\n     \t\t                if (metadata[fieldIndex].deprecated) {\n     \t\t                    // do not create accessors for deprecated properties.\n     \t\t                    return;\n     \t\t                }\n     \t\t                else if (metadata[fieldIndex].type !== undefined) {\n     \t\t                    // trying to define same property multiple times across inheritance.\n     \t\t                    // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\n     \t\t                    try {\n     \t\t                        throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\\nCheck @type() annotation`);\n     \t\t                    }\n     \t\t                    catch (e) {\n     \t\t                        const definitionAtLine = e.stack.split(\"\\n\")[4].trim();\n     \t\t                        throw new Error(`${e.message} ${definitionAtLine}`);\n     \t\t                    }\n     \t\t                }\n     \t\t            }\n     \t\t            else {\n     \t\t                //\n     \t\t                // detect index for this field, considering inheritance\n     \t\t                //\n     \t\t                fieldIndex = metadata[$numFields] // current structure already has fields defined\n     \t\t                    ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n     \t\t                    ?? -1; // no fields defined\n     \t\t                fieldIndex++;\n     \t\t            }\n     \t\t            if (options && options.manual) {\n     \t\t                Metadata.addField(metadata, fieldIndex, field, type, {\n     \t\t                    // do not declare getter/setter descriptor\n     \t\t                    enumerable: true,\n     \t\t                    configurable: true,\n     \t\t                    writable: true,\n     \t\t                });\n     \t\t            }\n     \t\t            else {\n     \t\t                const complexTypeKlass = (Array.isArray(type))\n     \t\t                    ? getType(\"array\")\n     \t\t                    : (typeof (Object.keys(type)[0]) === \"string\") && getType(Object.keys(type)[0]);\n     \t\t                const childType = (complexTypeKlass)\n     \t\t                    ? Object.values(type)[0]\n     \t\t                    : type;\n     \t\t                Metadata.addField(metadata, fieldIndex, field, type, getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass));\n     \t\t            }\n     \t\t        };\n     \t\t    }\n     \t\t    function getPropertyDescriptor(fieldCached, fieldIndex, type, complexTypeKlass) {\n     \t\t        return {\n     \t\t            get: function () { return this[fieldCached]; },\n     \t\t            set: function (value) {\n     \t\t                const previousValue = this[fieldCached] ?? undefined;\n     \t\t                // skip if value is the same as cached.\n     \t\t                if (value === previousValue) {\n     \t\t                    return;\n     \t\t                }\n     \t\t                if (value !== undefined &&\n     \t\t                    value !== null) {\n     \t\t                    if (complexTypeKlass) {\n     \t\t                        // automaticallty transform Array into ArraySchema\n     \t\t                        if (complexTypeKlass.constructor === ArraySchema && !(value instanceof ArraySchema)) {\n     \t\t                            value = new ArraySchema(...value);\n     \t\t                        }\n     \t\t                        // automaticallty transform Map into MapSchema\n     \t\t                        if (complexTypeKlass.constructor === MapSchema && !(value instanceof MapSchema)) {\n     \t\t                            value = new MapSchema(value);\n     \t\t                        }\n     \t\t                        value[$childType] = type;\n     \t\t                    }\n     \t\t                    else if (typeof (type) !== \"string\") {\n     \t\t                        assertInstanceType(value, type, this, fieldCached.substring(1));\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        assertType(value, type, this, fieldCached.substring(1));\n     \t\t                    }\n     \t\t                    const changeTree = this[$changes];\n     \t\t                    //\n     \t\t                    // Replacing existing \"ref\", remove it from root.\n     \t\t                    //\n     \t\t                    if (previousValue !== undefined && previousValue[$changes]) {\n     \t\t                        changeTree.root?.remove(previousValue[$changes]);\n     \t\t                        this.constructor[$track](changeTree, fieldIndex, exports.OPERATION.DELETE_AND_ADD);\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        this.constructor[$track](changeTree, fieldIndex, exports.OPERATION.ADD);\n     \t\t                    }\n     \t\t                    //\n     \t\t                    // call setParent() recursively for this and its child\n     \t\t                    // structures.\n     \t\t                    //\n     \t\t                    value[$changes]?.setParent(this, changeTree.root, fieldIndex);\n     \t\t                }\n     \t\t                else if (previousValue !== undefined) {\n     \t\t                    //\n     \t\t                    // Setting a field to `null` or `undefined` will delete it.\n     \t\t                    //\n     \t\t                    this[$changes].delete(fieldIndex);\n     \t\t                }\n     \t\t                this[fieldCached] = value;\n     \t\t            },\n     \t\t            enumerable: true,\n     \t\t            configurable: true\n     \t\t        };\n     \t\t    }\n     \t\t    /**\n     \t\t     * `@deprecated()` flag a field as deprecated.\n     \t\t     * The previous `@type()` annotation should remain along with this one.\n     \t\t     */\n     \t\t    function deprecated(throws = true) {\n     \t\t        return function (klass, field) {\n     \t\t            //\n     \t\t            // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\n     \t\t            //\n     \t\t            const constructor = klass.constructor;\n     \t\t            const parentClass = Object.getPrototypeOf(constructor);\n     \t\t            const parentMetadata = parentClass[Symbol.metadata];\n     \t\t            const metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n     \t\t            const fieldIndex = metadata[field];\n     \t\t            // if (!metadata[field]) {\n     \t\t            //     //\n     \t\t            //     // detect index for this field, considering inheritance\n     \t\t            //     //\n     \t\t            //     metadata[field] = {\n     \t\t            //         type: undefined,\n     \t\t            //         index: (metadata[$numFields] // current structure already has fields defined\n     \t\t            //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n     \t\t            //             ?? -1) + 1 // no fields defined\n     \t\t            //     }\n     \t\t            // }\n     \t\t            metadata[fieldIndex].deprecated = true;\n     \t\t            if (throws) {\n     \t\t                metadata[$descriptors] ??= {};\n     \t\t                metadata[$descriptors][field] = {\n     \t\t                    get: function () { throw new Error(`${field} is deprecated.`); },\n     \t\t                    set: function (value) { },\n     \t\t                    enumerable: false,\n     \t\t                    configurable: true\n     \t\t                };\n     \t\t            }\n     \t\t            // flag metadata[field] as non-enumerable\n     \t\t            Object.defineProperty(metadata, fieldIndex, {\n     \t\t                value: metadata[fieldIndex],\n     \t\t                enumerable: false,\n     \t\t                configurable: true\n     \t\t            });\n     \t\t        };\n     \t\t    }\n     \t\t    function defineTypes(target, fields, options) {\n     \t\t        for (let field in fields) {\n     \t\t            type(fields[field], options)(target.prototype, field);\n     \t\t        }\n     \t\t        return target;\n     \t\t    }\n     \t\t    function schema(fields, name, inherits = Schema) {\n     \t\t        const defaultValues = {};\n     \t\t        const viewTagFields = {};\n     \t\t        for (let fieldName in fields) {\n     \t\t            const field = fields[fieldName];\n     \t\t            if (typeof (field) === \"object\") {\n     \t\t                if (field['default'] !== undefined) {\n     \t\t                    defaultValues[fieldName] = field['default'];\n     \t\t                }\n     \t\t                if (field['view'] !== undefined) {\n     \t\t                    viewTagFields[fieldName] = (typeof (field['view']) === \"boolean\")\n     \t\t                        ? DEFAULT_VIEW_TAG\n     \t\t                        : field['view'];\n     \t\t                }\n     \t\t            }\n     \t\t        }\n     \t\t        const klass = Metadata.setFields(class extends inherits {\n     \t\t            constructor(...args) {\n     \t\t                args[0] = Object.assign({}, defaultValues, args[0]);\n     \t\t                super(...args);\n     \t\t            }\n     \t\t        }, fields);\n     \t\t        for (let fieldName in viewTagFields) {\n     \t\t            view(viewTagFields[fieldName])(klass.prototype, fieldName);\n     \t\t        }\n     \t\t        if (name) {\n     \t\t            Object.defineProperty(klass, \"name\", { value: name });\n     \t\t        }\n     \t\t        klass.extends = (fields, name) => schema(fields, name, klass);\n     \t\t        return klass;\n     \t\t    }\n\n     \t\t    function getIndent(level) {\n     \t\t        return (new Array(level).fill(0)).map((_, i) => (i === level - 1) ? ` ` : `   `).join(\"\");\n     \t\t    }\n     \t\t    function dumpChanges(schema) {\n     \t\t        const $root = schema[$changes].root;\n     \t\t        const dump = {\n     \t\t            ops: {},\n     \t\t            refs: []\n     \t\t        };\n     \t\t        // for (const refId in $root.changes) {\n     \t\t        $root.changes.forEach(changeTree => {\n     \t\t            // skip if ChangeTree is undefined\n     \t\t            if (changeTree === undefined) {\n     \t\t                return;\n     \t\t            }\n     \t\t            const changes = changeTree.indexedOperations;\n     \t\t            dump.refs.push(`refId#${changeTree.refId}`);\n     \t\t            for (const index in changes) {\n     \t\t                const op = changes[index];\n     \t\t                const opName = exports.OPERATION[op];\n     \t\t                if (!dump.ops[opName]) {\n     \t\t                    dump.ops[opName] = 0;\n     \t\t                }\n     \t\t                dump.ops[exports.OPERATION[op]]++;\n     \t\t            }\n     \t\t        });\n     \t\t        return dump;\n     \t\t    }\n\n     \t\t    var _a$2, _b$2;\n     \t\t    /**\n     \t\t     * Schema encoder / decoder\n     \t\t     */\n     \t\t    class Schema {\n     \t\t        static { this[_a$2] = encodeSchemaOperation; }\n     \t\t        static { this[_b$2] = decodeSchemaOperation; }\n     \t\t        /**\n     \t\t         * Assign the property descriptors required to track changes on this instance.\n     \t\t         * @param instance\n     \t\t         */\n     \t\t        static initialize(instance) {\n     \t\t            Object.defineProperty(instance, $changes, {\n     \t\t                value: new ChangeTree(instance),\n     \t\t                enumerable: false,\n     \t\t                writable: true\n     \t\t            });\n     \t\t            Object.defineProperties(instance, instance.constructor[Symbol.metadata]?.[$descriptors] || {});\n     \t\t        }\n     \t\t        static is(type) {\n     \t\t            return typeof (type[Symbol.metadata]) === \"object\";\n     \t\t            // const metadata = type[Symbol.metadata];\n     \t\t            // return metadata && Object.prototype.hasOwnProperty.call(metadata, -1);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Track property changes\n     \t\t         */\n     \t\t        static [(_a$2 = $encoder, _b$2 = $decoder, $track)](changeTree, index, operation = exports.OPERATION.ADD) {\n     \t\t            changeTree.change(index, operation);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Determine if a property must be filtered.\n     \t\t         * - If returns false, the property is NOT going to be encoded.\n     \t\t         * - If returns true, the property is going to be encoded.\n     \t\t         *\n     \t\t         * Encoding with \"filters\" happens in two steps:\n     \t\t         * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     \t\t         * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     \t\t         */\n     \t\t        static [$filter](ref, index, view) {\n     \t\t            const metadata = ref.constructor[Symbol.metadata];\n     \t\t            const tag = metadata[index]?.tag;\n     \t\t            if (view === undefined) {\n     \t\t                // shared pass/encode: encode if doesn't have a tag\n     \t\t                return tag === undefined;\n     \t\t            }\n     \t\t            else if (tag === undefined) {\n     \t\t                // view pass: no tag\n     \t\t                return true;\n     \t\t            }\n     \t\t            else if (tag === DEFAULT_VIEW_TAG) {\n     \t\t                // view pass: default tag\n     \t\t                return view.isChangeTreeVisible(ref[$changes]);\n     \t\t            }\n     \t\t            else {\n     \t\t                // view pass: custom tag\n     \t\t                const tags = view.tags?.get(ref[$changes]);\n     \t\t                return tags && tags.has(tag);\n     \t\t            }\n     \t\t        }\n     \t\t        // allow inherited classes to have a constructor\n     \t\t        constructor(...args) {\n     \t\t            //\n     \t\t            // inline\n     \t\t            // Schema.initialize(this);\n     \t\t            //\n     \t\t            Schema.initialize(this);\n     \t\t            //\n     \t\t            // Assign initial values\n     \t\t            //\n     \t\t            if (args[0]) {\n     \t\t                Object.assign(this, args[0]);\n     \t\t            }\n     \t\t        }\n     \t\t        assign(props) {\n     \t\t            Object.assign(this, props);\n     \t\t            return this;\n     \t\t        }\n     \t\t        /**\n     \t\t         * (Server-side): Flag a property to be encoded for the next patch.\n     \t\t         * @param instance Schema instance\n     \t\t         * @param property string representing the property name, or number representing the index of the property.\n     \t\t         * @param operation OPERATION to perform (detected automatically)\n     \t\t         */\n     \t\t        setDirty(property, operation) {\n     \t\t            const metadata = this.constructor[Symbol.metadata];\n     \t\t            this[$changes].change(metadata[metadata[property]].index, operation);\n     \t\t        }\n     \t\t        clone() {\n     \t\t            const cloned = new (this.constructor);\n     \t\t            const metadata = this.constructor[Symbol.metadata];\n     \t\t            //\n     \t\t            // TODO: clone all properties, not only annotated ones\n     \t\t            //\n     \t\t            // for (const field in this) {\n     \t\t            for (const fieldIndex in metadata) {\n     \t\t                // const field = metadata[metadata[fieldIndex]].name;\n     \t\t                const field = metadata[fieldIndex].name;\n     \t\t                if (typeof (this[field]) === \"object\" &&\n     \t\t                    typeof (this[field]?.clone) === \"function\") {\n     \t\t                    // deep clone\n     \t\t                    cloned[field] = this[field].clone();\n     \t\t                }\n     \t\t                else {\n     \t\t                    // primitive values\n     \t\t                    cloned[field] = this[field];\n     \t\t                }\n     \t\t            }\n     \t\t            return cloned;\n     \t\t        }\n     \t\t        toJSON() {\n     \t\t            const obj = {};\n     \t\t            const metadata = this.constructor[Symbol.metadata];\n     \t\t            for (const index in metadata) {\n     \t\t                const field = metadata[index];\n     \t\t                const fieldName = field.name;\n     \t\t                if (!field.deprecated && this[fieldName] !== null && typeof (this[fieldName]) !== \"undefined\") {\n     \t\t                    obj[fieldName] = (typeof (this[fieldName]['toJSON']) === \"function\")\n     \t\t                        ? this[fieldName]['toJSON']()\n     \t\t                        : this[fieldName];\n     \t\t                }\n     \t\t            }\n     \t\t            return obj;\n     \t\t        }\n     \t\t        discardAllChanges() {\n     \t\t            this[$changes].discardAll();\n     \t\t        }\n     \t\t        [$getByIndex](index) {\n     \t\t            const metadata = this.constructor[Symbol.metadata];\n     \t\t            return this[metadata[index].name];\n     \t\t        }\n     \t\t        [$deleteByIndex](index) {\n     \t\t            const metadata = this.constructor[Symbol.metadata];\n     \t\t            this[metadata[index].name] = undefined;\n     \t\t        }\n     \t\t        /**\n     \t\t         * Inspect the `refId` of all Schema instances in the tree. Optionally display the contents of the instance.\n     \t\t         *\n     \t\t         * @param ref Schema instance\n     \t\t         * @param showContents display JSON contents of the instance\n     \t\t         * @returns\n     \t\t         */\n     \t\t        static debugRefIds(ref, showContents = false, level = 0) {\n     \t\t            const contents = (showContents) ? ` - ${JSON.stringify(ref.toJSON())}` : \"\";\n     \t\t            const changeTree = ref[$changes];\n     \t\t            const refId = changeTree.refId;\n     \t\t            let output = \"\";\n     \t\t            output += `${getIndent(level)}${ref.constructor.name} (refId: ${refId})${contents}\\n`;\n     \t\t            changeTree.forEachChild((childChangeTree) => output += this.debugRefIds(childChangeTree.ref, showContents, level + 1));\n     \t\t            return output;\n     \t\t        }\n     \t\t        /**\n     \t\t         * Return a string representation of the changes on a Schema instance.\n     \t\t         * The list of changes is cleared after each encode.\n     \t\t         *\n     \t\t         * @param instance Schema instance\n     \t\t         * @param isEncodeAll Return \"full encode\" instead of current change set.\n     \t\t         * @returns\n     \t\t         */\n     \t\t        static debugChanges(instance, isEncodeAll = false) {\n     \t\t            const changeTree = instance[$changes];\n     \t\t            const changeSet = (isEncodeAll) ? changeTree.allChanges : changeTree.changes;\n     \t\t            const changeSetName = (isEncodeAll) ? \"allChanges\" : \"changes\";\n     \t\t            let output = `${instance.constructor.name} (${changeTree.refId}) -> .${changeSetName}:\\n`;\n     \t\t            function dumpChangeSet(changeSet) {\n     \t\t                changeSet.operations\n     \t\t                    .filter(op => op)\n     \t\t                    .forEach((index) => {\n     \t\t                    const operation = changeTree.indexedOperations[index];\n     \t\t                    console.log({ index, operation });\n     \t\t                    output += `- [${index}]: ${exports.OPERATION[operation]} (${JSON.stringify(changeTree.getValue(Number(index), isEncodeAll))})\\n`;\n     \t\t                });\n     \t\t            }\n     \t\t            dumpChangeSet(changeSet);\n     \t\t            // display filtered changes\n     \t\t            if (!isEncodeAll &&\n     \t\t                changeTree.filteredChanges &&\n     \t\t                (changeTree.filteredChanges.operations).filter(op => op).length > 0) {\n     \t\t                output += `${instance.constructor.name} (${changeTree.refId}) -> .filteredChanges:\\n`;\n     \t\t                dumpChangeSet(changeTree.filteredChanges);\n     \t\t            }\n     \t\t            // display filtered changes\n     \t\t            if (isEncodeAll &&\n     \t\t                changeTree.allFilteredChanges &&\n     \t\t                (changeTree.allFilteredChanges.operations).filter(op => op).length > 0) {\n     \t\t                output += `${instance.constructor.name} (${changeTree.refId}) -> .allFilteredChanges:\\n`;\n     \t\t                dumpChangeSet(changeTree.allFilteredChanges);\n     \t\t            }\n     \t\t            return output;\n     \t\t        }\n     \t\t        static debugChangesDeep(ref, changeSetName = \"changes\") {\n     \t\t            let output = \"\";\n     \t\t            const rootChangeTree = ref[$changes];\n     \t\t            const root = rootChangeTree.root;\n     \t\t            const changeTrees = new Map();\n     \t\t            const instanceRefIds = [];\n     \t\t            let totalOperations = 0;\n     \t\t            for (const [refId, changes] of Object.entries(root[changeSetName])) {\n     \t\t                const changeTree = root.changeTrees[refId];\n     \t\t                let includeChangeTree = false;\n     \t\t                let parentChangeTrees = [];\n     \t\t                let parentChangeTree = changeTree.parent?.[$changes];\n     \t\t                if (changeTree === rootChangeTree) {\n     \t\t                    includeChangeTree = true;\n     \t\t                }\n     \t\t                else {\n     \t\t                    while (parentChangeTree !== undefined) {\n     \t\t                        parentChangeTrees.push(parentChangeTree);\n     \t\t                        if (parentChangeTree.ref === ref) {\n     \t\t                            includeChangeTree = true;\n     \t\t                            break;\n     \t\t                        }\n     \t\t                        parentChangeTree = parentChangeTree.parent?.[$changes];\n     \t\t                    }\n     \t\t                }\n     \t\t                if (includeChangeTree) {\n     \t\t                    instanceRefIds.push(changeTree.refId);\n     \t\t                    totalOperations += Object.keys(changes).length;\n     \t\t                    changeTrees.set(changeTree, parentChangeTrees.reverse());\n     \t\t                }\n     \t\t            }\n     \t\t            output += \"---\\n\";\n     \t\t            output += `root refId: ${rootChangeTree.refId}\\n`;\n     \t\t            output += `Total instances: ${instanceRefIds.length} (refIds: ${instanceRefIds.join(\", \")})\\n`;\n     \t\t            output += `Total changes: ${totalOperations}\\n`;\n     \t\t            output += \"---\\n\";\n     \t\t            // based on root.changes, display a tree of changes that has the \"ref\" instance as parent\n     \t\t            const visitedParents = new WeakSet();\n     \t\t            for (const [changeTree, parentChangeTrees] of changeTrees.entries()) {\n     \t\t                parentChangeTrees.forEach((parentChangeTree, level) => {\n     \t\t                    if (!visitedParents.has(parentChangeTree)) {\n     \t\t                        output += `${getIndent(level)}${parentChangeTree.ref.constructor.name} (refId: ${parentChangeTree.refId})\\n`;\n     \t\t                        visitedParents.add(parentChangeTree);\n     \t\t                    }\n     \t\t                });\n     \t\t                const changes = changeTree.indexedOperations;\n     \t\t                const level = parentChangeTrees.length;\n     \t\t                const indent = getIndent(level);\n     \t\t                const parentIndex = (level > 0) ? `(${changeTree.parentIndex}) ` : \"\";\n     \t\t                output += `${indent}${parentIndex}${changeTree.ref.constructor.name} (refId: ${changeTree.refId}) - changes: ${Object.keys(changes).length}\\n`;\n     \t\t                for (const index in changes) {\n     \t\t                    const operation = changes[index];\n     \t\t                    output += `${getIndent(level + 1)}${exports.OPERATION[operation]}: ${index}\\n`;\n     \t\t                }\n     \t\t            }\n     \t\t            return `${output}`;\n     \t\t        }\n     \t\t    }\n\n     \t\t    var _a$1, _b$1;\n     \t\t    class CollectionSchema {\n     \t\t        static { this[_a$1] = encodeKeyValueOperation; }\n     \t\t        static { this[_b$1] = decodeKeyValueOperation; }\n     \t\t        /**\n     \t\t         * Determine if a property must be filtered.\n     \t\t         * - If returns false, the property is NOT going to be encoded.\n     \t\t         * - If returns true, the property is going to be encoded.\n     \t\t         *\n     \t\t         * Encoding with \"filters\" happens in two steps:\n     \t\t         * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     \t\t         * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     \t\t         */\n     \t\t        static [(_a$1 = $encoder, _b$1 = $decoder, $filter)](ref, index, view) {\n     \t\t            return (!view ||\n     \t\t                typeof (ref[$childType]) === \"string\" ||\n     \t\t                view.isChangeTreeVisible((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));\n     \t\t        }\n     \t\t        static is(type) {\n     \t\t            return type['collection'] !== undefined;\n     \t\t        }\n     \t\t        constructor(initialValues) {\n     \t\t            this.$items = new Map();\n     \t\t            this.$indexes = new Map();\n     \t\t            this.deletedItems = {};\n     \t\t            this.$refId = 0;\n     \t\t            this[$changes] = new ChangeTree(this);\n     \t\t            this[$changes].indexes = {};\n     \t\t            if (initialValues) {\n     \t\t                initialValues.forEach((v) => this.add(v));\n     \t\t            }\n     \t\t            Object.defineProperty(this, $childType, {\n     \t\t                value: undefined,\n     \t\t                enumerable: false,\n     \t\t                writable: true,\n     \t\t                configurable: true,\n     \t\t            });\n     \t\t        }\n     \t\t        add(value) {\n     \t\t            // set \"index\" for reference.\n     \t\t            const index = this.$refId++;\n     \t\t            const isRef = (value[$changes]) !== undefined;\n     \t\t            if (isRef) {\n     \t\t                value[$changes].setParent(this, this[$changes].root, index);\n     \t\t            }\n     \t\t            this[$changes].indexes[index] = index;\n     \t\t            this.$indexes.set(index, index);\n     \t\t            this.$items.set(index, value);\n     \t\t            this[$changes].change(index);\n     \t\t            return index;\n     \t\t        }\n     \t\t        at(index) {\n     \t\t            const key = Array.from(this.$items.keys())[index];\n     \t\t            return this.$items.get(key);\n     \t\t        }\n     \t\t        entries() {\n     \t\t            return this.$items.entries();\n     \t\t        }\n     \t\t        delete(item) {\n     \t\t            const entries = this.$items.entries();\n     \t\t            let index;\n     \t\t            let entry;\n     \t\t            while (entry = entries.next()) {\n     \t\t                if (entry.done) {\n     \t\t                    break;\n     \t\t                }\n     \t\t                if (item === entry.value[1]) {\n     \t\t                    index = entry.value[0];\n     \t\t                    break;\n     \t\t                }\n     \t\t            }\n     \t\t            if (index === undefined) {\n     \t\t                return false;\n     \t\t            }\n     \t\t            this.deletedItems[index] = this[$changes].delete(index);\n     \t\t            this.$indexes.delete(index);\n     \t\t            return this.$items.delete(index);\n     \t\t        }\n     \t\t        clear() {\n     \t\t            const changeTree = this[$changes];\n     \t\t            // discard previous operations.\n     \t\t            changeTree.discard(true);\n     \t\t            changeTree.indexes = {};\n     \t\t            // clear previous indexes\n     \t\t            this.$indexes.clear();\n     \t\t            // clear items\n     \t\t            this.$items.clear();\n     \t\t            changeTree.operation(exports.OPERATION.CLEAR);\n     \t\t        }\n     \t\t        has(value) {\n     \t\t            return Array.from(this.$items.values()).some((v) => v === value);\n     \t\t        }\n     \t\t        forEach(callbackfn) {\n     \t\t            this.$items.forEach((value, key, _) => callbackfn(value, key, this));\n     \t\t        }\n     \t\t        values() {\n     \t\t            return this.$items.values();\n     \t\t        }\n     \t\t        get size() {\n     \t\t            return this.$items.size;\n     \t\t        }\n     \t\t        /** Iterator */\n     \t\t        [Symbol.iterator]() {\n     \t\t            return this.$items.values();\n     \t\t        }\n     \t\t        setIndex(index, key) {\n     \t\t            this.$indexes.set(index, key);\n     \t\t        }\n     \t\t        getIndex(index) {\n     \t\t            return this.$indexes.get(index);\n     \t\t        }\n     \t\t        [$getByIndex](index) {\n     \t\t            return this.$items.get(this.$indexes.get(index));\n     \t\t        }\n     \t\t        [$deleteByIndex](index) {\n     \t\t            const key = this.$indexes.get(index);\n     \t\t            this.$items.delete(key);\n     \t\t            this.$indexes.delete(index);\n     \t\t        }\n     \t\t        [$onEncodeEnd]() {\n     \t\t            this.deletedItems = {};\n     \t\t        }\n     \t\t        toArray() {\n     \t\t            return Array.from(this.$items.values());\n     \t\t        }\n     \t\t        toJSON() {\n     \t\t            const values = [];\n     \t\t            this.forEach((value, key) => {\n     \t\t                values.push((typeof (value['toJSON']) === \"function\")\n     \t\t                    ? value['toJSON']()\n     \t\t                    : value);\n     \t\t            });\n     \t\t            return values;\n     \t\t        }\n     \t\t        //\n     \t\t        // Decoding utilities\n     \t\t        //\n     \t\t        clone(isDecoding) {\n     \t\t            let cloned;\n     \t\t            if (isDecoding) {\n     \t\t                // client-side\n     \t\t                cloned = Object.assign(new CollectionSchema(), this);\n     \t\t            }\n     \t\t            else {\n     \t\t                // server-side\n     \t\t                cloned = new CollectionSchema();\n     \t\t                this.forEach((value) => {\n     \t\t                    if (value[$changes]) {\n     \t\t                        cloned.add(value['clone']());\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        cloned.add(value);\n     \t\t                    }\n     \t\t                });\n     \t\t            }\n     \t\t            return cloned;\n     \t\t        }\n     \t\t    }\n     \t\t    registerType(\"collection\", { constructor: CollectionSchema, });\n\n     \t\t    var _a, _b;\n     \t\t    class SetSchema {\n     \t\t        static { this[_a] = encodeKeyValueOperation; }\n     \t\t        static { this[_b] = decodeKeyValueOperation; }\n     \t\t        /**\n     \t\t         * Determine if a property must be filtered.\n     \t\t         * - If returns false, the property is NOT going to be encoded.\n     \t\t         * - If returns true, the property is going to be encoded.\n     \t\t         *\n     \t\t         * Encoding with \"filters\" happens in two steps:\n     \t\t         * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     \t\t         * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     \t\t         */\n     \t\t        static [(_a = $encoder, _b = $decoder, $filter)](ref, index, view) {\n     \t\t            return (!view ||\n     \t\t                typeof (ref[$childType]) === \"string\" ||\n     \t\t                view.visible.has((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes]));\n     \t\t        }\n     \t\t        static is(type) {\n     \t\t            return type['set'] !== undefined;\n     \t\t        }\n     \t\t        constructor(initialValues) {\n     \t\t            this.$items = new Map();\n     \t\t            this.$indexes = new Map();\n     \t\t            this.deletedItems = {};\n     \t\t            this.$refId = 0;\n     \t\t            this[$changes] = new ChangeTree(this);\n     \t\t            this[$changes].indexes = {};\n     \t\t            if (initialValues) {\n     \t\t                initialValues.forEach((v) => this.add(v));\n     \t\t            }\n     \t\t            Object.defineProperty(this, $childType, {\n     \t\t                value: undefined,\n     \t\t                enumerable: false,\n     \t\t                writable: true,\n     \t\t                configurable: true,\n     \t\t            });\n     \t\t        }\n     \t\t        add(value) {\n     \t\t            // immediatelly return false if value already added.\n     \t\t            if (this.has(value)) {\n     \t\t                return false;\n     \t\t            }\n     \t\t            // set \"index\" for reference.\n     \t\t            const index = this.$refId++;\n     \t\t            if ((value[$changes]) !== undefined) {\n     \t\t                value[$changes].setParent(this, this[$changes].root, index);\n     \t\t            }\n     \t\t            const operation = this[$changes].indexes[index]?.op ?? exports.OPERATION.ADD;\n     \t\t            this[$changes].indexes[index] = index;\n     \t\t            this.$indexes.set(index, index);\n     \t\t            this.$items.set(index, value);\n     \t\t            this[$changes].change(index, operation);\n     \t\t            return index;\n     \t\t        }\n     \t\t        entries() {\n     \t\t            return this.$items.entries();\n     \t\t        }\n     \t\t        delete(item) {\n     \t\t            const entries = this.$items.entries();\n     \t\t            let index;\n     \t\t            let entry;\n     \t\t            while (entry = entries.next()) {\n     \t\t                if (entry.done) {\n     \t\t                    break;\n     \t\t                }\n     \t\t                if (item === entry.value[1]) {\n     \t\t                    index = entry.value[0];\n     \t\t                    break;\n     \t\t                }\n     \t\t            }\n     \t\t            if (index === undefined) {\n     \t\t                return false;\n     \t\t            }\n     \t\t            this.deletedItems[index] = this[$changes].delete(index);\n     \t\t            this.$indexes.delete(index);\n     \t\t            return this.$items.delete(index);\n     \t\t        }\n     \t\t        clear() {\n     \t\t            const changeTree = this[$changes];\n     \t\t            // discard previous operations.\n     \t\t            changeTree.discard(true);\n     \t\t            changeTree.indexes = {};\n     \t\t            // clear previous indexes\n     \t\t            this.$indexes.clear();\n     \t\t            // clear items\n     \t\t            this.$items.clear();\n     \t\t            changeTree.operation(exports.OPERATION.CLEAR);\n     \t\t        }\n     \t\t        has(value) {\n     \t\t            const values = this.$items.values();\n     \t\t            let has = false;\n     \t\t            let entry;\n     \t\t            while (entry = values.next()) {\n     \t\t                if (entry.done) {\n     \t\t                    break;\n     \t\t                }\n     \t\t                if (value === entry.value) {\n     \t\t                    has = true;\n     \t\t                    break;\n     \t\t                }\n     \t\t            }\n     \t\t            return has;\n     \t\t        }\n     \t\t        forEach(callbackfn) {\n     \t\t            this.$items.forEach((value, key, _) => callbackfn(value, key, this));\n     \t\t        }\n     \t\t        values() {\n     \t\t            return this.$items.values();\n     \t\t        }\n     \t\t        get size() {\n     \t\t            return this.$items.size;\n     \t\t        }\n     \t\t        /** Iterator */\n     \t\t        [Symbol.iterator]() {\n     \t\t            return this.$items.values();\n     \t\t        }\n     \t\t        setIndex(index, key) {\n     \t\t            this.$indexes.set(index, key);\n     \t\t        }\n     \t\t        getIndex(index) {\n     \t\t            return this.$indexes.get(index);\n     \t\t        }\n     \t\t        [$getByIndex](index) {\n     \t\t            return this.$items.get(this.$indexes.get(index));\n     \t\t        }\n     \t\t        [$deleteByIndex](index) {\n     \t\t            const key = this.$indexes.get(index);\n     \t\t            this.$items.delete(key);\n     \t\t            this.$indexes.delete(index);\n     \t\t        }\n     \t\t        [$onEncodeEnd]() {\n     \t\t            this.deletedItems = {};\n     \t\t        }\n     \t\t        toArray() {\n     \t\t            return Array.from(this.$items.values());\n     \t\t        }\n     \t\t        toJSON() {\n     \t\t            const values = [];\n     \t\t            this.forEach((value, key) => {\n     \t\t                values.push((typeof (value['toJSON']) === \"function\")\n     \t\t                    ? value['toJSON']()\n     \t\t                    : value);\n     \t\t            });\n     \t\t            return values;\n     \t\t        }\n     \t\t        //\n     \t\t        // Decoding utilities\n     \t\t        //\n     \t\t        clone(isDecoding) {\n     \t\t            let cloned;\n     \t\t            if (isDecoding) {\n     \t\t                // client-side\n     \t\t                cloned = Object.assign(new SetSchema(), this);\n     \t\t            }\n     \t\t            else {\n     \t\t                // server-side\n     \t\t                cloned = new SetSchema();\n     \t\t                this.forEach((value) => {\n     \t\t                    if (value[$changes]) {\n     \t\t                        cloned.add(value['clone']());\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        cloned.add(value);\n     \t\t                    }\n     \t\t                });\n     \t\t            }\n     \t\t            return cloned;\n     \t\t        }\n     \t\t    }\n     \t\t    registerType(\"set\", { constructor: SetSchema });\n\n     \t\t    /******************************************************************************\r\n     \t\t    Copyright (c) Microsoft Corporation.\r\n\r\n     \t\t    Permission to use, copy, modify, and/or distribute this software for any\r\n     \t\t    purpose with or without fee is hereby granted.\r\n\r\n     \t\t    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n     \t\t    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n     \t\t    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n     \t\t    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n     \t\t    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n     \t\t    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n     \t\t    PERFORMANCE OF THIS SOFTWARE.\r\n     \t\t    ***************************************************************************** */\r\n     \t\t    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\n     \t\t    function __decorate(decorators, target, key, desc) {\r\n     \t\t        var c = arguments.length, r = c < 3 ? target : desc, d;\r\n     \t\t        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n     \t\t        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n     \t\t        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n     \t\t    }\r\n\r\n     \t\t    typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n     \t\t        var e = new Error(message);\r\n     \t\t        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n     \t\t    };\n\n     \t\t    class Root {\n     \t\t        constructor(types) {\n     \t\t            this.types = types;\n     \t\t            this.nextUniqueId = 0;\n     \t\t            this.refCount = {};\n     \t\t            this.changeTrees = {};\n     \t\t            // all changes\n     \t\t            this.allChanges = [];\n     \t\t            this.allFilteredChanges = []; // TODO: do not initialize it if filters are not used\n     \t\t            // pending changes to be encoded\n     \t\t            this.changes = [];\n     \t\t            this.filteredChanges = []; // TODO: do not initialize it if filters are not used\n     \t\t        }\n     \t\t        getNextUniqueId() {\n     \t\t            return this.nextUniqueId++;\n     \t\t        }\n     \t\t        add(changeTree) {\n     \t\t            // FIXME: move implementation of `ensureRefId` to `Root` class\n     \t\t            changeTree.ensureRefId();\n     \t\t            const isNewChangeTree = (this.changeTrees[changeTree.refId] === undefined);\n     \t\t            if (isNewChangeTree) {\n     \t\t                this.changeTrees[changeTree.refId] = changeTree;\n     \t\t            }\n     \t\t            const previousRefCount = this.refCount[changeTree.refId];\n     \t\t            if (previousRefCount === 0) {\n     \t\t                //\n     \t\t                // When a ChangeTree is re-added, it means that it was previously removed.\n     \t\t                // We need to re-add all changes to the `changes` map.\n     \t\t                //\n     \t\t                const ops = changeTree.allChanges.operations;\n     \t\t                let len = ops.length;\n     \t\t                while (len--) {\n     \t\t                    changeTree.indexedOperations[ops[len]] = exports.OPERATION.ADD;\n     \t\t                    setOperationAtIndex(changeTree.changes, len);\n     \t\t                }\n     \t\t            }\n     \t\t            this.refCount[changeTree.refId] = (previousRefCount || 0) + 1;\n     \t\t            return isNewChangeTree;\n     \t\t        }\n     \t\t        remove(changeTree) {\n     \t\t            const refCount = (this.refCount[changeTree.refId]) - 1;\n     \t\t            if (refCount <= 0) {\n     \t\t                //\n     \t\t                // Only remove \"root\" reference if it's the last reference\n     \t\t                //\n     \t\t                changeTree.root = undefined;\n     \t\t                delete this.changeTrees[changeTree.refId];\n     \t\t                this.removeChangeFromChangeSet(\"allChanges\", changeTree);\n     \t\t                this.removeChangeFromChangeSet(\"changes\", changeTree);\n     \t\t                if (changeTree.filteredChanges) {\n     \t\t                    this.removeChangeFromChangeSet(\"allFilteredChanges\", changeTree);\n     \t\t                    this.removeChangeFromChangeSet(\"filteredChanges\", changeTree);\n     \t\t                }\n     \t\t                this.refCount[changeTree.refId] = 0;\n     \t\t            }\n     \t\t            else {\n     \t\t                this.refCount[changeTree.refId] = refCount;\n     \t\t                //\n     \t\t                // When losing a reference to an instance, it is best to move the\n     \t\t                // ChangeTree to the end of the encoding queue.\n     \t\t                //\n     \t\t                // This way, at decoding time, the instance that contains the\n     \t\t                // ChangeTree will be available before the ChangeTree itself. If the\n     \t\t                // containing instance is not available, the Decoder will throw\n     \t\t                // \"refId not found\" error.\n     \t\t                //\n     \t\t                if (changeTree.filteredChanges !== undefined) {\n     \t\t                    this.removeChangeFromChangeSet(\"filteredChanges\", changeTree);\n     \t\t                    enqueueChangeTree(this, changeTree, \"filteredChanges\");\n     \t\t                }\n     \t\t                else {\n     \t\t                    this.removeChangeFromChangeSet(\"changes\", changeTree);\n     \t\t                    enqueueChangeTree(this, changeTree, \"changes\");\n     \t\t                }\n     \t\t            }\n     \t\t            changeTree.forEachChild((child, _) => this.remove(child));\n     \t\t            return refCount;\n     \t\t        }\n     \t\t        removeChangeFromChangeSet(changeSetName, changeTree) {\n     \t\t            const changeSet = this[changeSetName];\n     \t\t            const changeSetIndex = changeSet.indexOf(changeTree);\n     \t\t            if (changeSetIndex !== -1) {\n     \t\t                changeTree[changeSetName].queueRootIndex = -1;\n     \t\t                changeSet[changeSetIndex] = undefined;\n     \t\t                return true;\n     \t\t            }\n     \t\t            // if (spliceOne(changeSet, changeSet.indexOf(changeTree))) {\n     \t\t            //     changeTree[changeSetName].queueRootIndex = -1;\n     \t\t            //     return true;\n     \t\t            // }\n     \t\t        }\n     \t\t        clear() {\n     \t\t            this.changes.length = 0;\n     \t\t        }\n     \t\t    }\n\n     \t\t    class Encoder {\n     \t\t        static { this.BUFFER_SIZE = (typeof (Buffer) !== \"undefined\") && Buffer.poolSize || 8 * 1024; } // 8KB\n     \t\t        constructor(state) {\n     \t\t            this.sharedBuffer = Buffer.allocUnsafe(Encoder.BUFFER_SIZE);\n     \t\t            //\n     \t\t            // Use .cache() here to avoid re-creating a new context for every new room instance.\n     \t\t            //\n     \t\t            // We may need to make this optional in case of dynamically created\n     \t\t            // schemas - which would lead to memory leaks\n     \t\t            //\n     \t\t            this.context = TypeContext.cache(state.constructor);\n     \t\t            this.root = new Root(this.context);\n     \t\t            this.setState(state);\n     \t\t            // console.log(\">>>>>>>>>>>>>>>> Encoder types\");\n     \t\t            // this.context.schemas.forEach((id, schema) => {\n     \t\t            //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\n     \t\t            // });\n     \t\t        }\n     \t\t        setState(state) {\n     \t\t            this.state = state;\n     \t\t            this.state[$changes].setRoot(this.root);\n     \t\t        }\n     \t\t        encode(it = { offset: 0 }, view, buffer = this.sharedBuffer, changeSetName = \"changes\", isEncodeAll = changeSetName === \"allChanges\", initialOffset = it.offset // cache current offset in case we need to resize the buffer\n     \t\t        ) {\n     \t\t            const hasView = (view !== undefined);\n     \t\t            const rootChangeTree = this.state[$changes];\n     \t\t            const changeTrees = this.root[changeSetName];\n     \t\t            for (let i = 0, numChangeTrees = changeTrees.length; i < numChangeTrees; i++) {\n     \t\t                const changeTree = changeTrees[i];\n     \t\t                if (!changeTree) {\n     \t\t                    continue;\n     \t\t                }\n     \t\t                if (hasView) {\n     \t\t                    if (!view.isChangeTreeVisible(changeTree)) {\n     \t\t                        // console.log(\"MARK AS INVISIBLE:\", { ref: changeTree.ref.constructor.name, refId: changeTree.refId, raw: changeTree.ref.toJSON() });\n     \t\t                        view.invisible.add(changeTree);\n     \t\t                        continue; // skip this change tree\n     \t\t                    }\n     \t\t                    view.invisible.delete(changeTree); // remove from invisible list\n     \t\t                }\n     \t\t                const changeSet = changeTree[changeSetName];\n     \t\t                const ref = changeTree.ref;\n     \t\t                // TODO: avoid iterating over change tree if no changes were made\n     \t\t                const numChanges = changeSet.operations.length;\n     \t\t                if (numChanges === 0) {\n     \t\t                    continue;\n     \t\t                }\n     \t\t                const ctor = ref.constructor;\n     \t\t                const encoder = ctor[$encoder];\n     \t\t                const filter = ctor[$filter];\n     \t\t                const metadata = ctor[Symbol.metadata];\n     \t\t                // skip root `refId` if it's the first change tree\n     \t\t                // (unless it \"hasView\", which will need to revisit the root)\n     \t\t                if (hasView || it.offset > initialOffset || changeTree !== rootChangeTree) {\n     \t\t                    buffer[it.offset++] = SWITCH_TO_STRUCTURE & 255;\n     \t\t                    encode.number(buffer, changeTree.refId, it);\n     \t\t                }\n     \t\t                for (let j = 0; j < numChanges; j++) {\n     \t\t                    const fieldIndex = changeSet.operations[j];\n     \t\t                    const operation = (fieldIndex < 0)\n     \t\t                        ? Math.abs(fieldIndex) // \"pure\" operation without fieldIndex (e.g. CLEAR, REVERSE, etc.)\n     \t\t                        : (isEncodeAll)\n     \t\t                            ? exports.OPERATION.ADD\n     \t\t                            : changeTree.indexedOperations[fieldIndex];\n     \t\t                    //\n     \t\t                    // first pass (encodeAll), identify \"filtered\" operations without encoding them\n     \t\t                    // they will be encoded per client, based on their view.\n     \t\t                    //\n     \t\t                    // TODO: how can we optimize filtering out \"encode all\" operations?\n     \t\t                    // TODO: avoid checking if no view tags were defined\n     \t\t                    //\n     \t\t                    if (fieldIndex === undefined || operation === undefined || (filter && !filter(ref, fieldIndex, view))) {\n     \t\t                        // console.log(\"ADD AS INVISIBLE:\", fieldIndex, changeTree.ref.constructor.name)\n     \t\t                        // view?.invisible.add(changeTree);\n     \t\t                        continue;\n     \t\t                    }\n     \t\t                    encoder(this, buffer, changeTree, fieldIndex, operation, it, isEncodeAll, hasView, metadata);\n     \t\t                }\n     \t\t            }\n     \t\t            if (it.offset > buffer.byteLength) {\n     \t\t                // we can assume that n + 1 poolSize will suffice given that we are likely done with encoding at this point\n     \t\t                // multiples of poolSize are faster to allocate than arbitrary sizes\n     \t\t                // if we are on an older platform that doesn't implement pooling use 8kb as poolSize (that's the default for node)\n     \t\t                const newSize = Math.ceil(it.offset / (Buffer.poolSize ?? 8 * 1024)) * (Buffer.poolSize ?? 8 * 1024);\n     \t\t                console.warn(`@colyseus/schema buffer overflow. Encoded state is higher than default BUFFER_SIZE. Use the following to increase default BUFFER_SIZE:\n\n     import { Encoder } from \"@colyseus/schema\";\n     Encoder.BUFFER_SIZE = ${Math.round(newSize / 1024)} * 1024; // ${Math.round(newSize / 1024)} KB\n `);\n     \t\t                //\n     \t\t                // resize buffer and re-encode (TODO: can we avoid re-encoding here?)\n     \t\t                // -> No we probably can't unless we catch the need for resize before encoding which is likely more computationally expensive than resizing on demand\n     \t\t                //\n     \t\t                buffer = Buffer.alloc(newSize, buffer); // fill with buffer here to memcpy previous encoding steps beyond the initialOffset\n     \t\t                // assign resized buffer to local sharedBuffer\n     \t\t                if (buffer === this.sharedBuffer) {\n     \t\t                    this.sharedBuffer = buffer;\n     \t\t                }\n     \t\t                return this.encode({ offset: initialOffset }, view, buffer, changeSetName, isEncodeAll);\n     \t\t            }\n     \t\t            else {\n     \t\t                return buffer.subarray(0, it.offset);\n     \t\t            }\n     \t\t        }\n     \t\t        encodeAll(it = { offset: 0 }, buffer = this.sharedBuffer) {\n     \t\t            return this.encode(it, undefined, buffer, \"allChanges\", true);\n     \t\t        }\n     \t\t        encodeAllView(view, sharedOffset, it, bytes = this.sharedBuffer) {\n     \t\t            const viewOffset = it.offset;\n     \t\t            // try to encode \"filtered\" changes\n     \t\t            this.encode(it, view, bytes, \"allFilteredChanges\", true, viewOffset);\n     \t\t            return Buffer.concat([\n     \t\t                bytes.subarray(0, sharedOffset),\n     \t\t                bytes.subarray(viewOffset, it.offset)\n     \t\t            ]);\n     \t\t        }\n     \t\t        debugChanges(field) {\n     \t\t            const rootChangeSet = (typeof (field) === \"string\")\n     \t\t                ? this.root[field]\n     \t\t                : field;\n     \t\t            rootChangeSet.forEach((changeTree) => {\n     \t\t                const changeSet = changeTree[field];\n     \t\t                const metadata = changeTree.ref.constructor[Symbol.metadata];\n     \t\t                console.log(\"->\", { ref: changeTree.ref.constructor.name, refId: changeTree.refId, changes: Object.keys(changeSet).length });\n     \t\t                for (const index in changeSet) {\n     \t\t                    const op = changeSet[index];\n     \t\t                    console.log(\"  ->\", {\n     \t\t                        index,\n     \t\t                        field: metadata?.[index],\n     \t\t                        op: exports.OPERATION[op],\n     \t\t                    });\n     \t\t                }\n     \t\t            });\n     \t\t        }\n     \t\t        encodeView(view, sharedOffset, it, bytes = this.sharedBuffer) {\n     \t\t            const viewOffset = it.offset;\n     \t\t            // encode visibility changes (add/remove for this view)\n     \t\t            for (const [refId, changes] of view.changes) {\n     \t\t                const changeTree = this.root.changeTrees[refId];\n     \t\t                if (changeTree === undefined) {\n     \t\t                    // detached instance, remove from view and skip.\n     \t\t                    // console.log(\"detached instance, remove from view and skip.\", refId);\n     \t\t                    view.changes.delete(refId);\n     \t\t                    continue;\n     \t\t                }\n     \t\t                const keys = Object.keys(changes);\n     \t\t                if (keys.length === 0) {\n     \t\t                    // FIXME: avoid having empty changes if no changes were made\n     \t\t                    // console.log(\"changes.size === 0, skip\", refId, changeTree.ref.constructor.name);\n     \t\t                    continue;\n     \t\t                }\n     \t\t                const ref = changeTree.ref;\n     \t\t                const ctor = ref.constructor;\n     \t\t                const encoder = ctor[$encoder];\n     \t\t                const metadata = ctor[Symbol.metadata];\n     \t\t                bytes[it.offset++] = SWITCH_TO_STRUCTURE & 255;\n     \t\t                encode.number(bytes, changeTree.refId, it);\n     \t\t                for (let i = 0, numChanges = keys.length; i < numChanges; i++) {\n     \t\t                    const index = Number(keys[i]);\n     \t\t                    // workaround when using view.add() on item that has been deleted from state (see test \"adding to view item that has been removed from state\")\n     \t\t                    const value = changeTree.ref[$getByIndex](index);\n     \t\t                    const operation = (value !== undefined && changes[index]) || exports.OPERATION.DELETE;\n     \t\t                    // isEncodeAll = false\n     \t\t                    // hasView = true\n     \t\t                    encoder(this, bytes, changeTree, index, operation, it, false, true, metadata);\n     \t\t                }\n     \t\t            }\n     \t\t            //\n     \t\t            // TODO: only clear view changes after all views are encoded\n     \t\t            // (to allow re-using StateView's for multiple clients)\n     \t\t            //\n     \t\t            // clear \"view\" changes after encoding\n     \t\t            view.changes.clear();\n     \t\t            // try to encode \"filtered\" changes\n     \t\t            this.encode(it, view, bytes, \"filteredChanges\", false, viewOffset);\n     \t\t            return Buffer.concat([\n     \t\t                bytes.subarray(0, sharedOffset),\n     \t\t                bytes.subarray(viewOffset, it.offset)\n     \t\t            ]);\n     \t\t        }\n     \t\t        discardChanges() {\n     \t\t            // discard shared changes\n     \t\t            let length = this.root.changes.length;\n     \t\t            if (length > 0) {\n     \t\t                while (length--) {\n     \t\t                    this.root.changes[length]?.endEncode('changes');\n     \t\t                }\n     \t\t                this.root.changes.length = 0;\n     \t\t            }\n     \t\t            // discard filtered changes\n     \t\t            length = this.root.filteredChanges.length;\n     \t\t            if (length > 0) {\n     \t\t                while (length--) {\n     \t\t                    this.root.filteredChanges[length]?.endEncode('filteredChanges');\n     \t\t                }\n     \t\t                this.root.filteredChanges.length = 0;\n     \t\t            }\n     \t\t        }\n     \t\t        tryEncodeTypeId(bytes, baseType, targetType, it) {\n     \t\t            const baseTypeId = this.context.getTypeId(baseType);\n     \t\t            const targetTypeId = this.context.getTypeId(targetType);\n     \t\t            if (targetTypeId === undefined) {\n     \t\t                console.warn(`@colyseus/schema WARNING: Class \"${targetType.name}\" is not registered on TypeRegistry - Please either tag the class with @entity or define a @type() field.`);\n     \t\t                return;\n     \t\t            }\n     \t\t            if (baseTypeId !== targetTypeId) {\n     \t\t                bytes[it.offset++] = TYPE_ID & 255;\n     \t\t                encode.number(bytes, targetTypeId, it);\n     \t\t            }\n     \t\t        }\n     \t\t        get hasChanges() {\n     \t\t            return (this.root.changes.length > 0 ||\n     \t\t                this.root.filteredChanges.length > 0);\n     \t\t        }\n     \t\t    }\n\n     \t\t    function spliceOne(arr, index) {\n     \t\t        // manually splice an array\n     \t\t        if (index === -1 || index >= arr.length) {\n     \t\t            return false;\n     \t\t        }\n     \t\t        const len = arr.length - 1;\n     \t\t        for (let i = index; i < len; i++) {\n     \t\t            arr[i] = arr[i + 1];\n     \t\t        }\n     \t\t        arr.length = len;\n     \t\t        return true;\n     \t\t    }\n\n     \t\t    class DecodingWarning extends Error {\n     \t\t        constructor(message) {\n     \t\t            super(message);\n     \t\t            this.name = \"DecodingWarning\";\n     \t\t        }\n     \t\t    }\n     \t\t    class ReferenceTracker {\n     \t\t        constructor() {\n     \t\t            //\n     \t\t            // Relation of refId => Schema structure\n     \t\t            // For direct access of structures during decoding time.\n     \t\t            //\n     \t\t            this.refs = new Map();\n     \t\t            this.refIds = new WeakMap();\n     \t\t            this.refCounts = {};\n     \t\t            this.deletedRefs = new Set();\n     \t\t            this.callbacks = {};\n     \t\t            this.nextUniqueId = 0;\n     \t\t        }\n     \t\t        getNextUniqueId() {\n     \t\t            return this.nextUniqueId++;\n     \t\t        }\n     \t\t        // for decoding\n     \t\t        addRef(refId, ref, incrementCount = true) {\n     \t\t            this.refs.set(refId, ref);\n     \t\t            this.refIds.set(ref, refId);\n     \t\t            if (incrementCount) {\n     \t\t                this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;\n     \t\t            }\n     \t\t            if (this.deletedRefs.has(refId)) {\n     \t\t                this.deletedRefs.delete(refId);\n     \t\t            }\n     \t\t        }\n     \t\t        // for decoding\n     \t\t        removeRef(refId) {\n     \t\t            const refCount = this.refCounts[refId];\n     \t\t            if (refCount === undefined) {\n     \t\t                try {\n     \t\t                    throw new DecodingWarning(\"trying to remove refId that doesn't exist: \" + refId);\n     \t\t                }\n     \t\t                catch (e) {\n     \t\t                    console.warn(e);\n     \t\t                }\n     \t\t                return;\n     \t\t            }\n     \t\t            if (refCount === 0) {\n     \t\t                try {\n     \t\t                    const ref = this.refs.get(refId);\n     \t\t                    throw new DecodingWarning(`trying to remove refId '${refId}' with 0 refCount (${ref.constructor.name}: ${JSON.stringify(ref)})`);\n     \t\t                }\n     \t\t                catch (e) {\n     \t\t                    console.warn(e);\n     \t\t                }\n     \t\t                return;\n     \t\t            }\n     \t\t            if ((this.refCounts[refId] = refCount - 1) <= 0) {\n     \t\t                this.deletedRefs.add(refId);\n     \t\t            }\n     \t\t        }\n     \t\t        clearRefs() {\n     \t\t            this.refs.clear();\n     \t\t            this.deletedRefs.clear();\n     \t\t            this.callbacks = {};\n     \t\t            this.refCounts = {};\n     \t\t        }\n     \t\t        // for decoding\n     \t\t        garbageCollectDeletedRefs() {\n     \t\t            this.deletedRefs.forEach((refId) => {\n     \t\t                //\n     \t\t                // Skip active references.\n     \t\t                //\n     \t\t                if (this.refCounts[refId] > 0) {\n     \t\t                    return;\n     \t\t                }\n     \t\t                const ref = this.refs.get(refId);\n     \t\t                //\n     \t\t                // Ensure child schema instances have their references removed as well.\n     \t\t                //\n     \t\t                if (ref.constructor[Symbol.metadata] !== undefined) {\n     \t\t                    const metadata = ref.constructor[Symbol.metadata];\n     \t\t                    for (const index in metadata) {\n     \t\t                        const field = metadata[index].name;\n     \t\t                        const childRefId = typeof (ref[field]) === \"object\" && this.refIds.get(ref[field]);\n     \t\t                        if (childRefId && !this.deletedRefs.has(childRefId)) {\n     \t\t                            this.removeRef(childRefId);\n     \t\t                        }\n     \t\t                    }\n     \t\t                }\n     \t\t                else {\n     \t\t                    if (typeof (ref[$childType]) === \"function\") {\n     \t\t                        Array.from(ref.values())\n     \t\t                            .forEach((child) => {\n     \t\t                            const childRefId = this.refIds.get(child);\n     \t\t                            if (!this.deletedRefs.has(childRefId)) {\n     \t\t                                this.removeRef(childRefId);\n     \t\t                            }\n     \t\t                        });\n     \t\t                    }\n     \t\t                }\n     \t\t                this.refs.delete(refId); // remove ref\n     \t\t                delete this.refCounts[refId]; // remove ref count\n     \t\t                delete this.callbacks[refId]; // remove callbacks\n     \t\t            });\n     \t\t            // clear deleted refs.\n     \t\t            this.deletedRefs.clear();\n     \t\t        }\n     \t\t        addCallback(refId, fieldOrOperation, callback) {\n     \t\t            if (refId === undefined) {\n     \t\t                const name = (typeof (fieldOrOperation) === \"number\")\n     \t\t                    ? exports.OPERATION[fieldOrOperation]\n     \t\t                    : fieldOrOperation;\n     \t\t                throw new Error(`Can't addCallback on '${name}' (refId is undefined)`);\n     \t\t            }\n     \t\t            if (!this.callbacks[refId]) {\n     \t\t                this.callbacks[refId] = {};\n     \t\t            }\n     \t\t            if (!this.callbacks[refId][fieldOrOperation]) {\n     \t\t                this.callbacks[refId][fieldOrOperation] = [];\n     \t\t            }\n     \t\t            this.callbacks[refId][fieldOrOperation].push(callback);\n     \t\t            return () => this.removeCallback(refId, fieldOrOperation, callback);\n     \t\t        }\n     \t\t        removeCallback(refId, field, callback) {\n     \t\t            const index = this.callbacks?.[refId]?.[field]?.indexOf(callback);\n     \t\t            if (index !== -1) {\n     \t\t                spliceOne(this.callbacks[refId][field], index);\n     \t\t            }\n     \t\t        }\n     \t\t    }\n\n     \t\t    class Decoder {\n     \t\t        constructor(root, context) {\n     \t\t            this.currentRefId = 0;\n     \t\t            this.setState(root);\n     \t\t            this.context = context || new TypeContext(root.constructor);\n     \t\t            // console.log(\">>>>>>>>>>>>>>>> Decoder types\");\n     \t\t            // this.context.schemas.forEach((id, schema) => {\n     \t\t            //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\n     \t\t            // });\n     \t\t        }\n     \t\t        setState(root) {\n     \t\t            this.state = root;\n     \t\t            this.root = new ReferenceTracker();\n     \t\t            this.root.addRef(0, root);\n     \t\t        }\n     \t\t        decode(bytes, it = { offset: 0 }, ref = this.state) {\n     \t\t            const allChanges = [];\n     \t\t            const $root = this.root;\n     \t\t            const totalBytes = bytes.byteLength;\n     \t\t            let decoder = ref['constructor'][$decoder];\n     \t\t            this.currentRefId = 0;\n     \t\t            while (it.offset < totalBytes) {\n     \t\t                //\n     \t\t                // Peek ahead, check if it's a switch to a different structure\n     \t\t                //\n     \t\t                if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {\n     \t\t                    it.offset++;\n     \t\t                    this.currentRefId = decode.number(bytes, it);\n     \t\t                    const nextRef = $root.refs.get(this.currentRefId);\n     \t\t                    //\n     \t\t                    // Trying to access a reference that haven't been decoded yet.\n     \t\t                    //\n     \t\t                    if (!nextRef) {\n     \t\t                        throw new Error(`\"refId\" not found: ${this.currentRefId}`);\n     \t\t                    }\n     \t\t                    ref[$onDecodeEnd]?.();\n     \t\t                    ref = nextRef;\n     \t\t                    decoder = ref.constructor[$decoder];\n     \t\t                    continue;\n     \t\t                }\n     \t\t                const result = decoder(this, bytes, it, ref, allChanges);\n     \t\t                if (result === DEFINITION_MISMATCH) {\n     \t\t                    console.warn(\"@colyseus/schema: definition mismatch\");\n     \t\t                    //\n     \t\t                    // keep skipping next bytes until reaches a known structure\n     \t\t                    // by local decoder.\n     \t\t                    //\n     \t\t                    const nextIterator = { offset: it.offset };\n     \t\t                    while (it.offset < totalBytes) {\n     \t\t                        if (bytes[it.offset] === SWITCH_TO_STRUCTURE) {\n     \t\t                            nextIterator.offset = it.offset + 1;\n     \t\t                            if ($root.refs.has(decode.number(bytes, nextIterator))) {\n     \t\t                                break;\n     \t\t                            }\n     \t\t                        }\n     \t\t                        it.offset++;\n     \t\t                    }\n     \t\t                    continue;\n     \t\t                }\n     \t\t            }\n     \t\t            // FIXME: DRY with SWITCH_TO_STRUCTURE block.\n     \t\t            ref[$onDecodeEnd]?.();\n     \t\t            // trigger changes\n     \t\t            this.triggerChanges?.(allChanges);\n     \t\t            // drop references of unused schemas\n     \t\t            $root.garbageCollectDeletedRefs();\n     \t\t            return allChanges;\n     \t\t        }\n     \t\t        getInstanceType(bytes, it, defaultType) {\n     \t\t            let type;\n     \t\t            if (bytes[it.offset] === TYPE_ID) {\n     \t\t                it.offset++;\n     \t\t                const type_id = decode.number(bytes, it);\n     \t\t                type = this.context.get(type_id);\n     \t\t            }\n     \t\t            return type || defaultType;\n     \t\t        }\n     \t\t        createInstanceOfType(type) {\n     \t\t            // let instance: Schema = new (type as any)();\n     \t\t            // // assign root on $changes\n     \t\t            // instance[$changes].root = this.root[$changes].root;\n     \t\t            // return instance;\n     \t\t            return new type();\n     \t\t        }\n     \t\t        removeChildRefs(ref, allChanges) {\n     \t\t            const needRemoveRef = typeof (ref[$childType]) !== \"string\";\n     \t\t            const refId = this.root.refIds.get(ref);\n     \t\t            ref.forEach((value, key) => {\n     \t\t                allChanges.push({\n     \t\t                    ref: ref,\n     \t\t                    refId,\n     \t\t                    op: exports.OPERATION.DELETE,\n     \t\t                    field: key,\n     \t\t                    value: undefined,\n     \t\t                    previousValue: value\n     \t\t                });\n     \t\t                if (needRemoveRef) {\n     \t\t                    this.root.removeRef(this.root.refIds.get(value));\n     \t\t                }\n     \t\t            });\n     \t\t        }\n     \t\t    }\n\n     \t\t    /**\n     \t\t     * Reflection\n     \t\t     */\n     \t\t    class ReflectionField extends Schema {\n     \t\t    }\n     \t\t    __decorate([\n     \t\t        type(\"string\")\n     \t\t    ], ReflectionField.prototype, \"name\", void 0);\n     \t\t    __decorate([\n     \t\t        type(\"string\")\n     \t\t    ], ReflectionField.prototype, \"type\", void 0);\n     \t\t    __decorate([\n     \t\t        type(\"number\")\n     \t\t    ], ReflectionField.prototype, \"referencedType\", void 0);\n     \t\t    class ReflectionType extends Schema {\n     \t\t        constructor() {\n     \t\t            super(...arguments);\n     \t\t            this.fields = new ArraySchema();\n     \t\t        }\n     \t\t    }\n     \t\t    __decorate([\n     \t\t        type(\"number\")\n     \t\t    ], ReflectionType.prototype, \"id\", void 0);\n     \t\t    __decorate([\n     \t\t        type(\"number\")\n     \t\t    ], ReflectionType.prototype, \"extendsId\", void 0);\n     \t\t    __decorate([\n     \t\t        type([ReflectionField])\n     \t\t    ], ReflectionType.prototype, \"fields\", void 0);\n     \t\t    class Reflection extends Schema {\n     \t\t        constructor() {\n     \t\t            super(...arguments);\n     \t\t            this.types = new ArraySchema();\n     \t\t        }\n     \t\t        /**\n     \t\t         * Encodes the TypeContext of an Encoder into a buffer.\n     \t\t         *\n     \t\t         * @param encoder Encoder instance\n     \t\t         * @param it\n     \t\t         * @returns\n     \t\t         */\n     \t\t        static encode(encoder, it = { offset: 0 }) {\n     \t\t            const context = encoder.context;\n     \t\t            const reflection = new Reflection();\n     \t\t            const reflectionEncoder = new Encoder(reflection);\n     \t\t            // rootType is usually the first schema passed to the Encoder\n     \t\t            // (unless it inherits from another schema)\n     \t\t            const rootType = context.schemas.get(encoder.state.constructor);\n     \t\t            if (rootType > 0) {\n     \t\t                reflection.rootType = rootType;\n     \t\t            }\n     \t\t            const includedTypeIds = new Set();\n     \t\t            const pendingReflectionTypes = {};\n     \t\t            // add type to reflection in a way that respects inheritance\n     \t\t            // (parent types should be added before their children)\n     \t\t            const addType = (type) => {\n     \t\t                if (type.extendsId === undefined || includedTypeIds.has(type.extendsId)) {\n     \t\t                    includedTypeIds.add(type.id);\n     \t\t                    reflection.types.push(type);\n     \t\t                    const deps = pendingReflectionTypes[type.id];\n     \t\t                    if (deps !== undefined) {\n     \t\t                        delete pendingReflectionTypes[type.id];\n     \t\t                        deps.forEach((childType) => addType(childType));\n     \t\t                    }\n     \t\t                }\n     \t\t                else {\n     \t\t                    if (pendingReflectionTypes[type.extendsId] === undefined) {\n     \t\t                        pendingReflectionTypes[type.extendsId] = [];\n     \t\t                    }\n     \t\t                    pendingReflectionTypes[type.extendsId].push(type);\n     \t\t                }\n     \t\t            };\n     \t\t            context.schemas.forEach((typeid, klass) => {\n     \t\t                const type = new ReflectionType();\n     \t\t                type.id = Number(typeid);\n     \t\t                // support inheritance\n     \t\t                const inheritFrom = Object.getPrototypeOf(klass);\n     \t\t                if (inheritFrom !== Schema) {\n     \t\t                    type.extendsId = context.schemas.get(inheritFrom);\n     \t\t                }\n     \t\t                const metadata = klass[Symbol.metadata];\n     \t\t                //\n     \t\t                // FIXME: this is a workaround for inherited types without additional fields\n     \t\t                // if metadata is the same reference as the parent class - it means the class has no own metadata\n     \t\t                //\n     \t\t                if (metadata !== inheritFrom[Symbol.metadata]) {\n     \t\t                    for (const fieldIndex in metadata) {\n     \t\t                        const index = Number(fieldIndex);\n     \t\t                        const fieldName = metadata[index].name;\n     \t\t                        // skip fields from parent classes\n     \t\t                        if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {\n     \t\t                            continue;\n     \t\t                        }\n     \t\t                        const reflectionField = new ReflectionField();\n     \t\t                        reflectionField.name = fieldName;\n     \t\t                        let fieldType;\n     \t\t                        const field = metadata[index];\n     \t\t                        if (typeof (field.type) === \"string\") {\n     \t\t                            fieldType = field.type;\n     \t\t                        }\n     \t\t                        else {\n     \t\t                            let childTypeSchema;\n     \t\t                            //\n     \t\t                            // TODO: refactor below.\n     \t\t                            //\n     \t\t                            if (Schema.is(field.type)) {\n     \t\t                                fieldType = \"ref\";\n     \t\t                                childTypeSchema = field.type;\n     \t\t                            }\n     \t\t                            else {\n     \t\t                                fieldType = Object.keys(field.type)[0];\n     \t\t                                if (typeof (field.type[fieldType]) === \"string\") {\n     \t\t                                    fieldType += \":\" + field.type[fieldType]; // array:string\n     \t\t                                }\n     \t\t                                else {\n     \t\t                                    childTypeSchema = field.type[fieldType];\n     \t\t                                }\n     \t\t                            }\n     \t\t                            reflectionField.referencedType = (childTypeSchema)\n     \t\t                                ? context.getTypeId(childTypeSchema)\n     \t\t                                : -1;\n     \t\t                        }\n     \t\t                        reflectionField.type = fieldType;\n     \t\t                        type.fields.push(reflectionField);\n     \t\t                    }\n     \t\t                }\n     \t\t                addType(type);\n     \t\t            });\n     \t\t            // in case there are types that were not added due to inheritance\n     \t\t            for (const typeid in pendingReflectionTypes) {\n     \t\t                pendingReflectionTypes[typeid].forEach((type) => reflection.types.push(type));\n     \t\t            }\n     \t\t            const buf = reflectionEncoder.encodeAll(it);\n     \t\t            return Buffer.from(buf, 0, it.offset);\n     \t\t        }\n     \t\t        /**\n     \t\t         * Decodes the TypeContext from a buffer into a Decoder instance.\n     \t\t         *\n     \t\t         * @param bytes Reflection.encode() output\n     \t\t         * @param it\n     \t\t         * @returns Decoder instance\n     \t\t         */\n     \t\t        static decode(bytes, it) {\n     \t\t            const reflection = new Reflection();\n     \t\t            const reflectionDecoder = new Decoder(reflection);\n     \t\t            reflectionDecoder.decode(bytes, it);\n     \t\t            const typeContext = new TypeContext();\n     \t\t            // 1st pass, initialize metadata + inheritance\n     \t\t            reflection.types.forEach((reflectionType) => {\n     \t\t                const parentClass = typeContext.get(reflectionType.extendsId) ?? Schema;\n     \t\t                const schema = class _ extends parentClass {\n     \t\t                };\n     \t\t                // register for inheritance support\n     \t\t                TypeContext.register(schema);\n     \t\t                // // for inheritance support\n     \t\t                // Metadata.initialize(schema);\n     \t\t                typeContext.add(schema, reflectionType.id);\n     \t\t            }, {});\n     \t\t            // define fields\n     \t\t            const addFields = (metadata, reflectionType, parentFieldIndex) => {\n     \t\t                reflectionType.fields.forEach((field, i) => {\n     \t\t                    const fieldIndex = parentFieldIndex + i;\n     \t\t                    if (field.referencedType !== undefined) {\n     \t\t                        let fieldType = field.type;\n     \t\t                        let refType = typeContext.get(field.referencedType);\n     \t\t                        // map or array of primitive type (-1)\n     \t\t                        if (!refType) {\n     \t\t                            const typeInfo = field.type.split(\":\");\n     \t\t                            fieldType = typeInfo[0];\n     \t\t                            refType = typeInfo[1]; // string\n     \t\t                        }\n     \t\t                        if (fieldType === \"ref\") {\n     \t\t                            Metadata.addField(metadata, fieldIndex, field.name, refType);\n     \t\t                        }\n     \t\t                        else {\n     \t\t                            Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });\n     \t\t                        }\n     \t\t                    }\n     \t\t                    else {\n     \t\t                        Metadata.addField(metadata, fieldIndex, field.name, field.type);\n     \t\t                    }\n     \t\t                });\n     \t\t            };\n     \t\t            // 2nd pass, set fields\n     \t\t            reflection.types.forEach((reflectionType) => {\n     \t\t                const schema = typeContext.get(reflectionType.id);\n     \t\t                // for inheritance support\n     \t\t                const metadata = Metadata.initialize(schema);\n     \t\t                const inheritedTypes = [];\n     \t\t                let parentType = reflectionType;\n     \t\t                do {\n     \t\t                    inheritedTypes.push(parentType);\n     \t\t                    parentType = reflection.types.find((t) => t.id === parentType.extendsId);\n     \t\t                } while (parentType);\n     \t\t                let parentFieldIndex = 0;\n     \t\t                inheritedTypes.reverse().forEach((reflectionType) => {\n     \t\t                    // add fields from all inherited classes\n     \t\t                    // TODO: refactor this to avoid adding fields from parent classes\n     \t\t                    addFields(metadata, reflectionType, parentFieldIndex);\n     \t\t                    parentFieldIndex += reflectionType.fields.length;\n     \t\t                });\n     \t\t            });\n     \t\t            const state = new (typeContext.get(reflection.rootType || 0))();\n     \t\t            return new Decoder(state, typeContext);\n     \t\t        }\n     \t\t    }\n     \t\t    __decorate([\n     \t\t        type([ReflectionType])\n     \t\t    ], Reflection.prototype, \"types\", void 0);\n     \t\t    __decorate([\n     \t\t        type(\"number\")\n     \t\t    ], Reflection.prototype, \"rootType\", void 0);\n\n     \t\t    function getDecoderStateCallbacks(decoder) {\n     \t\t        const $root = decoder.root;\n     \t\t        const callbacks = $root.callbacks;\n     \t\t        const onAddCalls = new WeakMap();\n     \t\t        let currentOnAddCallback;\n     \t\t        decoder.triggerChanges = function (allChanges) {\n     \t\t            const uniqueRefIds = new Set();\n     \t\t            for (let i = 0, l = allChanges.length; i < l; i++) {\n     \t\t                const change = allChanges[i];\n     \t\t                const refId = change.refId;\n     \t\t                const ref = change.ref;\n     \t\t                const $callbacks = callbacks[refId];\n     \t\t                if (!$callbacks) {\n     \t\t                    continue;\n     \t\t                }\n     \t\t                //\n     \t\t                // trigger onRemove on child structure.\n     \t\t                //\n     \t\t                if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE &&\n     \t\t                    change.previousValue instanceof Schema) {\n     \t\t                    const deleteCallbacks = callbacks[$root.refIds.get(change.previousValue)]?.[exports.OPERATION.DELETE];\n     \t\t                    for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\n     \t\t                        deleteCallbacks[i]();\n     \t\t                    }\n     \t\t                }\n     \t\t                if (ref instanceof Schema) {\n     \t\t                    //\n     \t\t                    // Handle schema instance\n     \t\t                    //\n     \t\t                    if (!uniqueRefIds.has(refId)) {\n     \t\t                        // trigger onChange\n     \t\t                        const replaceCallbacks = $callbacks?.[exports.OPERATION.REPLACE];\n     \t\t                        for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\n     \t\t                            replaceCallbacks[i]();\n     \t\t                            // try {\n     \t\t                            // } catch (e) {\n     \t\t                            //     console.error(e);\n     \t\t                            // }\n     \t\t                        }\n     \t\t                    }\n     \t\t                    if ($callbacks.hasOwnProperty(change.field)) {\n     \t\t                        const fieldCallbacks = $callbacks[change.field];\n     \t\t                        for (let i = fieldCallbacks?.length - 1; i >= 0; i--) {\n     \t\t                            fieldCallbacks[i](change.value, change.previousValue);\n     \t\t                            // try {\n     \t\t                            // } catch (e) {\n     \t\t                            //     console.error(e);\n     \t\t                            // }\n     \t\t                        }\n     \t\t                    }\n     \t\t                }\n     \t\t                else {\n     \t\t                    //\n     \t\t                    // Handle collection of items\n     \t\t                    //\n     \t\t                    if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {\n     \t\t                        //\n     \t\t                        // FIXME: `previousValue` should always be available.\n     \t\t                        //\n     \t\t                        if (change.previousValue !== undefined) {\n     \t\t                            // triger onRemove\n     \t\t                            const deleteCallbacks = $callbacks[exports.OPERATION.DELETE];\n     \t\t                            for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\n     \t\t                                deleteCallbacks[i](change.previousValue, change.dynamicIndex ?? change.field);\n     \t\t                            }\n     \t\t                        }\n     \t\t                        // Handle DELETE_AND_ADD operations\n     \t\t                        if ((change.op & exports.OPERATION.ADD) === exports.OPERATION.ADD) {\n     \t\t                            const addCallbacks = $callbacks[exports.OPERATION.ADD];\n     \t\t                            for (let i = addCallbacks?.length - 1; i >= 0; i--) {\n     \t\t                                addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n     \t\t                            }\n     \t\t                        }\n     \t\t                    }\n     \t\t                    else if ((change.op & exports.OPERATION.ADD) === exports.OPERATION.ADD && change.previousValue === undefined) {\n     \t\t                        // triger onAdd\n     \t\t                        const addCallbacks = $callbacks[exports.OPERATION.ADD];\n     \t\t                        for (let i = addCallbacks?.length - 1; i >= 0; i--) {\n     \t\t                            addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n     \t\t                        }\n     \t\t                    }\n     \t\t                    // trigger onChange\n     \t\t                    if (change.value !== change.previousValue &&\n     \t\t                        // FIXME: see \"should not encode item if added and removed at the same patch\" test case.\n     \t\t                        // some \"ADD\" + \"DELETE\" operations on same patch are being encoded as \"DELETE\"\n     \t\t                        (change.value !== undefined || change.previousValue !== undefined)) {\n     \t\t                        const replaceCallbacks = $callbacks[exports.OPERATION.REPLACE];\n     \t\t                        for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\n     \t\t                            replaceCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n     \t\t                        }\n     \t\t                    }\n     \t\t                }\n     \t\t                uniqueRefIds.add(refId);\n     \t\t            }\n     \t\t        };\n     \t\t        function getProxy(metadataOrType, context) {\n     \t\t            let metadata = context.instance?.constructor[Symbol.metadata] || metadataOrType;\n     \t\t            let isCollection = ((context.instance && typeof (context.instance['forEach']) === \"function\") ||\n     \t\t                (metadataOrType && typeof (metadataOrType[Symbol.metadata]) === \"undefined\"));\n     \t\t            if (metadata && !isCollection) {\n     \t\t                const onAddListen = function (ref, prop, callback, immediate) {\n     \t\t                    // immediate trigger\n     \t\t                    if (immediate &&\n     \t\t                        context.instance[prop] !== undefined &&\n     \t\t                        !onAddCalls.has(currentOnAddCallback) // Workaround for https://github.com/colyseus/schema/issues/147\n     \t\t                    ) {\n     \t\t                        callback(context.instance[prop], undefined);\n     \t\t                    }\n     \t\t                    return $root.addCallback($root.refIds.get(ref), prop, callback);\n     \t\t                };\n     \t\t                /**\n     \t\t                 * Schema instances\n     \t\t                 */\n     \t\t                return new Proxy({\n     \t\t                    listen: function listen(prop, callback, immediate = true) {\n     \t\t                        if (context.instance) {\n     \t\t                            return onAddListen(context.instance, prop, callback, immediate);\n     \t\t                        }\n     \t\t                        else {\n     \t\t                            // collection instance not received yet\n     \t\t                            let detachCallback = () => { };\n     \t\t                            context.onInstanceAvailable((ref, existing) => {\n     \t\t                                detachCallback = onAddListen(ref, prop, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));\n     \t\t                            });\n     \t\t                            return () => detachCallback();\n     \t\t                        }\n     \t\t                    },\n     \t\t                    onChange: function onChange(callback) {\n     \t\t                        return $root.addCallback($root.refIds.get(context.instance), exports.OPERATION.REPLACE, callback);\n     \t\t                    },\n     \t\t                    //\n     \t\t                    // TODO: refactor `bindTo()` implementation.\n     \t\t                    // There is room for improvement.\n     \t\t                    //\n     \t\t                    bindTo: function bindTo(targetObject, properties) {\n     \t\t                        if (!properties) {\n     \t\t                            properties = Object.keys(metadata).map((index) => metadata[index].name);\n     \t\t                        }\n     \t\t                        return $root.addCallback($root.refIds.get(context.instance), exports.OPERATION.REPLACE, () => {\n     \t\t                            properties.forEach((prop) => targetObject[prop] = context.instance[prop]);\n     \t\t                        });\n     \t\t                    }\n     \t\t                }, {\n     \t\t                    get(target, prop) {\n     \t\t                        const metadataField = metadata[metadata[prop]];\n     \t\t                        if (metadataField) {\n     \t\t                            const instance = context.instance?.[prop];\n     \t\t                            const onInstanceAvailable = ((callback) => {\n     \t\t                                const unbind = $(context.instance).listen(prop, (value, _) => {\n     \t\t                                    callback(value, false);\n     \t\t                                    // FIXME: by \"unbinding\" the callback here,\n     \t\t                                    // it will not support when the server\n     \t\t                                    // re-instantiates the instance.\n     \t\t                                    //\n     \t\t                                    unbind?.();\n     \t\t                                }, false);\n     \t\t                                // has existing value\n     \t\t                                if ($root.refIds.get(instance) !== undefined) {\n     \t\t                                    callback(instance, true);\n     \t\t                                }\n     \t\t                            });\n     \t\t                            return getProxy(metadataField.type, {\n     \t\t                                // make sure refId is available, otherwise need to wait for the instance to be available.\n     \t\t                                instance: ($root.refIds.get(instance) && instance),\n     \t\t                                parentInstance: context.instance,\n     \t\t                                onInstanceAvailable,\n     \t\t                            });\n     \t\t                        }\n     \t\t                        else {\n     \t\t                            // accessing the function\n     \t\t                            return target[prop];\n     \t\t                        }\n     \t\t                    },\n     \t\t                    has(target, prop) { return metadata[prop] !== undefined; },\n     \t\t                    set(_, _1, _2) { throw new Error(\"not allowed\"); },\n     \t\t                    deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\n     \t\t                });\n     \t\t            }\n     \t\t            else {\n     \t\t                /**\n     \t\t                 * Collection instances\n     \t\t                 */\n     \t\t                const onAdd = function (ref, callback, immediate) {\n     \t\t                    // Trigger callback on existing items\n     \t\t                    if (immediate) {\n     \t\t                        ref.forEach((v, k) => callback(v, k));\n     \t\t                    }\n     \t\t                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.ADD, (value, key) => {\n     \t\t                        onAddCalls.set(callback, true);\n     \t\t                        currentOnAddCallback = callback;\n     \t\t                        callback(value, key);\n     \t\t                        onAddCalls.delete(callback);\n     \t\t                        currentOnAddCallback = undefined;\n     \t\t                    });\n     \t\t                };\n     \t\t                const onRemove = function (ref, callback) {\n     \t\t                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.DELETE, callback);\n     \t\t                };\n     \t\t                const onChange = function (ref, callback) {\n     \t\t                    return $root.addCallback($root.refIds.get(ref), exports.OPERATION.REPLACE, callback);\n     \t\t                };\n     \t\t                return new Proxy({\n     \t\t                    onAdd: function (callback, immediate = true) {\n     \t\t                        //\n     \t\t                        // https://github.com/colyseus/schema/issues/147\n     \t\t                        // If parent instance has \"onAdd\" registered, avoid triggering immediate callback.\n     \t\t                        //\n     \t\t                        if (context.instance) {\n     \t\t                            return onAdd(context.instance, callback, immediate && !onAddCalls.has(currentOnAddCallback));\n     \t\t                        }\n     \t\t                        else if (context.onInstanceAvailable) {\n     \t\t                            // collection instance not received yet\n     \t\t                            let detachCallback = () => { };\n     \t\t                            context.onInstanceAvailable((ref, existing) => {\n     \t\t                                detachCallback = onAdd(ref, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));\n     \t\t                            });\n     \t\t                            return () => detachCallback();\n     \t\t                        }\n     \t\t                    },\n     \t\t                    onRemove: function (callback) {\n     \t\t                        if (context.instance) {\n     \t\t                            return onRemove(context.instance, callback);\n     \t\t                        }\n     \t\t                        else if (context.onInstanceAvailable) {\n     \t\t                            // collection instance not received yet\n     \t\t                            let detachCallback = () => { };\n     \t\t                            context.onInstanceAvailable((ref) => {\n     \t\t                                detachCallback = onRemove(ref, callback);\n     \t\t                            });\n     \t\t                            return () => detachCallback();\n     \t\t                        }\n     \t\t                    },\n     \t\t                    onChange: function (callback) {\n     \t\t                        if (context.instance) {\n     \t\t                            return onChange(context.instance, callback);\n     \t\t                        }\n     \t\t                        else if (context.onInstanceAvailable) {\n     \t\t                            // collection instance not received yet\n     \t\t                            let detachCallback = () => { };\n     \t\t                            context.onInstanceAvailable((ref) => {\n     \t\t                                detachCallback = onChange(ref, callback);\n     \t\t                            });\n     \t\t                            return () => detachCallback();\n     \t\t                        }\n     \t\t                    },\n     \t\t                }, {\n     \t\t                    get(target, prop) {\n     \t\t                        if (!target[prop]) {\n     \t\t                            throw new Error(`Can't access '${prop}' through callback proxy. access the instance directly.`);\n     \t\t                        }\n     \t\t                        return target[prop];\n     \t\t                    },\n     \t\t                    has(target, prop) { return target[prop] !== undefined; },\n     \t\t                    set(_, _1, _2) { throw new Error(\"not allowed\"); },\n     \t\t                    deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\n     \t\t                });\n     \t\t            }\n     \t\t        }\n     \t\t        function $(instance) {\n     \t\t            return getProxy(undefined, { instance });\n     \t\t        }\n     \t\t        return $;\n     \t\t    }\n\n     \t\t    function getRawChangesCallback(decoder, callback) {\n     \t\t        decoder.triggerChanges = callback;\n     \t\t    }\n\n     \t\t    class StateView {\n     \t\t        constructor(iterable = false) {\n     \t\t            this.iterable = iterable;\n     \t\t            /**\n     \t\t             * List of ChangeTree's that are visible to this view\n     \t\t             */\n     \t\t            this.visible = new WeakSet();\n     \t\t            /**\n     \t\t             * List of ChangeTree's that are invisible to this view\n     \t\t             */\n     \t\t            this.invisible = new WeakSet();\n     \t\t            /**\n     \t\t             * Manual \"ADD\" operations for changes per ChangeTree, specific to this view.\n     \t\t             * (This is used to force encoding a property, even if it was not changed)\n     \t\t             */\n     \t\t            this.changes = new Map();\n     \t\t            if (iterable) {\n     \t\t                this.items = [];\n     \t\t            }\n     \t\t        }\n     \t\t        // TODO: allow to set multiple tags at once\n     \t\t        add(obj, tag = DEFAULT_VIEW_TAG, checkIncludeParent = true) {\n     \t\t            const changeTree = obj?.[$changes];\n     \t\t            if (!changeTree) {\n     \t\t                console.warn(\"StateView#add(), invalid object:\", obj);\n     \t\t                return this;\n     \t\t            }\n     \t\t            else if (!changeTree.parent &&\n     \t\t                changeTree.refId !== 0 // allow root object\n     \t\t            ) {\n     \t\t                /**\n     \t\t                 * TODO: can we avoid this?\n     \t\t                 *\n     \t\t                 * When the \"parent\" structure has the @view() tag, it is currently\n     \t\t                 * not possible to identify it has to be added to the view as well\n     \t\t                 * (this.addParentOf() is not called).\n     \t\t                 */\n     \t\t                throw new Error(`Cannot add a detached instance to the StateView. Make sure to assign the \"${changeTree.ref.constructor.name}\" instance to the state before calling view.add()`);\n     \t\t            }\n     \t\t            // FIXME: ArraySchema/MapSchema do not have metadata\n     \t\t            const metadata = obj.constructor[Symbol.metadata];\n     \t\t            this.visible.add(changeTree);\n     \t\t            // add to iterable list (only the explicitly added items)\n     \t\t            if (this.iterable && checkIncludeParent) {\n     \t\t                this.items.push(obj);\n     \t\t            }\n     \t\t            // add parent ChangeTree's\n     \t\t            // - if it was invisible to this view\n     \t\t            // - if it were previously filtered out\n     \t\t            if (checkIncludeParent && changeTree.parent) {\n     \t\t                this.addParentOf(changeTree, tag);\n     \t\t            }\n     \t\t            //\n     \t\t            // TODO: when adding an item of a MapSchema, the changes may not\n     \t\t            // be set (only the parent's changes are set)\n     \t\t            //\n     \t\t            let changes = this.changes.get(changeTree.refId);\n     \t\t            if (changes === undefined) {\n     \t\t                changes = {};\n     \t\t                this.changes.set(changeTree.refId, changes);\n     \t\t            }\n     \t\t            // set tag\n     \t\t            if (tag !== DEFAULT_VIEW_TAG) {\n     \t\t                if (!this.tags) {\n     \t\t                    this.tags = new WeakMap();\n     \t\t                }\n     \t\t                let tags;\n     \t\t                if (!this.tags.has(changeTree)) {\n     \t\t                    tags = new Set();\n     \t\t                    this.tags.set(changeTree, tags);\n     \t\t                }\n     \t\t                else {\n     \t\t                    tags = this.tags.get(changeTree);\n     \t\t                }\n     \t\t                tags.add(tag);\n     \t\t                // Ref: add tagged properties\n     \t\t                metadata?.[$fieldIndexesByViewTag]?.[tag]?.forEach((index) => {\n     \t\t                    if (changeTree.getChange(index) !== exports.OPERATION.DELETE) {\n     \t\t                        changes[index] = exports.OPERATION.ADD;\n     \t\t                    }\n     \t\t                });\n     \t\t            }\n     \t\t            else {\n     \t\t                const isInvisible = this.invisible.has(changeTree);\n     \t\t                const changeSet = (changeTree.filteredChanges !== undefined)\n     \t\t                    ? changeTree.allFilteredChanges\n     \t\t                    : changeTree.allChanges;\n     \t\t                for (let i = 0, len = changeSet.operations.length; i < len; i++) {\n     \t\t                    const index = changeSet.operations[i];\n     \t\t                    if (index === undefined) {\n     \t\t                        continue;\n     \t\t                    } // skip \"undefined\" indexes\n     \t\t                    const op = changeTree.indexedOperations[index] ?? exports.OPERATION.ADD;\n     \t\t                    const tagAtIndex = metadata?.[index].tag;\n     \t\t                    if (!changeTree.isNew && // new structures will be added as part of .encode() call, no need to force it to .encodeView()\n     \t\t                        (isInvisible || // if \"invisible\", include all\n     \t\t                            tagAtIndex === undefined || // \"all change\" with no tag\n     \t\t                            tagAtIndex === tag // tagged property\n     \t\t                        ) &&\n     \t\t                        op !== exports.OPERATION.DELETE) {\n     \t\t                        changes[index] = op;\n     \t\t                    }\n     \t\t                }\n     \t\t            }\n     \t\t            // Add children of this ChangeTree to this view\n     \t\t            changeTree.forEachChild((change, index) => {\n     \t\t                // Do not ADD children that don't have the same tag\n     \t\t                if (metadata &&\n     \t\t                    metadata[index].tag !== undefined &&\n     \t\t                    metadata[index].tag !== tag) {\n     \t\t                    return;\n     \t\t                }\n     \t\t                this.add(change.ref, tag, false);\n     \t\t            });\n     \t\t            return this;\n     \t\t        }\n     \t\t        addParentOf(childChangeTree, tag) {\n     \t\t            const changeTree = childChangeTree.parent[$changes];\n     \t\t            const parentIndex = childChangeTree.parentIndex;\n     \t\t            if (!this.visible.has(changeTree)) {\n     \t\t                // view must have all \"changeTree\" parent tree\n     \t\t                this.visible.add(changeTree);\n     \t\t                // add parent's parent\n     \t\t                const parentChangeTree = changeTree.parent?.[$changes];\n     \t\t                if (parentChangeTree && (parentChangeTree.filteredChanges !== undefined)) {\n     \t\t                    this.addParentOf(changeTree, tag);\n     \t\t                }\n     \t\t                // // parent is already available, no need to add it!\n     \t\t                // if (!this.invisible.has(changeTree)) { return; }\n     \t\t            }\n     \t\t            // add parent's tag properties\n     \t\t            if (changeTree.getChange(parentIndex) !== exports.OPERATION.DELETE) {\n     \t\t                let changes = this.changes.get(changeTree.refId);\n     \t\t                if (changes === undefined) {\n     \t\t                    changes = {};\n     \t\t                    this.changes.set(changeTree.refId, changes);\n     \t\t                }\n     \t\t                if (!this.tags) {\n     \t\t                    this.tags = new WeakMap();\n     \t\t                }\n     \t\t                let tags;\n     \t\t                if (!this.tags.has(changeTree)) {\n     \t\t                    tags = new Set();\n     \t\t                    this.tags.set(changeTree, tags);\n     \t\t                }\n     \t\t                else {\n     \t\t                    tags = this.tags.get(changeTree);\n     \t\t                }\n     \t\t                tags.add(tag);\n     \t\t                changes[parentIndex] = exports.OPERATION.ADD;\n     \t\t            }\n     \t\t        }\n     \t\t        remove(obj, tag = DEFAULT_VIEW_TAG, _isClear = false) {\n     \t\t            const changeTree = obj[$changes];\n     \t\t            if (!changeTree) {\n     \t\t                console.warn(\"StateView#remove(), invalid object:\", obj);\n     \t\t                return this;\n     \t\t            }\n     \t\t            this.visible.delete(changeTree);\n     \t\t            // remove from iterable list\n     \t\t            if (this.iterable &&\n     \t\t                !_isClear // no need to remove during clear(), as it will be cleared entirely\n     \t\t            ) {\n     \t\t                spliceOne(this.items, this.items.indexOf(obj));\n     \t\t            }\n     \t\t            const ref = changeTree.ref;\n     \t\t            const metadata = ref.constructor[Symbol.metadata]; // ArraySchema/MapSchema do not have metadata\n     \t\t            let changes = this.changes.get(changeTree.refId);\n     \t\t            if (changes === undefined) {\n     \t\t                changes = {};\n     \t\t                this.changes.set(changeTree.refId, changes);\n     \t\t            }\n     \t\t            if (tag === DEFAULT_VIEW_TAG) {\n     \t\t                // parent is collection (Map/Array)\n     \t\t                const parent = changeTree.parent;\n     \t\t                if (!Metadata.isValidInstance(parent)) {\n     \t\t                    const parentChangeTree = parent[$changes];\n     \t\t                    let changes = this.changes.get(parentChangeTree.refId);\n     \t\t                    if (changes === undefined) {\n     \t\t                        changes = {};\n     \t\t                        this.changes.set(parentChangeTree.refId, changes);\n     \t\t                    }\n     \t\t                    // DELETE / DELETE BY REF ID\n     \t\t                    changes[changeTree.parentIndex] = exports.OPERATION.DELETE;\n     \t\t                }\n     \t\t                else {\n     \t\t                    // delete all \"tagged\" properties.\n     \t\t                    metadata?.[$viewFieldIndexes].forEach((index) => changes[index] = exports.OPERATION.DELETE);\n     \t\t                }\n     \t\t            }\n     \t\t            else {\n     \t\t                // delete only tagged properties\n     \t\t                metadata?.[$fieldIndexesByViewTag][tag].forEach((index) => changes[index] = exports.OPERATION.DELETE);\n     \t\t            }\n     \t\t            // remove tag\n     \t\t            if (this.tags && this.tags.has(changeTree)) {\n     \t\t                const tags = this.tags.get(changeTree);\n     \t\t                if (tag === undefined) {\n     \t\t                    // delete all tags\n     \t\t                    this.tags.delete(changeTree);\n     \t\t                }\n     \t\t                else {\n     \t\t                    // delete specific tag\n     \t\t                    tags.delete(tag);\n     \t\t                    // if tag set is empty, delete it entirely\n     \t\t                    if (tags.size === 0) {\n     \t\t                        this.tags.delete(changeTree);\n     \t\t                    }\n     \t\t                }\n     \t\t            }\n     \t\t            return this;\n     \t\t        }\n     \t\t        has(obj) {\n     \t\t            return this.visible.has(obj[$changes]);\n     \t\t        }\n     \t\t        hasTag(ob, tag = DEFAULT_VIEW_TAG) {\n     \t\t            const tags = this.tags?.get(ob[$changes]);\n     \t\t            return tags?.has(tag) ?? false;\n     \t\t        }\n     \t\t        clear() {\n     \t\t            if (!this.iterable) {\n     \t\t                throw new Error(\"StateView#clear() is only available for iterable StateView's. Use StateView(iterable: true) constructor.\");\n     \t\t            }\n     \t\t            for (let i = 0, l = this.items.length; i < l; i++) {\n     \t\t                this.remove(this.items[i], DEFAULT_VIEW_TAG, true);\n     \t\t            }\n     \t\t            // clear items array\n     \t\t            this.items.length = 0;\n     \t\t        }\n     \t\t        isChangeTreeVisible(changeTree) {\n     \t\t            let isVisible = this.visible.has(changeTree);\n     \t\t            //\n     \t\t            // TODO: avoid checking for parent visibility, most of the time it's not needed\n     \t\t            // See test case: 'should not be required to manually call view.add() items to child arrays without @view() tag'\n     \t\t            //\n     \t\t            if (!isVisible && changeTree.isVisibilitySharedWithParent) {\n     \t\t                // console.log(\"CHECK AGAINST PARENT...\", {\n     \t\t                //     ref: changeTree.ref.constructor.name,\n     \t\t                //     refId: changeTree.refId,\n     \t\t                //     parent: changeTree.parent.constructor.name,\n     \t\t                // });\n     \t\t                if (this.visible.has(changeTree.parent[$changes])) {\n     \t\t                    this.visible.add(changeTree);\n     \t\t                    isVisible = true;\n     \t\t                }\n     \t\t            }\n     \t\t            return isVisible;\n     \t\t        }\n     \t\t    }\n\n     \t\t    registerType(\"map\", { constructor: MapSchema });\n     \t\t    registerType(\"array\", { constructor: ArraySchema });\n     \t\t    registerType(\"set\", { constructor: SetSchema });\n     \t\t    registerType(\"collection\", { constructor: CollectionSchema, });\n\n     \t\t    exports.$changes = $changes;\n     \t\t    exports.$childType = $childType;\n     \t\t    exports.$decoder = $decoder;\n     \t\t    exports.$deleteByIndex = $deleteByIndex;\n     \t\t    exports.$encoder = $encoder;\n     \t\t    exports.$filter = $filter;\n     \t\t    exports.$getByIndex = $getByIndex;\n     \t\t    exports.$track = $track;\n     \t\t    exports.ArraySchema = ArraySchema;\n     \t\t    exports.ChangeTree = ChangeTree;\n     \t\t    exports.CollectionSchema = CollectionSchema;\n     \t\t    exports.Decoder = Decoder;\n     \t\t    exports.Encoder = Encoder;\n     \t\t    exports.MapSchema = MapSchema;\n     \t\t    exports.Metadata = Metadata;\n     \t\t    exports.Reflection = Reflection;\n     \t\t    exports.ReflectionField = ReflectionField;\n     \t\t    exports.ReflectionType = ReflectionType;\n     \t\t    exports.Schema = Schema;\n     \t\t    exports.SetSchema = SetSchema;\n     \t\t    exports.StateView = StateView;\n     \t\t    exports.TypeContext = TypeContext;\n     \t\t    exports.decode = decode;\n     \t\t    exports.decodeKeyValueOperation = decodeKeyValueOperation;\n     \t\t    exports.decodeSchemaOperation = decodeSchemaOperation;\n     \t\t    exports.defineCustomTypes = defineCustomTypes;\n     \t\t    exports.defineTypes = defineTypes;\n     \t\t    exports.deprecated = deprecated;\n     \t\t    exports.dumpChanges = dumpChanges;\n     \t\t    exports.encode = encode;\n     \t\t    exports.encodeArray = encodeArray;\n     \t\t    exports.encodeKeyValueOperation = encodeKeyValueOperation;\n     \t\t    exports.encodeSchemaOperation = encodeSchemaOperation;\n     \t\t    exports.entity = entity;\n     \t\t    exports.getDecoderStateCallbacks = getDecoderStateCallbacks;\n     \t\t    exports.getRawChangesCallback = getRawChangesCallback;\n     \t\t    exports.registerType = registerType;\n     \t\t    exports.schema = schema;\n     \t\t    exports.type = type;\n     \t\t    exports.view = view;\n\n     \t\t})); \n     \t} (umd$1, umd$1.exports));\n     \treturn umd$1.exports;\n     }\n\n     var umdExports = requireUmd();\n\n     class H3TransportTransport {\n         constructor(events) {\n             this.events = events;\n             this.isOpen = false;\n             this.lengthPrefixBuffer = new Uint8Array(9); // 9 bytes is the maximum length of a length prefix\n         }\n         connect(url, options = {}) {\n             const wtOpts = options.fingerprint && ({\n                 // requireUnreliable: true,\n                 // congestionControl: \"default\", // \"low-latency\" || \"throughput\"\n                 serverCertificateHashes: [{\n                         algorithm: 'sha-256',\n                         value: new Uint8Array(options.fingerprint).buffer\n                     }]\n             }) || undefined;\n             this.wt = new WebTransport(url, wtOpts);\n             this.wt.ready.then((e) => {\n                 console.log(\"WebTransport ready!\", e);\n                 this.isOpen = true;\n                 this.unreliableReader = this.wt.datagrams.readable.getReader();\n                 this.unreliableWriter = this.wt.datagrams.writable.getWriter();\n                 const incomingBidi = this.wt.incomingBidirectionalStreams.getReader();\n                 incomingBidi.read().then((stream) => {\n                     this.reader = stream.value.readable.getReader();\n                     this.writer = stream.value.writable.getWriter();\n                     // immediately write room/sessionId for establishing the room connection\n                     this.sendSeatReservation(options.room.roomId, options.sessionId, options.reconnectionToken);\n                     // start reading incoming data\n                     this.readIncomingData();\n                     this.readIncomingUnreliableData();\n                 }).catch((e) => {\n                     console.error(\"failed to read incoming stream\", e);\n                     console.error(\"TODO: close the connection\");\n                 });\n                 // this.events.onopen(e);\n             }).catch((e) => {\n                 // this.events.onerror(e);\n                 // this.events.onclose({ code: e.closeCode, reason: e.reason });\n                 console.log(\"WebTransport not ready!\", e);\n                 this._close();\n             });\n             this.wt.closed.then((e) => {\n                 console.log(\"WebTransport closed w/ success\", e);\n                 this.events.onclose({ code: e.closeCode, reason: e.reason });\n             }).catch((e) => {\n                 console.log(\"WebTransport closed w/ error\", e);\n                 this.events.onerror(e);\n                 this.events.onclose({ code: e.closeCode, reason: e.reason });\n             }).finally(() => {\n                 this._close();\n             });\n         }\n         send(data) {\n             const prefixLength = umdExports.encode.number(this.lengthPrefixBuffer, data.length, { offset: 0 });\n             const dataWithPrefixedLength = new Uint8Array(prefixLength + data.length);\n             dataWithPrefixedLength.set(this.lengthPrefixBuffer.subarray(0, prefixLength), 0);\n             dataWithPrefixedLength.set(data, prefixLength);\n             this.writer.write(dataWithPrefixedLength);\n         }\n         sendUnreliable(data) {\n             const prefixLength = umdExports.encode.number(this.lengthPrefixBuffer, data.length, { offset: 0 });\n             const dataWithPrefixedLength = new Uint8Array(prefixLength + data.length);\n             dataWithPrefixedLength.set(this.lengthPrefixBuffer.subarray(0, prefixLength), 0);\n             dataWithPrefixedLength.set(data, prefixLength);\n             this.unreliableWriter.write(dataWithPrefixedLength);\n         }\n         close(code, reason) {\n             try {\n                 this.wt.close({ closeCode: code, reason: reason });\n             }\n             catch (e) {\n                 console.error(e);\n             }\n         }\n         readIncomingData() {\n             return __awaiter(this, void 0, void 0, function* () {\n                 let result;\n                 while (this.isOpen) {\n                     try {\n                         result = yield this.reader.read();\n                         //\n                         // a single read may contain multiple messages\n                         // each message is prefixed with its length\n                         //\n                         const messages = result.value;\n                         const it = { offset: 0 };\n                         do {\n                             //\n                             // QUESTION: should we buffer the message in case it's not fully read?\n                             //\n                             const length = umdExports.decode.number(messages, it);\n                             this.events.onmessage({ data: messages.subarray(it.offset, it.offset + length) });\n                             it.offset += length;\n                         } while (it.offset < messages.length);\n                     }\n                     catch (e) {\n                         if (e.message.indexOf(\"session is closed\") === -1) {\n                             console.error(\"H3Transport: failed to read incoming data\", e);\n                         }\n                         break;\n                     }\n                     if (result.done) {\n                         break;\n                     }\n                 }\n             });\n         }\n         readIncomingUnreliableData() {\n             return __awaiter(this, void 0, void 0, function* () {\n                 let result;\n                 while (this.isOpen) {\n                     try {\n                         result = yield this.unreliableReader.read();\n                         //\n                         // a single read may contain multiple messages\n                         // each message is prefixed with its length\n                         //\n                         const messages = result.value;\n                         const it = { offset: 0 };\n                         do {\n                             //\n                             // QUESTION: should we buffer the message in case it's not fully read?\n                             //\n                             const length = umdExports.decode.number(messages, it);\n                             this.events.onmessage({ data: messages.subarray(it.offset, it.offset + length) });\n                             it.offset += length;\n                         } while (it.offset < messages.length);\n                     }\n                     catch (e) {\n                         if (e.message.indexOf(\"session is closed\") === -1) {\n                             console.error(\"H3Transport: failed to read incoming data\", e);\n                         }\n                         break;\n                     }\n                     if (result.done) {\n                         break;\n                     }\n                 }\n             });\n         }\n         sendSeatReservation(roomId, sessionId, reconnectionToken) {\n             const it = { offset: 0 };\n             const bytes = [];\n             umdExports.encode.string(bytes, roomId, it);\n             umdExports.encode.string(bytes, sessionId, it);\n             if (reconnectionToken) {\n                 umdExports.encode.string(bytes, reconnectionToken, it);\n             }\n             this.writer.write(new Uint8Array(bytes).buffer);\n         }\n         _close() {\n             this.isOpen = false;\n         }\n     }\n\n     var browser;\n     var hasRequiredBrowser;\n\n     function requireBrowser () {\n     \tif (hasRequiredBrowser) return browser;\n     \thasRequiredBrowser = 1;\n\n     \tbrowser = function () {\n     \t  throw new Error(\n     \t    'ws does not work in the browser. Browser clients must use the native ' +\n     \t      'WebSocket object'\n     \t  );\n     \t};\n     \treturn browser;\n     }\n\n     var browserExports = requireBrowser();\n     var NodeWebSocket = /*@__PURE__*/getDefaultExportFromCjs(browserExports);\n\n     const WebSocket = globalThis.WebSocket || NodeWebSocket;\n     class WebSocketTransport {\n         constructor(events) {\n             this.events = events;\n         }\n         send(data) {\n             this.ws.send(data);\n         }\n         sendUnreliable(data) {\n             console.warn(\"colyseus.js: The WebSocket transport does not support unreliable messages\");\n         }\n         /**\n          * @param url URL to connect to\n          * @param headers custom headers to send with the connection (only supported in Node.js. Web Browsers do not allow setting custom headers)\n          */\n         connect(url, headers) {\n             try {\n                 // Node or Bun environments (supports custom headers)\n                 this.ws = new WebSocket(url, { headers, protocols: this.protocols });\n             }\n             catch (e) {\n                 // browser environment (custom headers not supported)\n                 this.ws = new WebSocket(url, this.protocols);\n             }\n             this.ws.binaryType = 'arraybuffer';\n             this.ws.onopen = this.events.onopen;\n             this.ws.onmessage = this.events.onmessage;\n             this.ws.onclose = this.events.onclose;\n             this.ws.onerror = this.events.onerror;\n         }\n         close(code, reason) {\n             this.ws.close(code, reason);\n         }\n         get isOpen() {\n             return this.ws.readyState === WebSocket.OPEN;\n         }\n     }\n\n     class Connection {\n         constructor(protocol) {\n             this.events = {};\n             switch (protocol) {\n                 case \"h3\":\n                     this.transport = new H3TransportTransport(this.events);\n                     break;\n                 default:\n                     this.transport = new WebSocketTransport(this.events);\n                     break;\n             }\n         }\n         connect(url, options) {\n             this.transport.connect.call(this.transport, url, options);\n         }\n         send(data) {\n             this.transport.send(data);\n         }\n         sendUnreliable(data) {\n             this.transport.sendUnreliable(data);\n         }\n         close(code, reason) {\n             this.transport.close(code, reason);\n         }\n         get isOpen() {\n             return this.transport.isOpen;\n         }\n     }\n\n     // Use codes between 0~127 for lesser throughput (1 byte)\n     exports.Protocol = void 0;\n     (function (Protocol) {\n         // Room-related (10~19)\n         Protocol[Protocol[\"HANDSHAKE\"] = 9] = \"HANDSHAKE\";\n         Protocol[Protocol[\"JOIN_ROOM\"] = 10] = \"JOIN_ROOM\";\n         Protocol[Protocol[\"ERROR\"] = 11] = \"ERROR\";\n         Protocol[Protocol[\"LEAVE_ROOM\"] = 12] = \"LEAVE_ROOM\";\n         Protocol[Protocol[\"ROOM_DATA\"] = 13] = \"ROOM_DATA\";\n         Protocol[Protocol[\"ROOM_STATE\"] = 14] = \"ROOM_STATE\";\n         Protocol[Protocol[\"ROOM_STATE_PATCH\"] = 15] = \"ROOM_STATE_PATCH\";\n         Protocol[Protocol[\"ROOM_DATA_SCHEMA\"] = 16] = \"ROOM_DATA_SCHEMA\";\n         Protocol[Protocol[\"ROOM_DATA_BYTES\"] = 17] = \"ROOM_DATA_BYTES\";\n     })(exports.Protocol || (exports.Protocol = {}));\n     exports.ErrorCode = void 0;\n     (function (ErrorCode) {\n         ErrorCode[ErrorCode[\"MATCHMAKE_NO_HANDLER\"] = 4210] = \"MATCHMAKE_NO_HANDLER\";\n         ErrorCode[ErrorCode[\"MATCHMAKE_INVALID_CRITERIA\"] = 4211] = \"MATCHMAKE_INVALID_CRITERIA\";\n         ErrorCode[ErrorCode[\"MATCHMAKE_INVALID_ROOM_ID\"] = 4212] = \"MATCHMAKE_INVALID_ROOM_ID\";\n         ErrorCode[ErrorCode[\"MATCHMAKE_UNHANDLED\"] = 4213] = \"MATCHMAKE_UNHANDLED\";\n         ErrorCode[ErrorCode[\"MATCHMAKE_EXPIRED\"] = 4214] = \"MATCHMAKE_EXPIRED\";\n         ErrorCode[ErrorCode[\"AUTH_FAILED\"] = 4215] = \"AUTH_FAILED\";\n         ErrorCode[ErrorCode[\"APPLICATION_ERROR\"] = 4216] = \"APPLICATION_ERROR\";\n     })(exports.ErrorCode || (exports.ErrorCode = {}));\n\n     const serializers = {};\n     function registerSerializer(id, serializer) {\n         serializers[id] = serializer;\n     }\n     function getSerializer(id) {\n         const serializer = serializers[id];\n         if (!serializer) {\n             throw new Error(\"missing serializer: \" + id);\n         }\n         return serializer;\n     }\n\n     /**\n      * The MIT License (MIT)\n      *\n      * Copyright 2016 Andrey Sitnik <andrey@sitnik.ru>\n      *\n      * Permission is hereby granted, free of charge, to any person obtaining a copy of\n      * this software and associated documentation files (the \"Software\"), to deal in\n      * the Software without restriction, including without limitation the rights to\n      * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n      * the Software, and to permit persons to whom the Software is furnished to do so,\n      * subject to the following conditions:\n      *\n      * The above copyright notice and this permission notice shall be included in all\n      * copies or substantial portions of the Software.\n      *\n      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n      * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n      * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n      * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n      * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n      */\n     const createNanoEvents = () => ({\n         emit(event, ...args) {\n             let callbacks = this.events[event] || [];\n             for (let i = 0, length = callbacks.length; i < length; i++) {\n                 callbacks[i](...args);\n             }\n         },\n         events: {},\n         on(event, cb) {\n             var _a;\n             ((_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.push(cb)) || (this.events[event] = [cb]);\n             return () => {\n                 var _a;\n                 this.events[event] = (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.filter(i => cb !== i);\n             };\n         }\n     });\n\n     class EventEmitter {\n         constructor() {\n             this.handlers = [];\n         }\n         register(cb, once = false) {\n             this.handlers.push(cb);\n             return this;\n         }\n         invoke(...args) {\n             this.handlers.forEach((handler) => handler.apply(this, args));\n         }\n         invokeAsync(...args) {\n             return Promise.all(this.handlers.map((handler) => handler.apply(this, args)));\n         }\n         remove(cb) {\n             const index = this.handlers.indexOf(cb);\n             this.handlers[index] = this.handlers[this.handlers.length - 1];\n             this.handlers.pop();\n         }\n         clear() {\n             this.handlers = [];\n         }\n     }\n     function createSignal() {\n         const emitter = new EventEmitter();\n         function register(cb) {\n             return emitter.register(cb, this === null);\n         }\n         register.once = (cb) => {\n             const callback = function (...args) {\n                 cb.apply(this, args);\n                 emitter.remove(callback);\n             };\n             emitter.register(callback);\n         };\n         register.remove = (cb) => emitter.remove(cb);\n         register.invoke = (...args) => emitter.invoke(...args);\n         register.invokeAsync = (...args) => emitter.invokeAsync(...args);\n         register.clear = () => emitter.clear();\n         return register;\n     }\n\n     function getStateCallbacks(room) {\n         try {\n             // SchemaSerializer\n             return umdExports.getDecoderStateCallbacks(room['serializer'].decoder);\n         }\n         catch (e) {\n             // NoneSerializer\n             return undefined;\n         }\n     }\n     class SchemaSerializer {\n         setState(encodedState, it) {\n             this.decoder.decode(encodedState, it);\n         }\n         getState() {\n             return this.state;\n         }\n         patch(patches, it) {\n             return this.decoder.decode(patches, it);\n         }\n         teardown() {\n             this.decoder.root.clearRefs();\n         }\n         handshake(bytes, it) {\n             if (this.state) {\n                 //\n                 // TODO: validate definitions against concreate this.state instance\n                 //\n                 umdExports.Reflection.decode(bytes, it); // no-op\n                 this.decoder = new umdExports.Decoder(this.state);\n             }\n             else {\n                 // initialize reflected state from server\n                 this.decoder = umdExports.Reflection.decode(bytes, it);\n                 this.state = this.decoder.state;\n             }\n         }\n     }\n\n     var decoder;\n     try {\n     \tdecoder = new TextDecoder();\n     } catch(error) {}\n     var src;\n     var srcEnd;\n     var position$1 = 0;\n     var currentUnpackr = {};\n     var currentStructures;\n     var srcString;\n     var srcStringStart = 0;\n     var srcStringEnd = 0;\n     var bundledStrings$1;\n     var referenceMap;\n     var currentExtensions = [];\n     var dataView;\n     var defaultOptions = {\n     \tuseRecords: false,\n     \tmapsAsObjects: true\n     };\n     class C1Type {}\n     const C1 = new C1Type();\n     C1.name = 'MessagePack 0xC1';\n     var sequentialMode = false;\n     var inlineObjectReadThreshold = 2;\n     var readStruct;\n     // no-eval build\n     try {\n     \tnew Function('');\n     } catch(error) {\n     \t// if eval variants are not supported, do not create inline object readers ever\n     \tinlineObjectReadThreshold = Infinity;\n     }\n\n     class Unpackr {\n     \tconstructor(options) {\n     \t\tif (options) {\n     \t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n     \t\t\t\toptions.mapsAsObjects = true;\n     \t\t\tif (options.sequential && options.trusted !== false) {\n     \t\t\t\toptions.trusted = true;\n     \t\t\t\tif (!options.structures && options.useRecords != false) {\n     \t\t\t\t\toptions.structures = [];\n     \t\t\t\t\tif (!options.maxSharedStructures)\n     \t\t\t\t\t\toptions.maxSharedStructures = 0;\n     \t\t\t\t}\n     \t\t\t}\n     \t\t\tif (options.structures)\n     \t\t\t\toptions.structures.sharedLength = options.structures.length;\n     \t\t\telse if (options.getStructures) {\n     \t\t\t\t(options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures\n     \t\t\t\toptions.structures.sharedLength = 0;\n     \t\t\t}\n     \t\t\tif (options.int64AsNumber) {\n     \t\t\t\toptions.int64AsType = 'number';\n     \t\t\t}\n     \t\t}\n     \t\tObject.assign(this, options);\n     \t}\n     \tunpack(source, options) {\n     \t\tif (src) {\n     \t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n     \t\t\treturn saveState(() => {\n     \t\t\t\tclearSource();\n     \t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n     \t\t\t})\n     \t\t}\n     \t\tif (!source.buffer && source.constructor === ArrayBuffer)\n     \t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n     \t\tif (typeof options === 'object') {\n     \t\t\tsrcEnd = options.end || source.length;\n     \t\t\tposition$1 = options.start || 0;\n     \t\t} else {\n     \t\t\tposition$1 = 0;\n     \t\t\tsrcEnd = options > -1 ? options : source.length;\n     \t\t}\n     \t\tsrcStringEnd = 0;\n     \t\tsrcString = null;\n     \t\tbundledStrings$1 = null;\n     \t\tsrc = source;\n     \t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n     \t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n     \t\t// new ones\n     \t\ttry {\n     \t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n     \t\t} catch(error) {\n     \t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n     \t\t\tsrc = null;\n     \t\t\tif (source instanceof Uint8Array)\n     \t\t\t\tthrow error\n     \t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n     \t\t}\n     \t\tif (this instanceof Unpackr) {\n     \t\t\tcurrentUnpackr = this;\n     \t\t\tif (this.structures) {\n     \t\t\t\tcurrentStructures = this.structures;\n     \t\t\t\treturn checkedRead(options)\n     \t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n     \t\t\t\tcurrentStructures = [];\n     \t\t\t}\n     \t\t} else {\n     \t\t\tcurrentUnpackr = defaultOptions;\n     \t\t\tif (!currentStructures || currentStructures.length > 0)\n     \t\t\t\tcurrentStructures = [];\n     \t\t}\n     \t\treturn checkedRead(options)\n     \t}\n     \tunpackMultiple(source, forEach) {\n     \t\tlet values, lastPosition = 0;\n     \t\ttry {\n     \t\t\tsequentialMode = true;\n     \t\t\tlet size = source.length;\n     \t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size);\n     \t\t\tif (forEach) {\n     \t\t\t\tif (forEach(value, lastPosition, position$1) === false) return;\n     \t\t\t\twhile(position$1 < size) {\n     \t\t\t\t\tlastPosition = position$1;\n     \t\t\t\t\tif (forEach(checkedRead(), lastPosition, position$1) === false) {\n     \t\t\t\t\t\treturn\n     \t\t\t\t\t}\n     \t\t\t\t}\n     \t\t\t}\n     \t\t\telse {\n     \t\t\t\tvalues = [ value ];\n     \t\t\t\twhile(position$1 < size) {\n     \t\t\t\t\tlastPosition = position$1;\n     \t\t\t\t\tvalues.push(checkedRead());\n     \t\t\t\t}\n     \t\t\t\treturn values\n     \t\t\t}\n     \t\t} catch(error) {\n     \t\t\terror.lastPosition = lastPosition;\n     \t\t\terror.values = values;\n     \t\t\tthrow error\n     \t\t} finally {\n     \t\t\tsequentialMode = false;\n     \t\t\tclearSource();\n     \t\t}\n     \t}\n     \t_mergeStructures(loadedStructures, existingStructures) {\n     \t\tloadedStructures = loadedStructures || [];\n     \t\tif (Object.isFrozen(loadedStructures))\n     \t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0));\n     \t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n     \t\t\tlet structure = loadedStructures[i];\n     \t\t\tif (structure) {\n     \t\t\t\tstructure.isShared = true;\n     \t\t\t\tif (i >= 32)\n     \t\t\t\t\tstructure.highByte = (i - 32) >> 5;\n     \t\t\t}\n     \t\t}\n     \t\tloadedStructures.sharedLength = loadedStructures.length;\n     \t\tfor (let id in existingStructures || []) {\n     \t\t\tif (id >= 0) {\n     \t\t\t\tlet structure = loadedStructures[id];\n     \t\t\t\tlet existing = existingStructures[id];\n     \t\t\t\tif (existing) {\n     \t\t\t\t\tif (structure)\n     \t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;\n     \t\t\t\t\tloadedStructures[id] = existing;\n     \t\t\t\t}\n     \t\t\t}\n     \t\t}\n     \t\treturn this.structures = loadedStructures\n     \t}\n     \tdecode(source, options) {\n     \t\treturn this.unpack(source, options)\n     \t}\n     }\n     function checkedRead(options) {\n     \ttry {\n     \t\tif (!currentUnpackr.trusted && !sequentialMode) {\n     \t\t\tlet sharedLength = currentStructures.sharedLength || 0;\n     \t\t\tif (sharedLength < currentStructures.length)\n     \t\t\t\tcurrentStructures.length = sharedLength;\n     \t\t}\n     \t\tlet result;\n     \t\tif (currentUnpackr.randomAccessStructure && src[position$1] < 0x40 && src[position$1] >= 0x20 && readStruct) ; else\n     \t\t\tresult = read();\n     \t\tif (bundledStrings$1) { // bundled strings to skip past\n     \t\t\tposition$1 = bundledStrings$1.postBundlePosition;\n     \t\t\tbundledStrings$1 = null;\n     \t\t}\n     \t\tif (sequentialMode)\n     \t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n     \t\t\t// we can clear this out and keep the structures we read\n     \t\t\tcurrentStructures.restoreStructures = null;\n\n     \t\tif (position$1 == srcEnd) {\n     \t\t\t// finished reading this source, cleanup references\n     \t\t\tif (currentStructures && currentStructures.restoreStructures)\n     \t\t\t\trestoreStructures();\n     \t\t\tcurrentStructures = null;\n     \t\t\tsrc = null;\n     \t\t\tif (referenceMap)\n     \t\t\t\treferenceMap = null;\n     \t\t} else if (position$1 > srcEnd) {\n     \t\t\t// over read\n     \t\t\tthrow new Error('Unexpected end of MessagePack data')\n     \t\t} else if (!sequentialMode) {\n     \t\t\tlet jsonView;\n     \t\t\ttry {\n     \t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100);\n     \t\t\t} catch(error) {\n     \t\t\t\tjsonView = '(JSON view not available ' + error + ')';\n     \t\t\t}\n     \t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n     \t\t}\n     \t\t// else more to read, but we are reading sequentially, so don't clear source yet\n     \t\treturn result\n     \t} catch(error) {\n     \t\tif (currentStructures && currentStructures.restoreStructures)\n     \t\t\trestoreStructures();\n     \t\tclearSource();\n     \t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position$1 > srcEnd) {\n     \t\t\terror.incomplete = true;\n     \t\t}\n     \t\tthrow error\n     \t}\n     }\n\n     function restoreStructures() {\n     \tfor (let id in currentStructures.restoreStructures) {\n     \t\tcurrentStructures[id] = currentStructures.restoreStructures[id];\n     \t}\n     \tcurrentStructures.restoreStructures = null;\n     }\n\n     function read() {\n     \tlet token = src[position$1++];\n     \tif (token < 0xa0) {\n     \t\tif (token < 0x80) {\n     \t\t\tif (token < 0x40)\n     \t\t\t\treturn token\n     \t\t\telse {\n     \t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n     \t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f];\n     \t\t\t\tif (structure) {\n     \t\t\t\t\tif (!structure.read) {\n     \t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f);\n     \t\t\t\t\t}\n     \t\t\t\t\treturn structure.read()\n     \t\t\t\t} else\n     \t\t\t\t\treturn token\n     \t\t\t}\n     \t\t} else if (token < 0x90) {\n     \t\t\t// map\n     \t\t\ttoken -= 0x80;\n     \t\t\tif (currentUnpackr.mapsAsObjects) {\n     \t\t\t\tlet object = {};\n     \t\t\t\tfor (let i = 0; i < token; i++) {\n     \t\t\t\t\tlet key = readKey();\n     \t\t\t\t\tif (key === '__proto__')\n     \t\t\t\t\t\tkey = '__proto_';\n     \t\t\t\t\tobject[key] = read();\n     \t\t\t\t}\n     \t\t\t\treturn object\n     \t\t\t} else {\n     \t\t\t\tlet map = new Map();\n     \t\t\t\tfor (let i = 0; i < token; i++) {\n     \t\t\t\t\tmap.set(read(), read());\n     \t\t\t\t}\n     \t\t\t\treturn map\n     \t\t\t}\n     \t\t} else {\n     \t\t\ttoken -= 0x90;\n     \t\t\tlet array = new Array(token);\n     \t\t\tfor (let i = 0; i < token; i++) {\n     \t\t\t\tarray[i] = read();\n     \t\t\t}\n     \t\t\tif (currentUnpackr.freezeData)\n     \t\t\t\treturn Object.freeze(array)\n     \t\t\treturn array\n     \t\t}\n     \t} else if (token < 0xc0) {\n     \t\t// fixstr\n     \t\tlet length = token - 0xa0;\n     \t\tif (srcStringEnd >= position$1) {\n     \t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart)\n     \t\t}\n     \t\tif (srcStringEnd == 0 && srcEnd < 140) {\n     \t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n     \t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n     \t\t\tif (string != null)\n     \t\t\t\treturn string\n     \t\t}\n     \t\treturn readFixedString(length)\n     \t} else {\n     \t\tlet value;\n     \t\tswitch (token) {\n     \t\t\tcase 0xc0: return null\n     \t\t\tcase 0xc1:\n     \t\t\t\tif (bundledStrings$1) {\n     \t\t\t\t\tvalue = read(); // followed by the length of the string in characters (not bytes!)\n     \t\t\t\t\tif (value > 0)\n     \t\t\t\t\t\treturn bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value)\n     \t\t\t\t\telse\n     \t\t\t\t\t\treturn bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 -= value)\n     \t\t\t\t}\n     \t\t\t\treturn C1; // \"never-used\", return special object to denote that\n     \t\t\tcase 0xc2: return false\n     \t\t\tcase 0xc3: return true\n     \t\t\tcase 0xc4:\n     \t\t\t\t// bin 8\n     \t\t\t\tvalue = src[position$1++];\n     \t\t\t\tif (value === undefined)\n     \t\t\t\t\tthrow new Error('Unexpected end of buffer')\n     \t\t\t\treturn readBin(value)\n     \t\t\tcase 0xc5:\n     \t\t\t\t// bin 16\n     \t\t\t\tvalue = dataView.getUint16(position$1);\n     \t\t\t\tposition$1 += 2;\n     \t\t\t\treturn readBin(value)\n     \t\t\tcase 0xc6:\n     \t\t\t\t// bin 32\n     \t\t\t\tvalue = dataView.getUint32(position$1);\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\treturn readBin(value)\n     \t\t\tcase 0xc7:\n     \t\t\t\t// ext 8\n     \t\t\t\treturn readExt(src[position$1++])\n     \t\t\tcase 0xc8:\n     \t\t\t\t// ext 16\n     \t\t\t\tvalue = dataView.getUint16(position$1);\n     \t\t\t\tposition$1 += 2;\n     \t\t\t\treturn readExt(value)\n     \t\t\tcase 0xc9:\n     \t\t\t\t// ext 32\n     \t\t\t\tvalue = dataView.getUint32(position$1);\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\treturn readExt(value)\n     \t\t\tcase 0xca:\n     \t\t\t\tvalue = dataView.getFloat32(position$1);\n     \t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n     \t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n     \t\t\t\t\tlet multiplier = mult10[((src[position$1] & 0x7f) << 1) | (src[position$1 + 1] >> 7)];\n     \t\t\t\t\tposition$1 += 4;\n     \t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n     \t\t\t\t}\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\treturn value\n     \t\t\tcase 0xcb:\n     \t\t\t\tvalue = dataView.getFloat64(position$1);\n     \t\t\t\tposition$1 += 8;\n     \t\t\t\treturn value\n     \t\t\t// uint handlers\n     \t\t\tcase 0xcc:\n     \t\t\t\treturn src[position$1++]\n     \t\t\tcase 0xcd:\n     \t\t\t\tvalue = dataView.getUint16(position$1);\n     \t\t\t\tposition$1 += 2;\n     \t\t\t\treturn value\n     \t\t\tcase 0xce:\n     \t\t\t\tvalue = dataView.getUint32(position$1);\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\treturn value\n     \t\t\tcase 0xcf:\n     \t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n     \t\t\t\t\tvalue = dataView.getUint32(position$1) * 0x100000000;\n     \t\t\t\t\tvalue += dataView.getUint32(position$1 + 4);\n     \t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n     \t\t\t\t\tvalue = dataView.getBigUint64(position$1).toString();\n     \t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n     \t\t\t\t\tvalue = dataView.getBigUint64(position$1);\n     \t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value);\n     \t\t\t\t} else\n     \t\t\t\t\tvalue = dataView.getBigUint64(position$1);\n     \t\t\t\tposition$1 += 8;\n     \t\t\t\treturn value\n\n     \t\t\t// int handlers\n     \t\t\tcase 0xd0:\n     \t\t\t\treturn dataView.getInt8(position$1++)\n     \t\t\tcase 0xd1:\n     \t\t\t\tvalue = dataView.getInt16(position$1);\n     \t\t\t\tposition$1 += 2;\n     \t\t\t\treturn value\n     \t\t\tcase 0xd2:\n     \t\t\t\tvalue = dataView.getInt32(position$1);\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\treturn value\n     \t\t\tcase 0xd3:\n     \t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n     \t\t\t\t\tvalue = dataView.getInt32(position$1) * 0x100000000;\n     \t\t\t\t\tvalue += dataView.getUint32(position$1 + 4);\n     \t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n     \t\t\t\t\tvalue = dataView.getBigInt64(position$1).toString();\n     \t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n     \t\t\t\t\tvalue = dataView.getBigInt64(position$1);\n     \t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value);\n     \t\t\t\t} else\n     \t\t\t\t\tvalue = dataView.getBigInt64(position$1);\n     \t\t\t\tposition$1 += 8;\n     \t\t\t\treturn value\n\n     \t\t\tcase 0xd4:\n     \t\t\t\t// fixext 1\n     \t\t\t\tvalue = src[position$1++];\n     \t\t\t\tif (value == 0x72) {\n     \t\t\t\t\treturn recordDefinition(src[position$1++] & 0x3f)\n     \t\t\t\t} else {\n     \t\t\t\t\tlet extension = currentExtensions[value];\n     \t\t\t\t\tif (extension) {\n     \t\t\t\t\t\tif (extension.read) {\n     \t\t\t\t\t\t\tposition$1++; // skip filler byte\n     \t\t\t\t\t\t\treturn extension.read(read())\n     \t\t\t\t\t\t} else if (extension.noBuffer) {\n     \t\t\t\t\t\t\tposition$1++; // skip filler byte\n     \t\t\t\t\t\t\treturn extension()\n     \t\t\t\t\t\t} else\n     \t\t\t\t\t\t\treturn extension(src.subarray(position$1, ++position$1))\n     \t\t\t\t\t} else\n     \t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n     \t\t\t\t}\n     \t\t\tcase 0xd5:\n     \t\t\t\t// fixext 2\n     \t\t\t\tvalue = src[position$1];\n     \t\t\t\tif (value == 0x72) {\n     \t\t\t\t\tposition$1++;\n     \t\t\t\t\treturn recordDefinition(src[position$1++] & 0x3f, src[position$1++])\n     \t\t\t\t} else\n     \t\t\t\t\treturn readExt(2)\n     \t\t\tcase 0xd6:\n     \t\t\t\t// fixext 4\n     \t\t\t\treturn readExt(4)\n     \t\t\tcase 0xd7:\n     \t\t\t\t// fixext 8\n     \t\t\t\treturn readExt(8)\n     \t\t\tcase 0xd8:\n     \t\t\t\t// fixext 16\n     \t\t\t\treturn readExt(16)\n     \t\t\tcase 0xd9:\n     \t\t\t// str 8\n     \t\t\t\tvalue = src[position$1++];\n     \t\t\t\tif (srcStringEnd >= position$1) {\n     \t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n     \t\t\t\t}\n     \t\t\t\treturn readString8(value)\n     \t\t\tcase 0xda:\n     \t\t\t// str 16\n     \t\t\t\tvalue = dataView.getUint16(position$1);\n     \t\t\t\tposition$1 += 2;\n     \t\t\t\tif (srcStringEnd >= position$1) {\n     \t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n     \t\t\t\t}\n     \t\t\t\treturn readString16(value)\n     \t\t\tcase 0xdb:\n     \t\t\t// str 32\n     \t\t\t\tvalue = dataView.getUint32(position$1);\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\tif (srcStringEnd >= position$1) {\n     \t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n     \t\t\t\t}\n     \t\t\t\treturn readString32(value)\n     \t\t\tcase 0xdc:\n     \t\t\t// array 16\n     \t\t\t\tvalue = dataView.getUint16(position$1);\n     \t\t\t\tposition$1 += 2;\n     \t\t\t\treturn readArray(value)\n     \t\t\tcase 0xdd:\n     \t\t\t// array 32\n     \t\t\t\tvalue = dataView.getUint32(position$1);\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\treturn readArray(value)\n     \t\t\tcase 0xde:\n     \t\t\t// map 16\n     \t\t\t\tvalue = dataView.getUint16(position$1);\n     \t\t\t\tposition$1 += 2;\n     \t\t\t\treturn readMap(value)\n     \t\t\tcase 0xdf:\n     \t\t\t// map 32\n     \t\t\t\tvalue = dataView.getUint32(position$1);\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\treturn readMap(value)\n     \t\t\tdefault: // negative int\n     \t\t\t\tif (token >= 0xe0)\n     \t\t\t\t\treturn token - 0x100\n     \t\t\t\tif (token === undefined) {\n     \t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data');\n     \t\t\t\t\terror.incomplete = true;\n     \t\t\t\t\tthrow error\n     \t\t\t\t}\n     \t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n     \t\t}\n     \t}\n     }\n     const validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\n     function createStructureReader(structure, firstId) {\n     \tfunction readObject() {\n     \t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n     \t\tif (readObject.count++ > inlineObjectReadThreshold) {\n     \t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n     \t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read);\n     \t\t\tif (structure.highByte === 0)\n     \t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read);\n     \t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n     \t\t}\n     \t\tlet object = {};\n     \t\tfor (let i = 0, l = structure.length; i < l; i++) {\n     \t\t\tlet key = structure[i];\n     \t\t\tif (key === '__proto__')\n     \t\t\t\tkey = '__proto_';\n     \t\t\tobject[key] = read();\n     \t\t}\n     \t\tif (currentUnpackr.freezeData)\n     \t\t\treturn Object.freeze(object);\n     \t\treturn object\n     \t}\n     \treadObject.count = 0;\n     \tif (structure.highByte === 0) {\n     \t\treturn createSecondByteReader(firstId, readObject)\n     \t}\n     \treturn readObject\n     }\n\n     const createSecondByteReader = (firstId, read0) => {\n     \treturn function() {\n     \t\tlet highByte = src[position$1++];\n     \t\tif (highByte === 0)\n     \t\t\treturn read0()\n     \t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);\n     \t\tlet structure = currentStructures[id] || loadStructures()[id];\n     \t\tif (!structure) {\n     \t\t\tthrow new Error('Record id is not defined for ' + id)\n     \t\t}\n     \t\tif (!structure.read)\n     \t\t\tstructure.read = createStructureReader(structure, firstId);\n     \t\treturn structure.read()\n     \t}\n     };\n\n     function loadStructures() {\n     \tlet loadedStructures = saveState(() => {\n     \t\t// save the state in case getStructures modifies our buffer\n     \t\tsrc = null;\n     \t\treturn currentUnpackr.getStructures()\n     \t});\n     \treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n     }\n\n     var readFixedString = readStringJS;\n     var readString8 = readStringJS;\n     var readString16 = readStringJS;\n     var readString32 = readStringJS;\n     function readStringJS(length) {\n     \tlet result;\n     \tif (length < 16) {\n     \t\tif (result = shortStringInJS(length))\n     \t\t\treturn result\n     \t}\n     \tif (length > 64 && decoder)\n     \t\treturn decoder.decode(src.subarray(position$1, position$1 += length))\n     \tconst end = position$1 + length;\n     \tconst units = [];\n     \tresult = '';\n     \twhile (position$1 < end) {\n     \t\tconst byte1 = src[position$1++];\n     \t\tif ((byte1 & 0x80) === 0) {\n     \t\t\t// 1 byte\n     \t\t\tunits.push(byte1);\n     \t\t} else if ((byte1 & 0xe0) === 0xc0) {\n     \t\t\t// 2 bytes\n     \t\t\tconst byte2 = src[position$1++] & 0x3f;\n     \t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2);\n     \t\t} else if ((byte1 & 0xf0) === 0xe0) {\n     \t\t\t// 3 bytes\n     \t\t\tconst byte2 = src[position$1++] & 0x3f;\n     \t\t\tconst byte3 = src[position$1++] & 0x3f;\n     \t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n     \t\t} else if ((byte1 & 0xf8) === 0xf0) {\n     \t\t\t// 4 bytes\n     \t\t\tconst byte2 = src[position$1++] & 0x3f;\n     \t\t\tconst byte3 = src[position$1++] & 0x3f;\n     \t\t\tconst byte4 = src[position$1++] & 0x3f;\n     \t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n     \t\t\tif (unit > 0xffff) {\n     \t\t\t\tunit -= 0x10000;\n     \t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800);\n     \t\t\t\tunit = 0xdc00 | (unit & 0x3ff);\n     \t\t\t}\n     \t\t\tunits.push(unit);\n     \t\t} else {\n     \t\t\tunits.push(byte1);\n     \t\t}\n\n     \t\tif (units.length >= 0x1000) {\n     \t\t\tresult += fromCharCode.apply(String, units);\n     \t\t\tunits.length = 0;\n     \t\t}\n     \t}\n\n     \tif (units.length > 0) {\n     \t\tresult += fromCharCode.apply(String, units);\n     \t}\n\n     \treturn result\n     }\n\n     function readArray(length) {\n     \tlet array = new Array(length);\n     \tfor (let i = 0; i < length; i++) {\n     \t\tarray[i] = read();\n     \t}\n     \tif (currentUnpackr.freezeData)\n     \t\treturn Object.freeze(array)\n     \treturn array\n     }\n\n     function readMap(length) {\n     \tif (currentUnpackr.mapsAsObjects) {\n     \t\tlet object = {};\n     \t\tfor (let i = 0; i < length; i++) {\n     \t\t\tlet key = readKey();\n     \t\t\tif (key === '__proto__')\n     \t\t\t\tkey = '__proto_';\n     \t\t\tobject[key] = read();\n     \t\t}\n     \t\treturn object\n     \t} else {\n     \t\tlet map = new Map();\n     \t\tfor (let i = 0; i < length; i++) {\n     \t\t\tmap.set(read(), read());\n     \t\t}\n     \t\treturn map\n     \t}\n     }\n\n     var fromCharCode = String.fromCharCode;\n     function longStringInJS(length) {\n     \tlet start = position$1;\n     \tlet bytes = new Array(length);\n     \tfor (let i = 0; i < length; i++) {\n     \t\tconst byte = src[position$1++];\n     \t\tif ((byte & 0x80) > 0) {\n     \t\t\t\tposition$1 = start;\n     \t\t\t\treturn\n     \t\t\t}\n     \t\t\tbytes[i] = byte;\n     \t\t}\n     \t\treturn fromCharCode.apply(String, bytes)\n     }\n     function shortStringInJS(length) {\n     \tif (length < 4) {\n     \t\tif (length < 2) {\n     \t\t\tif (length === 0)\n     \t\t\t\treturn ''\n     \t\t\telse {\n     \t\t\t\tlet a = src[position$1++];\n     \t\t\t\tif ((a & 0x80) > 1) {\n     \t\t\t\t\tposition$1 -= 1;\n     \t\t\t\t\treturn\n     \t\t\t\t}\n     \t\t\t\treturn fromCharCode(a)\n     \t\t\t}\n     \t\t} else {\n     \t\t\tlet a = src[position$1++];\n     \t\t\tlet b = src[position$1++];\n     \t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n     \t\t\t\tposition$1 -= 2;\n     \t\t\t\treturn\n     \t\t\t}\n     \t\t\tif (length < 3)\n     \t\t\t\treturn fromCharCode(a, b)\n     \t\t\tlet c = src[position$1++];\n     \t\t\tif ((c & 0x80) > 0) {\n     \t\t\t\tposition$1 -= 3;\n     \t\t\t\treturn\n     \t\t\t}\n     \t\t\treturn fromCharCode(a, b, c)\n     \t\t}\n     \t} else {\n     \t\tlet a = src[position$1++];\n     \t\tlet b = src[position$1++];\n     \t\tlet c = src[position$1++];\n     \t\tlet d = src[position$1++];\n     \t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n     \t\t\tposition$1 -= 4;\n     \t\t\treturn\n     \t\t}\n     \t\tif (length < 6) {\n     \t\t\tif (length === 4)\n     \t\t\t\treturn fromCharCode(a, b, c, d)\n     \t\t\telse {\n     \t\t\t\tlet e = src[position$1++];\n     \t\t\t\tif ((e & 0x80) > 0) {\n     \t\t\t\t\tposition$1 -= 5;\n     \t\t\t\t\treturn\n     \t\t\t\t}\n     \t\t\t\treturn fromCharCode(a, b, c, d, e)\n     \t\t\t}\n     \t\t} else if (length < 8) {\n     \t\t\tlet e = src[position$1++];\n     \t\t\tlet f = src[position$1++];\n     \t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n     \t\t\t\tposition$1 -= 6;\n     \t\t\t\treturn\n     \t\t\t}\n     \t\t\tif (length < 7)\n     \t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n     \t\t\tlet g = src[position$1++];\n     \t\t\tif ((g & 0x80) > 0) {\n     \t\t\t\tposition$1 -= 7;\n     \t\t\t\treturn\n     \t\t\t}\n     \t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n     \t\t} else {\n     \t\t\tlet e = src[position$1++];\n     \t\t\tlet f = src[position$1++];\n     \t\t\tlet g = src[position$1++];\n     \t\t\tlet h = src[position$1++];\n     \t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n     \t\t\t\tposition$1 -= 8;\n     \t\t\t\treturn\n     \t\t\t}\n     \t\t\tif (length < 10) {\n     \t\t\t\tif (length === 8)\n     \t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n     \t\t\t\telse {\n     \t\t\t\t\tlet i = src[position$1++];\n     \t\t\t\t\tif ((i & 0x80) > 0) {\n     \t\t\t\t\t\tposition$1 -= 9;\n     \t\t\t\t\t\treturn\n     \t\t\t\t\t}\n     \t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n     \t\t\t\t}\n     \t\t\t} else if (length < 12) {\n     \t\t\t\tlet i = src[position$1++];\n     \t\t\t\tlet j = src[position$1++];\n     \t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n     \t\t\t\t\tposition$1 -= 10;\n     \t\t\t\t\treturn\n     \t\t\t\t}\n     \t\t\t\tif (length < 11)\n     \t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n     \t\t\t\tlet k = src[position$1++];\n     \t\t\t\tif ((k & 0x80) > 0) {\n     \t\t\t\t\tposition$1 -= 11;\n     \t\t\t\t\treturn\n     \t\t\t\t}\n     \t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n     \t\t\t} else {\n     \t\t\t\tlet i = src[position$1++];\n     \t\t\t\tlet j = src[position$1++];\n     \t\t\t\tlet k = src[position$1++];\n     \t\t\t\tlet l = src[position$1++];\n     \t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n     \t\t\t\t\tposition$1 -= 12;\n     \t\t\t\t\treturn\n     \t\t\t\t}\n     \t\t\t\tif (length < 14) {\n     \t\t\t\t\tif (length === 12)\n     \t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n     \t\t\t\t\telse {\n     \t\t\t\t\t\tlet m = src[position$1++];\n     \t\t\t\t\t\tif ((m & 0x80) > 0) {\n     \t\t\t\t\t\t\tposition$1 -= 13;\n     \t\t\t\t\t\t\treturn\n     \t\t\t\t\t\t}\n     \t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n     \t\t\t\t\t}\n     \t\t\t\t} else {\n     \t\t\t\t\tlet m = src[position$1++];\n     \t\t\t\t\tlet n = src[position$1++];\n     \t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n     \t\t\t\t\t\tposition$1 -= 14;\n     \t\t\t\t\t\treturn\n     \t\t\t\t\t}\n     \t\t\t\t\tif (length < 15)\n     \t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n     \t\t\t\t\tlet o = src[position$1++];\n     \t\t\t\t\tif ((o & 0x80) > 0) {\n     \t\t\t\t\t\tposition$1 -= 15;\n     \t\t\t\t\t\treturn\n     \t\t\t\t\t}\n     \t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n     \t\t\t\t}\n     \t\t\t}\n     \t\t}\n     \t}\n     }\n\n     function readOnlyJSString() {\n     \tlet token = src[position$1++];\n     \tlet length;\n     \tif (token < 0xc0) {\n     \t\t// fixstr\n     \t\tlength = token - 0xa0;\n     \t} else {\n     \t\tswitch(token) {\n     \t\t\tcase 0xd9:\n     \t\t\t// str 8\n     \t\t\t\tlength = src[position$1++];\n     \t\t\t\tbreak\n     \t\t\tcase 0xda:\n     \t\t\t// str 16\n     \t\t\t\tlength = dataView.getUint16(position$1);\n     \t\t\t\tposition$1 += 2;\n     \t\t\t\tbreak\n     \t\t\tcase 0xdb:\n     \t\t\t// str 32\n     \t\t\t\tlength = dataView.getUint32(position$1);\n     \t\t\t\tposition$1 += 4;\n     \t\t\t\tbreak\n     \t\t\tdefault:\n     \t\t\t\tthrow new Error('Expected string')\n     \t\t}\n     \t}\n     \treturn readStringJS(length)\n     }\n\n\n     function readBin(length) {\n     \treturn currentUnpackr.copyBuffers ?\n     \t\t// specifically use the copying slice (not the node one)\n     \t\tUint8Array.prototype.slice.call(src, position$1, position$1 += length) :\n     \t\tsrc.subarray(position$1, position$1 += length)\n     }\n     function readExt(length) {\n     \tlet type = src[position$1++];\n     \tif (currentExtensions[type]) {\n     \t\tlet end;\n     \t\treturn currentExtensions[type](src.subarray(position$1, end = (position$1 += length)), (readPosition) => {\n     \t\t\tposition$1 = readPosition;\n     \t\t\ttry {\n     \t\t\t\treturn read();\n     \t\t\t} finally {\n     \t\t\t\tposition$1 = end;\n     \t\t\t}\n     \t\t})\n     \t}\n     \telse\n     \t\tthrow new Error('Unknown extension type ' + type)\n     }\n\n     var keyCache = new Array(4096);\n     function readKey() {\n     \tlet length = src[position$1++];\n     \tif (length >= 0xa0 && length < 0xc0) {\n     \t\t// fixstr, potentially use key cache\n     \t\tlength = length - 0xa0;\n     \t\tif (srcStringEnd >= position$1) // if it has been extracted, must use it (and faster anyway)\n     \t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart)\n     \t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n     \t\t\treturn readFixedString(length)\n     \t} else { // not cacheable, go back and do a standard read\n     \t\tposition$1--;\n     \t\treturn asSafeString(read())\n     \t}\n     \tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position$1) : length > 0 ? src[position$1] : 0)) & 0xfff;\n     \tlet entry = keyCache[key];\n     \tlet checkPosition = position$1;\n     \tlet end = position$1 + length - 3;\n     \tlet chunk;\n     \tlet i = 0;\n     \tif (entry && entry.bytes == length) {\n     \t\twhile (checkPosition < end) {\n     \t\t\tchunk = dataView.getUint32(checkPosition);\n     \t\t\tif (chunk != entry[i++]) {\n     \t\t\t\tcheckPosition = 0x70000000;\n     \t\t\t\tbreak\n     \t\t\t}\n     \t\t\tcheckPosition += 4;\n     \t\t}\n     \t\tend += 3;\n     \t\twhile (checkPosition < end) {\n     \t\t\tchunk = src[checkPosition++];\n     \t\t\tif (chunk != entry[i++]) {\n     \t\t\t\tcheckPosition = 0x70000000;\n     \t\t\t\tbreak\n     \t\t\t}\n     \t\t}\n     \t\tif (checkPosition === end) {\n     \t\t\tposition$1 = checkPosition;\n     \t\t\treturn entry.string\n     \t\t}\n     \t\tend -= 3;\n     \t\tcheckPosition = position$1;\n     \t}\n     \tentry = [];\n     \tkeyCache[key] = entry;\n     \tentry.bytes = length;\n     \twhile (checkPosition < end) {\n     \t\tchunk = dataView.getUint32(checkPosition);\n     \t\tentry.push(chunk);\n     \t\tcheckPosition += 4;\n     \t}\n     \tend += 3;\n     \twhile (checkPosition < end) {\n     \t\tchunk = src[checkPosition++];\n     \t\tentry.push(chunk);\n     \t}\n     \t// for small blocks, avoiding the overhead of the extract call is helpful\n     \tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n     \tif (string != null)\n     \t\treturn entry.string = string\n     \treturn entry.string = readFixedString(length)\n     }\n\n     function asSafeString(property) {\n     \t// protect against expensive (DoS) string conversions\n     \tif (typeof property === 'string') return property;\n     \tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n     \tif (property == null) return property + '';\n     \tif (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {\n     \t\treturn property.flat().toString();\n     \t}\n     \tthrow new Error(`Invalid property type for record: ${typeof property}`);\n     }\n     // the registration of the record definition extension (as \"r\")\n     const recordDefinition = (id, highByte) => {\n     \tlet structure = read().map(asSafeString); // ensure that all keys are strings and\n     \t// that the array is mutable\n     \tlet firstByte = id;\n     \tif (highByte !== undefined) {\n     \t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id);\n     \t\tstructure.highByte = highByte;\n     \t}\n     \tlet existingStructure = currentStructures[id];\n     \t// If it is a shared structure, we need to restore any changes after reading.\n     \t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n     \t// to the state prior to an incomplete read in order to properly resume.\n     \tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n     \t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n     \t}\n     \tcurrentStructures[id] = structure;\n     \tstructure.read = createStructureReader(structure, firstByte);\n     \treturn structure.read()\n     };\n     currentExtensions[0] = () => {}; // notepack defines extension 0 to mean undefined, so use that as the default here\n     currentExtensions[0].noBuffer = true;\n\n     currentExtensions[0x42] = (data) => {\n     \t// decode bigint\n     \tlet length = data.length;\n     \tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n     \tfor (let i = 1; i < length; i++) {\n     \t\tvalue <<= BigInt(8);\n     \t\tvalue += BigInt(data[i]);\n     \t}\n     \treturn value;\n     };\n\n     let errors = { Error, TypeError, ReferenceError };\n     currentExtensions[0x65] = () => {\n     \tlet data = read();\n     \treturn (errors[data[0]] || Error)(data[1], { cause: data[2] })\n     };\n\n     currentExtensions[0x69] = (data) => {\n     \t// id extension (for structured clones)\n     \tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n     \tlet id = dataView.getUint32(position$1 - 4);\n     \tif (!referenceMap)\n     \t\treferenceMap = new Map();\n     \tlet token = src[position$1];\n     \tlet target;\n     \t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n     \t// ahead past references to record structure definitions\n     \tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n     \t\ttarget = [];\n     \telse\n     \t\ttarget = {};\n\n     \tlet refEntry = { target }; // a placeholder object\n     \treferenceMap.set(id, refEntry);\n     \tlet targetProperties = read(); // read the next value as the target object to id\n     \tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n     \t\treturn Object.assign(target, targetProperties)\n     \trefEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n     \treturn targetProperties // no cycle, can just use the returned read object\n     };\n\n     currentExtensions[0x70] = (data) => {\n     \t// pointer extension (for structured clones)\n     \tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n     \tlet id = dataView.getUint32(position$1 - 4);\n     \tlet refEntry = referenceMap.get(id);\n     \trefEntry.used = true;\n     \treturn refEntry.target\n     };\n\n     currentExtensions[0x73] = () => new Set(read());\n\n     const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array');\n\n     let glbl = typeof globalThis === 'object' ? globalThis : window;\n     currentExtensions[0x74] = (data) => {\n     \tlet typeCode = data[0];\n     \tlet typedArrayName = typedArrays[typeCode];\n     \tif (!typedArrayName) {\n     \t\tif (typeCode === 16) {\n     \t\t\tlet ab = new ArrayBuffer(data.length - 1);\n     \t\t\tlet u8 = new Uint8Array(ab);\n     \t\t\tu8.set(data.subarray(1));\n     \t\t\treturn ab;\n     \t\t}\n     \t\tthrow new Error('Could not find typed array for code ' + typeCode)\n     \t}\n     \t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n     \treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n     };\n     currentExtensions[0x78] = () => {\n     \tlet data = read();\n     \treturn new RegExp(data[0], data[1])\n     };\n     const TEMP_BUNDLE = [];\n     currentExtensions[0x62] = (data) => {\n     \tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];\n     \tlet dataPosition = position$1;\n     \tposition$1 += dataSize - data.length;\n     \tbundledStrings$1 = TEMP_BUNDLE;\n     \tbundledStrings$1 = [readOnlyJSString(), readOnlyJSString()];\n     \tbundledStrings$1.position0 = 0;\n     \tbundledStrings$1.position1 = 0;\n     \tbundledStrings$1.postBundlePosition = position$1;\n     \tposition$1 = dataPosition;\n     \treturn read()\n     };\n\n     currentExtensions[0xff] = (data) => {\n     \t// 32-bit date extension\n     \tif (data.length == 4)\n     \t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n     \telse if (data.length == 8)\n     \t\treturn new Date(\n     \t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n     \t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n     \telse if (data.length == 12)// TODO: Implement support for negative\n     \t\treturn new Date(\n     \t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n     \t\t\t(((data[4] & 0x80) ? -281474976710656 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n     \telse\n     \t\treturn new Date('invalid')\n     }; // notepack defines extension 0 to mean undefined, so use that as the default here\n     // registration of bulk record definition?\n     // currentExtensions[0x52] = () =>\n\n     function saveState(callback) {\n     \tlet savedSrcEnd = srcEnd;\n     \tlet savedPosition = position$1;\n     \tlet savedSrcStringStart = srcStringStart;\n     \tlet savedSrcStringEnd = srcStringEnd;\n     \tlet savedSrcString = srcString;\n     \tlet savedReferenceMap = referenceMap;\n     \tlet savedBundledStrings = bundledStrings$1;\n\n     \t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n     \tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n     \tlet savedStructures = currentStructures;\n     \tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length);\n     \tlet savedPackr = currentUnpackr;\n     \tlet savedSequentialMode = sequentialMode;\n     \tlet value = callback();\n     \tsrcEnd = savedSrcEnd;\n     \tposition$1 = savedPosition;\n     \tsrcStringStart = savedSrcStringStart;\n     \tsrcStringEnd = savedSrcStringEnd;\n     \tsrcString = savedSrcString;\n     \treferenceMap = savedReferenceMap;\n     \tbundledStrings$1 = savedBundledStrings;\n     \tsrc = savedSrc;\n     \tsequentialMode = savedSequentialMode;\n     \tcurrentStructures = savedStructures;\n     \tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents);\n     \tcurrentUnpackr = savedPackr;\n     \tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n     \treturn value\n     }\n     function clearSource() {\n     \tsrc = null;\n     \treferenceMap = null;\n     \tcurrentStructures = null;\n     }\n\n     const mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\n     for (let i = 0; i < 256; i++) {\n     \tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103));\n     }\n     var defaultUnpackr = new Unpackr({ useRecords: false });\n     const unpack = defaultUnpackr.unpack;\n     defaultUnpackr.unpackMultiple;\n     defaultUnpackr.unpack;\n     let f32Array = new Float32Array(1);\n     new Uint8Array(f32Array.buffer, 0, 4);\n\n     let textEncoder;\n     try {\n     \ttextEncoder = new TextEncoder();\n     } catch (error) {}\n     let extensions, extensionClasses;\n     const hasNodeBuffer = typeof Buffer !== 'undefined';\n     const ByteArrayAllocate = hasNodeBuffer ?\n     \tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array;\n     const ByteArray = hasNodeBuffer ? Buffer : Uint8Array;\n     const MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000;\n     let target, keysTarget;\n     let targetView;\n     let position = 0;\n     let safeEnd;\n     let bundledStrings = null;\n     let writeStructSlots;\n     const MAX_BUNDLE_SIZE = 0x5500; // maximum characters such that the encoded bytes fits in 16 bits.\n     const hasNonLatin = /[\\u0080-\\uFFFF]/;\n     const RECORD_SYMBOL = Symbol('record-id');\n     class Packr extends Unpackr {\n     \tconstructor(options) {\n     \t\tsuper(options);\n     \t\tthis.offset = 0;\n     \t\tlet start;\n     \t\tlet hasSharedUpdate;\n     \t\tlet structures;\n     \t\tlet referenceMap;\n     \t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n     \t\t\treturn target.utf8Write(string, position, target.byteLength - position)\n     \t\t} : (textEncoder && textEncoder.encodeInto) ?\n     \t\t\tfunction(string, position) {\n     \t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n     \t\t\t} : false;\n\n     \t\tlet packr = this;\n     \t\tif (!options)\n     \t\t\toptions = {};\n     \t\tlet isSequential = options && options.sequential;\n     \t\tlet hasSharedStructures = options.structures || options.saveStructures;\n     \t\tlet maxSharedStructures = options.maxSharedStructures;\n     \t\tif (maxSharedStructures == null)\n     \t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0;\n     \t\tif (maxSharedStructures > 8160)\n     \t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n     \t\tif (options.structuredClone && options.moreTypes == undefined) {\n     \t\t\tthis.moreTypes = true;\n     \t\t}\n     \t\tlet maxOwnStructures = options.maxOwnStructures;\n     \t\tif (maxOwnStructures == null)\n     \t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64;\n     \t\tif (!this.structures && options.useRecords != false)\n     \t\t\tthis.structures = [];\n     \t\t// two byte record ids for shared structures\n     \t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64);\n     \t\tlet sharedLimitId = maxSharedStructures + 0x40;\n     \t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40;\n     \t\tif (maxStructureId > 8256) {\n     \t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n     \t\t}\n     \t\tlet recordIdsToRemove = [];\n     \t\tlet transitionsCount = 0;\n     \t\tlet serializationsSinceTransitionRebuild = 0;\n\n     \t\tthis.pack = this.encode = function(value, encodeOptions) {\n     \t\t\tif (!target) {\n     \t\t\t\ttarget = new ByteArrayAllocate(8192);\n     \t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));\n     \t\t\t\tposition = 0;\n     \t\t\t}\n     \t\t\tsafeEnd = target.length - 10;\n     \t\t\tif (safeEnd - position < 0x800) {\n     \t\t\t\t// don't start too close to the end,\n     \t\t\t\ttarget = new ByteArrayAllocate(target.length);\n     \t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));\n     \t\t\t\tsafeEnd = target.length - 10;\n     \t\t\t\tposition = 0;\n     \t\t\t} else\n     \t\t\t\tposition = (position + 7) & 0x7ffffff8; // Word align to make any future copying of this buffer faster\n     \t\t\tstart = position;\n     \t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff);\n     \t\t\treferenceMap = packr.structuredClone ? new Map() : null;\n     \t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n     \t\t\t\tbundledStrings = [];\n     \t\t\t\tbundledStrings.size = Infinity; // force a new bundle start on first string\n     \t\t\t} else\n     \t\t\t\tbundledStrings = null;\n     \t\t\tstructures = packr.structures;\n     \t\t\tif (structures) {\n     \t\t\t\tif (structures.uninitialized)\n     \t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures());\n     \t\t\t\tlet sharedLength = structures.sharedLength || 0;\n     \t\t\t\tif (sharedLength > maxSharedStructures) {\n     \t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n     \t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n     \t\t\t\t}\n     \t\t\t\tif (!structures.transitions) {\n     \t\t\t\t\t// rebuild our structure transitions\n     \t\t\t\t\tstructures.transitions = Object.create(null);\n     \t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n     \t\t\t\t\t\tlet keys = structures[i];\n     \t\t\t\t\t\tif (!keys)\n     \t\t\t\t\t\t\tcontinue\n     \t\t\t\t\t\tlet nextTransition, transition = structures.transitions;\n     \t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n     \t\t\t\t\t\t\tlet key = keys[j];\n     \t\t\t\t\t\t\tnextTransition = transition[key];\n     \t\t\t\t\t\t\tif (!nextTransition) {\n     \t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n     \t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\ttransition = nextTransition;\n     \t\t\t\t\t\t}\n     \t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40;\n     \t\t\t\t\t}\n     \t\t\t\t\tthis.lastNamedStructuresLength = sharedLength;\n     \t\t\t\t}\n     \t\t\t\tif (!isSequential) {\n     \t\t\t\t\tstructures.nextId = sharedLength + 0x40;\n     \t\t\t\t}\n     \t\t\t}\n     \t\t\tif (hasSharedUpdate)\n     \t\t\t\thasSharedUpdate = false;\n     \t\t\tlet encodingError;\n     \t\t\ttry {\n     \t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n     \t\t\t\t\twriteStruct(value);\n     \t\t\t\telse\n     \t\t\t\t\tpack(value);\n     \t\t\t\tlet lastBundle = bundledStrings;\n     \t\t\t\tif (bundledStrings)\n     \t\t\t\t\twriteBundles(start, pack, 0);\n     \t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n     \t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n     \t\t\t\t\tlet i = idsToInsert.length;\n     \t\t\t\t\tlet incrementPosition = -1;\n     \t\t\t\t\twhile (lastBundle && i > 0) {\n     \t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n     \t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n     \t\t\t\t\t\t\tincrementPosition = 0;\n     \t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n     \t\t\t\t\t\t\tif (incrementPosition >= 0)\n     \t\t\t\t\t\t\t\tincrementPosition += 6;\n     \t\t\t\t\t\t} else {\n     \t\t\t\t\t\t\tif (incrementPosition >= 0) {\n     \t\t\t\t\t\t\t\t// update the bundle reference now\n     \t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n     \t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition);\n     \t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n     \t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n     \t\t\t\t\t\t\ti++;\n     \t\t\t\t\t\t}\n     \t\t\t\t\t}\n     \t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n     \t\t\t\t\t\t// update the bundle reference now\n     \t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n     \t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition);\n     \t\t\t\t\t}\n     \t\t\t\t\tposition += idsToInsert.length * 6;\n     \t\t\t\t\tif (position > safeEnd)\n     \t\t\t\t\t\tmakeRoom(position);\n     \t\t\t\t\tpackr.offset = position;\n     \t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert);\n     \t\t\t\t\treferenceMap = null;\n     \t\t\t\t\treturn serialized\n     \t\t\t\t}\n     \t\t\t\tpackr.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n     \t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n     \t\t\t\t\ttarget.start = start;\n     \t\t\t\t\ttarget.end = position;\n     \t\t\t\t\treturn target\n     \t\t\t\t}\n     \t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n     \t\t\t} catch(error) {\n     \t\t\t\tencodingError = error;\n     \t\t\t\tthrow error;\n     \t\t\t} finally {\n     \t\t\t\tif (structures) {\n     \t\t\t\t\tresetStructures();\n     \t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n     \t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0;\n     \t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n     \t\t\t\t\t\tlet returnBuffer = target.subarray(start, position);\n     \t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n     \t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n     \t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n     \t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n     \t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n     \t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength;\n     \t\t\t\t\t\t\t// don't keep large buffers around\n     \t\t\t\t\t\t\tif (target.length > 0x40000000) target = null;\n     \t\t\t\t\t\t\treturn returnBuffer\n     \t\t\t\t\t\t}\n     \t\t\t\t\t}\n     \t\t\t\t}\n     \t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n     \t\t\t\tif (target.length > 0x40000000) target = null;\n     \t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n     \t\t\t\t\tposition = start;\n     \t\t\t}\n     \t\t};\n     \t\tconst resetStructures = () => {\n     \t\t\tif (serializationsSinceTransitionRebuild < 10)\n     \t\t\t\tserializationsSinceTransitionRebuild++;\n     \t\t\tlet sharedLength = structures.sharedLength || 0;\n     \t\t\tif (structures.length > sharedLength && !isSequential)\n     \t\t\t\tstructures.length = sharedLength;\n     \t\t\tif (transitionsCount > 10000) {\n     \t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n     \t\t\t\tstructures.transitions = null;\n     \t\t\t\tserializationsSinceTransitionRebuild = 0;\n     \t\t\t\ttransitionsCount = 0;\n     \t\t\t\tif (recordIdsToRemove.length > 0)\n     \t\t\t\t\trecordIdsToRemove = [];\n     \t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n     \t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n     \t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0;\n     \t\t\t\t}\n     \t\t\t\trecordIdsToRemove = [];\n     \t\t\t}\n     \t\t};\n     \t\tconst packArray = (value) => {\n     \t\t\tvar length = value.length;\n     \t\t\tif (length < 0x10) {\n     \t\t\t\ttarget[position++] = 0x90 | length;\n     \t\t\t} else if (length < 0x10000) {\n     \t\t\t\ttarget[position++] = 0xdc;\n     \t\t\t\ttarget[position++] = length >> 8;\n     \t\t\t\ttarget[position++] = length & 0xff;\n     \t\t\t} else {\n     \t\t\t\ttarget[position++] = 0xdd;\n     \t\t\t\ttargetView.setUint32(position, length);\n     \t\t\t\tposition += 4;\n     \t\t\t}\n     \t\t\tfor (let i = 0; i < length; i++) {\n     \t\t\t\tpack(value[i]);\n     \t\t\t}\n     \t\t};\n     \t\tconst pack = (value) => {\n     \t\t\tif (position > safeEnd)\n     \t\t\t\ttarget = makeRoom(position);\n\n     \t\t\tvar type = typeof value;\n     \t\t\tvar length;\n     \t\t\tif (type === 'string') {\n     \t\t\t\tlet strLength = value.length;\n     \t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n     \t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n     \t\t\t\t\t\tlet extStart;\n     \t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;\n     \t\t\t\t\t\tif (position + maxBytes > safeEnd)\n     \t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes);\n     \t\t\t\t\t\tlet lastBundle;\n     \t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n     \t\t\t\t\t\t\tlastBundle = bundledStrings;\n     \t\t\t\t\t\t\ttarget[position] = 0xc8; // ext 16\n     \t\t\t\t\t\t\tposition += 3; // reserve for the writing bundle size\n     \t\t\t\t\t\t\ttarget[position++] = 0x62; // 'b'\n     \t\t\t\t\t\t\textStart = position - start;\n     \t\t\t\t\t\t\tposition += 4; // reserve for writing bundle reference\n     \t\t\t\t\t\t\twriteBundles(start, pack, 0); // write the last bundles\n     \t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart);\n     \t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n     \t\t\t\t\t\t\ttarget[position++] = 0xd6; // fixext 4\n     \t\t\t\t\t\t\ttarget[position++] = 0x62; // 'b'\n     \t\t\t\t\t\t\textStart = position - start;\n     \t\t\t\t\t\t\tposition += 4; // reserve for writing bundle reference\n     \t\t\t\t\t\t}\n     \t\t\t\t\t\tbundledStrings = ['', '']; // create new ones\n     \t\t\t\t\t\tbundledStrings.previous = lastBundle;\n     \t\t\t\t\t\tbundledStrings.size = 0;\n     \t\t\t\t\t\tbundledStrings.position = extStart;\n     \t\t\t\t\t}\n     \t\t\t\t\tlet twoByte = hasNonLatin.test(value);\n     \t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value;\n     \t\t\t\t\ttarget[position++] = 0xc1;\n     \t\t\t\t\tpack(twoByte ? -strLength : strLength);\n     \t\t\t\t\treturn\n     \t\t\t\t}\n     \t\t\t\tlet headerSize;\n     \t\t\t\t// first we estimate the header size, so we can write to the correct location\n     \t\t\t\tif (strLength < 0x20) {\n     \t\t\t\t\theaderSize = 1;\n     \t\t\t\t} else if (strLength < 0x100) {\n     \t\t\t\t\theaderSize = 2;\n     \t\t\t\t} else if (strLength < 0x10000) {\n     \t\t\t\t\theaderSize = 3;\n     \t\t\t\t} else {\n     \t\t\t\t\theaderSize = 5;\n     \t\t\t\t}\n     \t\t\t\tlet maxBytes = strLength * 3;\n     \t\t\t\tif (position + maxBytes > safeEnd)\n     \t\t\t\t\ttarget = makeRoom(position + maxBytes);\n\n     \t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n     \t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize;\n     \t\t\t\t\tfor (i = 0; i < strLength; i++) {\n     \t\t\t\t\t\tc1 = value.charCodeAt(i);\n     \t\t\t\t\t\tif (c1 < 0x80) {\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1;\n     \t\t\t\t\t\t} else if (c1 < 0x800) {\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0;\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n     \t\t\t\t\t\t} else if (\n     \t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n     \t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n     \t\t\t\t\t\t) {\n     \t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n     \t\t\t\t\t\t\ti++;\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0;\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80;\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n     \t\t\t\t\t\t} else {\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0;\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n     \t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n     \t\t\t\t\t\t}\n     \t\t\t\t\t}\n     \t\t\t\t\tlength = strPosition - position - headerSize;\n     \t\t\t\t} else {\n     \t\t\t\t\tlength = encodeUtf8(value, position + headerSize);\n     \t\t\t\t}\n\n     \t\t\t\tif (length < 0x20) {\n     \t\t\t\t\ttarget[position++] = 0xa0 | length;\n     \t\t\t\t} else if (length < 0x100) {\n     \t\t\t\t\tif (headerSize < 2) {\n     \t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length);\n     \t\t\t\t\t}\n     \t\t\t\t\ttarget[position++] = 0xd9;\n     \t\t\t\t\ttarget[position++] = length;\n     \t\t\t\t} else if (length < 0x10000) {\n     \t\t\t\t\tif (headerSize < 3) {\n     \t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length);\n     \t\t\t\t\t}\n     \t\t\t\t\ttarget[position++] = 0xda;\n     \t\t\t\t\ttarget[position++] = length >> 8;\n     \t\t\t\t\ttarget[position++] = length & 0xff;\n     \t\t\t\t} else {\n     \t\t\t\t\tif (headerSize < 5) {\n     \t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length);\n     \t\t\t\t\t}\n     \t\t\t\t\ttarget[position++] = 0xdb;\n     \t\t\t\t\ttargetView.setUint32(position, length);\n     \t\t\t\t\tposition += 4;\n     \t\t\t\t}\n     \t\t\t\tposition += length;\n     \t\t\t} else if (type === 'number') {\n     \t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n     \t\t\t\t\t// positive uint\n     \t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n     \t\t\t\t\t\ttarget[position++] = value;\n     \t\t\t\t\t} else if (value < 0x100) {\n     \t\t\t\t\t\ttarget[position++] = 0xcc;\n     \t\t\t\t\t\ttarget[position++] = value;\n     \t\t\t\t\t} else if (value < 0x10000) {\n     \t\t\t\t\t\ttarget[position++] = 0xcd;\n     \t\t\t\t\t\ttarget[position++] = value >> 8;\n     \t\t\t\t\t\ttarget[position++] = value & 0xff;\n     \t\t\t\t\t} else {\n     \t\t\t\t\t\ttarget[position++] = 0xce;\n     \t\t\t\t\t\ttargetView.setUint32(position, value);\n     \t\t\t\t\t\tposition += 4;\n     \t\t\t\t\t}\n     \t\t\t\t} else if (value >> 0 === value) { // negative integer\n     \t\t\t\t\tif (value >= -32) {\n     \t\t\t\t\t\ttarget[position++] = 0x100 + value;\n     \t\t\t\t\t} else if (value >= -128) {\n     \t\t\t\t\t\ttarget[position++] = 0xd0;\n     \t\t\t\t\t\ttarget[position++] = value + 0x100;\n     \t\t\t\t\t} else if (value >= -32768) {\n     \t\t\t\t\t\ttarget[position++] = 0xd1;\n     \t\t\t\t\t\ttargetView.setInt16(position, value);\n     \t\t\t\t\t\tposition += 2;\n     \t\t\t\t\t} else {\n     \t\t\t\t\t\ttarget[position++] = 0xd2;\n     \t\t\t\t\t\ttargetView.setInt32(position, value);\n     \t\t\t\t\t\tposition += 4;\n     \t\t\t\t\t}\n     \t\t\t\t} else {\n     \t\t\t\t\tlet useFloat32;\n     \t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -2147483648) {\n     \t\t\t\t\t\ttarget[position++] = 0xca;\n     \t\t\t\t\t\ttargetView.setFloat32(position, value);\n     \t\t\t\t\t\tlet xShifted;\n     \t\t\t\t\t\tif (useFloat32 < 4 ||\n     \t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n     \t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n     \t\t\t\t\t\t\tposition += 4;\n     \t\t\t\t\t\t\treturn\n     \t\t\t\t\t\t} else\n     \t\t\t\t\t\t\tposition--; // move back into position for writing a double\n     \t\t\t\t\t}\n     \t\t\t\t\ttarget[position++] = 0xcb;\n     \t\t\t\t\ttargetView.setFloat64(position, value);\n     \t\t\t\t\tposition += 8;\n     \t\t\t\t}\n     \t\t\t} else if (type === 'object' || type === 'function') {\n     \t\t\t\tif (!value)\n     \t\t\t\t\ttarget[position++] = 0xc0;\n     \t\t\t\telse {\n     \t\t\t\t\tif (referenceMap) {\n     \t\t\t\t\t\tlet referee = referenceMap.get(value);\n     \t\t\t\t\t\tif (referee) {\n     \t\t\t\t\t\t\tif (!referee.id) {\n     \t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);\n     \t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee);\n     \t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\ttarget[position++] = 0xd6; // fixext 4\n     \t\t\t\t\t\t\ttarget[position++] = 0x70; // \"p\" for pointer\n     \t\t\t\t\t\t\ttargetView.setUint32(position, referee.id);\n     \t\t\t\t\t\t\tposition += 4;\n     \t\t\t\t\t\t\treturn\n     \t\t\t\t\t\t} else\n     \t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start });\n     \t\t\t\t\t}\n     \t\t\t\t\tlet constructor = value.constructor;\n     \t\t\t\t\tif (constructor === Object) {\n     \t\t\t\t\t\twriteObject(value);\n     \t\t\t\t\t} else if (constructor === Array) {\n     \t\t\t\t\t\tpackArray(value);\n     \t\t\t\t\t} else if (constructor === Map) {\n     \t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80;\n     \t\t\t\t\t\telse {\n     \t\t\t\t\t\t\tlength = value.size;\n     \t\t\t\t\t\t\tif (length < 0x10) {\n     \t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length;\n     \t\t\t\t\t\t\t} else if (length < 0x10000) {\n     \t\t\t\t\t\t\t\ttarget[position++] = 0xde;\n     \t\t\t\t\t\t\t\ttarget[position++] = length >> 8;\n     \t\t\t\t\t\t\t\ttarget[position++] = length & 0xff;\n     \t\t\t\t\t\t\t} else {\n     \t\t\t\t\t\t\t\ttarget[position++] = 0xdf;\n     \t\t\t\t\t\t\t\ttargetView.setUint32(position, length);\n     \t\t\t\t\t\t\t\tposition += 4;\n     \t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n     \t\t\t\t\t\t\t\tpack(key);\n     \t\t\t\t\t\t\t\tpack(entryValue);\n     \t\t\t\t\t\t\t}\n     \t\t\t\t\t\t}\n     \t\t\t\t\t} else {\n     \t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n     \t\t\t\t\t\t\tlet extensionClass = extensionClasses[i];\n     \t\t\t\t\t\t\tif (value instanceof extensionClass) {\n     \t\t\t\t\t\t\t\tlet extension = extensions[i];\n     \t\t\t\t\t\t\t\tif (extension.write) {\n     \t\t\t\t\t\t\t\t\tif (extension.type) {\n     \t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4; // one byte \"tag\" extension\n     \t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type;\n     \t\t\t\t\t\t\t\t\t\ttarget[position++] = 0;\n     \t\t\t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value);\n     \t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n     \t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n     \t\t\t\t\t\t\t\t\t\t\tpackArray(value);\n     \t\t\t\t\t\t\t\t\t\t} else {\n     \t\t\t\t\t\t\t\t\t\t\twriteObject(value);\n     \t\t\t\t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\t\t\t} else {\n     \t\t\t\t\t\t\t\t\t\tpack(writeResult);\n     \t\t\t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\t\t\treturn\n     \t\t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\t\tlet currentTarget = target;\n     \t\t\t\t\t\t\t\tlet currentTargetView = targetView;\n     \t\t\t\t\t\t\t\tlet currentPosition = position;\n     \t\t\t\t\t\t\t\ttarget = null;\n     \t\t\t\t\t\t\t\tlet result;\n     \t\t\t\t\t\t\t\ttry {\n     \t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n     \t\t\t\t\t\t\t\t\t\t// restore target and use it\n     \t\t\t\t\t\t\t\t\t\ttarget = currentTarget;\n     \t\t\t\t\t\t\t\t\t\tcurrentTarget = null;\n     \t\t\t\t\t\t\t\t\t\tposition += size;\n     \t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n     \t\t\t\t\t\t\t\t\t\t\tmakeRoom(position);\n     \t\t\t\t\t\t\t\t\t\treturn {\n     \t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n     \t\t\t\t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\t\t\t}, pack);\n     \t\t\t\t\t\t\t\t} finally {\n     \t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n     \t\t\t\t\t\t\t\t\tif (currentTarget) {\n     \t\t\t\t\t\t\t\t\t\ttarget = currentTarget;\n     \t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView;\n     \t\t\t\t\t\t\t\t\t\tposition = currentPosition;\n     \t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10;\n     \t\t\t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\t\tif (result) {\n     \t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n     \t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position);\n     \t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type);\n     \t\t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\t\treturn\n     \t\t\t\t\t\t\t}\n     \t\t\t\t\t\t}\n     \t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n     \t\t\t\t\t\tif (Array.isArray(value)) {\n     \t\t\t\t\t\t\tpackArray(value);\n     \t\t\t\t\t\t} else {\n     \t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n     \t\t\t\t\t\t\tif (value.toJSON) {\n     \t\t\t\t\t\t\t\tconst json = value.toJSON();\n     \t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n     \t\t\t\t\t\t\t\tif (json !== value)\n     \t\t\t\t\t\t\t\t\treturn pack(json)\n     \t\t\t\t\t\t\t}\n\n     \t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n     \t\t\t\t\t\t\tif (type === 'function')\n     \t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n     \t\t\t\t\t\t\t// no extension found, write as plain object\n     \t\t\t\t\t\t\twriteObject(value);\n     \t\t\t\t\t\t}\n     \t\t\t\t\t}\n     \t\t\t\t}\n     \t\t\t} else if (type === 'boolean') {\n     \t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2;\n     \t\t\t} else if (type === 'bigint') {\n     \t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n     \t\t\t\t\t// use a signed int as long as it fits\n     \t\t\t\t\ttarget[position++] = 0xd3;\n     \t\t\t\t\ttargetView.setBigInt64(position, value);\n     \t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n     \t\t\t\t\t// if we can fit an unsigned int, use that\n     \t\t\t\t\ttarget[position++] = 0xcf;\n     \t\t\t\t\ttargetView.setBigUint64(position, value);\n     \t\t\t\t} else {\n     \t\t\t\t\t// overflow\n     \t\t\t\t\tif (this.largeBigIntToFloat) {\n     \t\t\t\t\t\ttarget[position++] = 0xcb;\n     \t\t\t\t\t\ttargetView.setFloat64(position, Number(value));\n     \t\t\t\t\t} else if (this.largeBigIntToString) {\n     \t\t\t\t\t\treturn pack(value.toString());\n     \t\t\t\t\t} else if (this.useBigIntExtension && value < BigInt(2)**BigInt(1023) && value > -(BigInt(2)**BigInt(1023))) {\n     \t\t\t\t\t\ttarget[position++] = 0xc7;\n     \t\t\t\t\t\tposition++;\n     \t\t\t\t\t\ttarget[position++] = 0x42; // \"B\" for BigInt\n     \t\t\t\t\t\tlet bytes = [];\n     \t\t\t\t\t\tlet alignedSign;\n     \t\t\t\t\t\tdo {\n     \t\t\t\t\t\t\tlet byte = value & BigInt(0xff);\n     \t\t\t\t\t\t\talignedSign = (byte & BigInt(0x80)) === (value < BigInt(0) ? BigInt(0x80) : BigInt(0));\n     \t\t\t\t\t\t\tbytes.push(byte);\n     \t\t\t\t\t\t\tvalue >>= BigInt(8);\n     \t\t\t\t\t\t} while (!((value === BigInt(0) || value === BigInt(-1)) && alignedSign));\n     \t\t\t\t\t\ttarget[position-2] = bytes.length;\n     \t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n     \t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n     \t\t\t\t\t\t}\n     \t\t\t\t\t\treturn\n     \t\t\t\t\t} else {\n     \t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n     \t\t\t\t\t\t\t' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +\n     \t\t\t\t\t\t\t' largeBigIntToString to convert to string')\n     \t\t\t\t\t}\n     \t\t\t\t}\n     \t\t\t\tposition += 8;\n     \t\t\t} else if (type === 'undefined') {\n     \t\t\t\tif (this.encodeUndefinedAsNil)\n     \t\t\t\t\ttarget[position++] = 0xc0;\n     \t\t\t\telse {\n     \t\t\t\t\ttarget[position++] = 0xd4; // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n     \t\t\t\t\ttarget[position++] = 0;\n     \t\t\t\t\ttarget[position++] = 0;\n     \t\t\t\t}\n     \t\t\t} else {\n     \t\t\t\tthrow new Error('Unknown type: ' + type)\n     \t\t\t}\n     \t\t};\n\n     \t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n     \t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n     \t\t\tlet keys;\n     \t\t\tif (this.skipValues) {\n     \t\t\t\tkeys = [];\n     \t\t\t\tfor (let key in object) {\n     \t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n     \t\t\t\t\t\t!this.skipValues.includes(object[key]))\n     \t\t\t\t\t\tkeys.push(key);\n     \t\t\t\t}\n     \t\t\t} else {\n     \t\t\t\tkeys = Object.keys(object);\n     \t\t\t}\n     \t\t\tlet length = keys.length;\n     \t\t\tif (length < 0x10) {\n     \t\t\t\ttarget[position++] = 0x80 | length;\n     \t\t\t} else if (length < 0x10000) {\n     \t\t\t\ttarget[position++] = 0xde;\n     \t\t\t\ttarget[position++] = length >> 8;\n     \t\t\t\ttarget[position++] = length & 0xff;\n     \t\t\t} else {\n     \t\t\t\ttarget[position++] = 0xdf;\n     \t\t\t\ttargetView.setUint32(position, length);\n     \t\t\t\tposition += 4;\n     \t\t\t}\n     \t\t\tlet key;\n     \t\t\tif (this.coercibleKeyAsNumber) {\n     \t\t\t\tfor (let i = 0; i < length; i++) {\n     \t\t\t\t\tkey = keys[i];\n     \t\t\t\t\tlet num = Number(key);\n     \t\t\t\t\tpack(isNaN(num) ? key : num);\n     \t\t\t\t\tpack(object[key]);\n     \t\t\t\t}\n\n     \t\t\t} else {\n     \t\t\t\tfor (let i = 0; i < length; i++) {\n     \t\t\t\t\tpack(key = keys[i]);\n     \t\t\t\t\tpack(object[key]);\n     \t\t\t\t}\n     \t\t\t}\n     \t\t} :\n     \t\t(object) => {\n     \t\t\ttarget[position++] = 0xde; // always using map 16, so we can preallocate and set the length afterwards\n     \t\t\tlet objectOffset = position - start;\n     \t\t\tposition += 2;\n     \t\t\tlet size = 0;\n     \t\t\tfor (let key in object) {\n     \t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n     \t\t\t\t\tpack(key);\n     \t\t\t\t\tpack(object[key]);\n     \t\t\t\t\tsize++;\n     \t\t\t\t}\n     \t\t\t}\n     \t\t\tif (size > 0xffff) {\n     \t\t\t\tthrow new Error('Object is too large to serialize with fast 16-bit map size,' +\n     \t\t\t\t' use the \"variableMapSize\" option to serialize this object');\n     \t\t\t}\n     \t\t\ttarget[objectOffset++ + start] = size >> 8;\n     \t\t\ttarget[objectOffset + start] = size & 0xff;\n     \t\t};\n\n     \t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n     \t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n     \t\t(object) => {\n     \t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n     \t\t\tlet objectOffset = position++ - start;\n     \t\t\tlet wroteKeys;\n     \t\t\tfor (let key in object) {\n     \t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n     \t\t\t\t\tnextTransition = transition[key];\n     \t\t\t\t\tif (nextTransition)\n     \t\t\t\t\t\ttransition = nextTransition;\n     \t\t\t\t\telse {\n     \t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n     \t\t\t\t\t\tlet keys = Object.keys(object);\n     \t\t\t\t\t\tlet lastTransition = transition;\n     \t\t\t\t\t\ttransition = structures.transitions;\n     \t\t\t\t\t\tlet newTransitions = 0;\n     \t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n     \t\t\t\t\t\t\tlet key = keys[i];\n     \t\t\t\t\t\t\tnextTransition = transition[key];\n     \t\t\t\t\t\t\tif (!nextTransition) {\n     \t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n     \t\t\t\t\t\t\t\tnewTransitions++;\n     \t\t\t\t\t\t\t}\n     \t\t\t\t\t\t\ttransition = nextTransition;\n     \t\t\t\t\t\t}\n     \t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n     \t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n     \t\t\t\t\t\t\tposition--;\n     \t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions);\n     \t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n     \t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions);\n     \t\t\t\t\t\twroteKeys = true;\n     \t\t\t\t\t\ttransition = lastTransition[key];\n     \t\t\t\t\t}\n     \t\t\t\t\tpack(object[key]);\n     \t\t\t\t}\n     \t\t\t}\n     \t\t\tif (!wroteKeys) {\n     \t\t\t\tlet recordId = transition[RECORD_SYMBOL];\n     \t\t\t\tif (recordId)\n     \t\t\t\t\ttarget[objectOffset + start] = recordId;\n     \t\t\t\telse\n     \t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0);\n     \t\t\t}\n     \t\t} :\n     \t\t(object) => {\n     \t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n     \t\t\tlet newTransitions = 0;\n     \t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n     \t\t\t\tnextTransition = transition[key];\n     \t\t\t\tif (!nextTransition) {\n     \t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n     \t\t\t\t\tnewTransitions++;\n     \t\t\t\t}\n     \t\t\t\ttransition = nextTransition;\n     \t\t\t}\n     \t\t\tlet recordId = transition[RECORD_SYMBOL];\n     \t\t\tif (recordId) {\n     \t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n     \t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60;\n     \t\t\t\t\ttarget[position++] = recordId >> 5;\n     \t\t\t\t} else\n     \t\t\t\t\ttarget[position++] = recordId;\n     \t\t\t} else {\n     \t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);\n     \t\t\t}\n     \t\t\t// now write the values\n     \t\t\tfor (let key in object)\n     \t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n     \t\t\t\t\tpack(object[key]);\n     \t\t\t\t}\n     \t\t};\n\n     \t\t// create reference to useRecords if useRecords is a function\n     \t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n     \t\tconst writeObject = checkUseRecords ? (object) => {\n     \t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object);\n     \t\t} : writeRecord;\n\n     \t\tconst makeRoom = (end) => {\n     \t\t\tlet newSize;\n     \t\t\tif (end > 0x1000000) {\n     \t\t\t\t// special handling for really large buffers\n     \t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n     \t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n     \t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n     \t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);\n     \t\t\t} else // faster handling for smaller buffers\n     \t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12;\n     \t\t\tlet newBuffer = new ByteArrayAllocate(newSize);\n     \t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));\n     \t\t\tend = Math.min(end, target.length);\n     \t\t\tif (target.copy)\n     \t\t\t\ttarget.copy(newBuffer, 0, start, end);\n     \t\t\telse\n     \t\t\t\tnewBuffer.set(target.slice(start, end));\n     \t\t\tposition -= start;\n     \t\t\tstart = 0;\n     \t\t\tsafeEnd = newBuffer.length - 10;\n     \t\t\treturn target = newBuffer\n     \t\t};\n     \t\tconst newRecord = (transition, keys, newTransitions) => {\n     \t\t\tlet recordId = structures.nextId;\n     \t\t\tif (!recordId)\n     \t\t\t\trecordId = 0x40;\n     \t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n     \t\t\t\trecordId = structures.nextOwnId;\n     \t\t\t\tif (!(recordId < maxStructureId))\n     \t\t\t\t\trecordId = sharedLimitId;\n     \t\t\t\tstructures.nextOwnId = recordId + 1;\n     \t\t\t} else {\n     \t\t\t\tif (recordId >= maxStructureId)// cycle back around\n     \t\t\t\t\trecordId = sharedLimitId;\n     \t\t\t\tstructures.nextId = recordId + 1;\n     \t\t\t}\n     \t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1;\n     \t\t\ttransition[RECORD_SYMBOL] = recordId;\n     \t\t\ttransition.__keys__ = keys;\n     \t\t\tstructures[recordId - 0x40] = keys;\n\n     \t\t\tif (recordId < sharedLimitId) {\n     \t\t\t\tkeys.isShared = true;\n     \t\t\t\tstructures.sharedLength = recordId - 0x3f;\n     \t\t\t\thasSharedUpdate = true;\n     \t\t\t\tif (highByte >= 0) {\n     \t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60;\n     \t\t\t\t\ttarget[position++] = highByte;\n     \t\t\t\t} else {\n     \t\t\t\t\ttarget[position++] = recordId;\n     \t\t\t\t}\n     \t\t\t} else {\n     \t\t\t\tif (highByte >= 0) {\n     \t\t\t\t\ttarget[position++] = 0xd5; // fixext 2\n     \t\t\t\t\ttarget[position++] = 0x72; // \"r\" record defintion extension type\n     \t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60;\n     \t\t\t\t\ttarget[position++] = highByte;\n     \t\t\t\t} else {\n     \t\t\t\t\ttarget[position++] = 0xd4; // fixext 1\n     \t\t\t\t\ttarget[position++] = 0x72; // \"r\" record defintion extension type\n     \t\t\t\t\ttarget[position++] = recordId;\n     \t\t\t\t}\n\n     \t\t\t\tif (newTransitions)\n     \t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n     \t\t\t\t// record the removal of the id, we can maintain our shared structure\n     \t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n     \t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0; // we are cycling back through, and have to remove old ones\n     \t\t\t\trecordIdsToRemove.push(transition);\n     \t\t\t\tpack(keys);\n     \t\t\t}\n     \t\t};\n     \t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n     \t\t\tlet mainTarget = target;\n     \t\t\tlet mainPosition = position;\n     \t\t\tlet mainSafeEnd = safeEnd;\n     \t\t\tlet mainStart = start;\n     \t\t\ttarget = keysTarget;\n     \t\t\tposition = 0;\n     \t\t\tstart = 0;\n     \t\t\tif (!target)\n     \t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192);\n     \t\t\tsafeEnd = target.length - 10;\n     \t\t\tnewRecord(transition, keys, newTransitions);\n     \t\t\tkeysTarget = target;\n     \t\t\tlet keysPosition = position;\n     \t\t\ttarget = mainTarget;\n     \t\t\tposition = mainPosition;\n     \t\t\tsafeEnd = mainSafeEnd;\n     \t\t\tstart = mainStart;\n     \t\t\tif (keysPosition > 1) {\n     \t\t\t\tlet newEnd = position + keysPosition - 1;\n     \t\t\t\tif (newEnd > safeEnd)\n     \t\t\t\t\tmakeRoom(newEnd);\n     \t\t\t\tlet insertionPosition = insertionOffset + start;\n     \t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position);\n     \t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition);\n     \t\t\t\tposition = newEnd;\n     \t\t\t} else {\n     \t\t\t\ttarget[insertionOffset + start] = keysTarget[0];\n     \t\t\t}\n     \t\t};\n     \t\tconst writeStruct = (object) => {\n     \t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n     \t\t\t\tif (notifySharedUpdate)\n     \t\t\t\t\treturn hasSharedUpdate = true;\n     \t\t\t\tposition = newPosition;\n     \t\t\t\tlet startTarget = target;\n     \t\t\t\tpack(value);\n     \t\t\t\tresetStructures();\n     \t\t\t\tif (startTarget !== target) {\n     \t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n     \t\t\t\t}\n     \t\t\t\treturn position;\n     \t\t\t}, this);\n     \t\t\tif (newPosition === 0) // bail and go to a msgpack object\n     \t\t\t\treturn writeObject(object);\n     \t\t\tposition = newPosition;\n     \t\t};\n     \t}\n     \tuseBuffer(buffer) {\n     \t\t// this means we are finished using our own buffer and we can write over it safely\n     \t\ttarget = buffer;\n     \t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));\n     \t\tposition = 0;\n     \t}\n     \tset position (value) {\n     \t\tposition = value;\n     \t}\n     \tget position() {\n     \t\treturn position;\n     \t}\n     \tset buffer (buffer) {\n     \t\ttarget = buffer;\n     \t}\n     \tget buffer () {\n     \t\treturn target;\n     \t}\n     \tclearSharedData() {\n     \t\tif (this.structures)\n     \t\t\tthis.structures = [];\n     \t\tif (this.typedStructs)\n     \t\t\tthis.typedStructs = [];\n     \t}\n     }\n\n     extensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ];\n     extensions = [{\n     \tpack(date, allocateForWrite, pack) {\n     \t\tlet seconds = date.getTime() / 1000;\n     \t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n     \t\t\t// Timestamp 32\n     \t\t\tlet { target, targetView, position} = allocateForWrite(6);\n     \t\t\ttarget[position++] = 0xd6;\n     \t\t\ttarget[position++] = 0xff;\n     \t\t\ttargetView.setUint32(position, seconds);\n     \t\t} else if (seconds > 0 && seconds < 0x100000000) {\n     \t\t\t// Timestamp 64\n     \t\t\tlet { target, targetView, position} = allocateForWrite(10);\n     \t\t\ttarget[position++] = 0xd7;\n     \t\t\ttarget[position++] = 0xff;\n     \t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0));\n     \t\t\ttargetView.setUint32(position + 4, seconds);\n     \t\t} else if (isNaN(seconds)) {\n     \t\t\tif (this.onInvalidDate) {\n     \t\t\t\tallocateForWrite(0);\n     \t\t\t\treturn pack(this.onInvalidDate())\n     \t\t\t}\n     \t\t\t// Intentionally invalid timestamp\n     \t\t\tlet { target, targetView, position} = allocateForWrite(3);\n     \t\t\ttarget[position++] = 0xd4;\n     \t\t\ttarget[position++] = 0xff;\n     \t\t\ttarget[position++] = 0xff;\n     \t\t} else {\n     \t\t\t// Timestamp 96\n     \t\t\tlet { target, targetView, position} = allocateForWrite(15);\n     \t\t\ttarget[position++] = 0xc7;\n     \t\t\ttarget[position++] = 12;\n     \t\t\ttarget[position++] = 0xff;\n     \t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000);\n     \t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)));\n     \t\t}\n     \t}\n     }, {\n     \tpack(set, allocateForWrite, pack) {\n     \t\tif (this.setAsEmptyObject) {\n     \t\t\tallocateForWrite(0);\n     \t\t\treturn pack({})\n     \t\t}\n     \t\tlet array = Array.from(set);\n     \t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n     \t\tif (this.moreTypes) {\n     \t\t\ttarget[position++] = 0xd4;\n     \t\t\ttarget[position++] = 0x73; // 's' for Set\n     \t\t\ttarget[position++] = 0;\n     \t\t}\n     \t\tpack(array);\n     \t}\n     }, {\n     \tpack(error, allocateForWrite, pack) {\n     \t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n     \t\tif (this.moreTypes) {\n     \t\t\ttarget[position++] = 0xd4;\n     \t\t\ttarget[position++] = 0x65; // 'e' for error\n     \t\t\ttarget[position++] = 0;\n     \t\t}\n     \t\tpack([ error.name, error.message, error.cause ]);\n     \t}\n     }, {\n     \tpack(regex, allocateForWrite, pack) {\n     \t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n     \t\tif (this.moreTypes) {\n     \t\t\ttarget[position++] = 0xd4;\n     \t\t\ttarget[position++] = 0x78; // 'x' for regeXp\n     \t\t\ttarget[position++] = 0;\n     \t\t}\n     \t\tpack([ regex.source, regex.flags ]);\n     \t}\n     }, {\n     \tpack(arrayBuffer, allocateForWrite) {\n     \t\tif (this.moreTypes)\n     \t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite);\n     \t\telse\n     \t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);\n     \t}\n     }, {\n     \tpack(typedArray, allocateForWrite) {\n     \t\tlet constructor = typedArray.constructor;\n     \t\tif (constructor !== ByteArray && this.moreTypes)\n     \t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);\n     \t\telse\n     \t\t\twriteBuffer(typedArray, allocateForWrite);\n     \t}\n     }, {\n     \tpack(c1, allocateForWrite) { // specific 0xC1 object\n     \t\tlet { target, position} = allocateForWrite(1);\n     \t\ttarget[position] = 0xc1;\n     \t}\n     }];\n\n     function writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n     \tlet length = typedArray.byteLength;\n     \tif (length + 1 < 0x100) {\n     \t\tvar { target, position } = allocateForWrite(4 + length);\n     \t\ttarget[position++] = 0xc7;\n     \t\ttarget[position++] = length + 1;\n     \t} else if (length + 1 < 0x10000) {\n     \t\tvar { target, position } = allocateForWrite(5 + length);\n     \t\ttarget[position++] = 0xc8;\n     \t\ttarget[position++] = (length + 1) >> 8;\n     \t\ttarget[position++] = (length + 1) & 0xff;\n     \t} else {\n     \t\tvar { target, position, targetView } = allocateForWrite(7 + length);\n     \t\ttarget[position++] = 0xc9;\n     \t\ttargetView.setUint32(position, length + 1); // plus one for the type byte\n     \t\tposition += 4;\n     \t}\n     \ttarget[position++] = 0x74; // \"t\" for typed array\n     \ttarget[position++] = type;\n     \tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray);\n     \ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position);\n     }\n     function writeBuffer(buffer, allocateForWrite) {\n     \tlet length = buffer.byteLength;\n     \tvar target, position;\n     \tif (length < 0x100) {\n     \t\tvar { target, position } = allocateForWrite(length + 2);\n     \t\ttarget[position++] = 0xc4;\n     \t\ttarget[position++] = length;\n     \t} else if (length < 0x10000) {\n     \t\tvar { target, position } = allocateForWrite(length + 3);\n     \t\ttarget[position++] = 0xc5;\n     \t\ttarget[position++] = length >> 8;\n     \t\ttarget[position++] = length & 0xff;\n     \t} else {\n     \t\tvar { target, position, targetView } = allocateForWrite(length + 5);\n     \t\ttarget[position++] = 0xc6;\n     \t\ttargetView.setUint32(position, length);\n     \t\tposition += 4;\n     \t}\n     \ttarget.set(buffer, position);\n     }\n\n     function writeExtensionData(result, target, position, type) {\n     \tlet length = result.length;\n     \tswitch (length) {\n     \t\tcase 1:\n     \t\t\ttarget[position++] = 0xd4;\n     \t\t\tbreak\n     \t\tcase 2:\n     \t\t\ttarget[position++] = 0xd5;\n     \t\t\tbreak\n     \t\tcase 4:\n     \t\t\ttarget[position++] = 0xd6;\n     \t\t\tbreak\n     \t\tcase 8:\n     \t\t\ttarget[position++] = 0xd7;\n     \t\t\tbreak\n     \t\tcase 16:\n     \t\t\ttarget[position++] = 0xd8;\n     \t\t\tbreak\n     \t\tdefault:\n     \t\t\tif (length < 0x100) {\n     \t\t\t\ttarget[position++] = 0xc7;\n     \t\t\t\ttarget[position++] = length;\n     \t\t\t} else if (length < 0x10000) {\n     \t\t\t\ttarget[position++] = 0xc8;\n     \t\t\t\ttarget[position++] = length >> 8;\n     \t\t\t\ttarget[position++] = length & 0xff;\n     \t\t\t} else {\n     \t\t\t\ttarget[position++] = 0xc9;\n     \t\t\t\ttarget[position++] = length >> 24;\n     \t\t\t\ttarget[position++] = (length >> 16) & 0xff;\n     \t\t\t\ttarget[position++] = (length >> 8) & 0xff;\n     \t\t\t\ttarget[position++] = length & 0xff;\n     \t\t\t}\n     \t}\n     \ttarget[position++] = type;\n     \ttarget.set(result, position);\n     \tposition += length;\n     \treturn position\n     }\n\n     function insertIds(serialized, idsToInsert) {\n     \t// insert the ids that need to be referenced for structured clones\n     \tlet nextId;\n     \tlet distanceToMove = idsToInsert.length * 6;\n     \tlet lastEnd = serialized.length - distanceToMove;\n     \twhile (nextId = idsToInsert.pop()) {\n     \t\tlet offset = nextId.offset;\n     \t\tlet id = nextId.id;\n     \t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n     \t\tdistanceToMove -= 6;\n     \t\tlet position = offset + distanceToMove;\n     \t\tserialized[position++] = 0xd6;\n     \t\tserialized[position++] = 0x69; // 'i'\n     \t\tserialized[position++] = id >> 24;\n     \t\tserialized[position++] = (id >> 16) & 0xff;\n     \t\tserialized[position++] = (id >> 8) & 0xff;\n     \t\tserialized[position++] = id & 0xff;\n     \t\tlastEnd = offset;\n     \t}\n     \treturn serialized\n     }\n\n     function writeBundles(start, pack, incrementPosition) {\n     \tif (bundledStrings.length > 0) {\n     \t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start);\n     \t\tbundledStrings.stringsPosition = position - start;\n     \t\tlet writeStrings = bundledStrings;\n     \t\tbundledStrings = null;\n     \t\tpack(writeStrings[0]);\n     \t\tpack(writeStrings[1]);\n     \t}\n     }\n     function prepareStructures(structures, packr) {\n     \tstructures.isCompatible = (existingStructures) => {\n     \t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length);\n     \t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n     \t\t\tpackr._mergeStructures(existingStructures);\n     \t\treturn compatible;\n     \t};\n     \treturn structures\n     }\n\n     let defaultPackr = new Packr({ useRecords: false });\n     defaultPackr.pack;\n     defaultPackr.pack;\n     const REUSE_BUFFER_MODE = 512;\n     const RESET_BUFFER_MODE = 1024;\n     const RESERVE_START_SPACE = 2048;\n\n     class Room {\n         constructor(name, rootSchema) {\n             // Public signals\n             this.onStateChange = createSignal();\n             this.onError = createSignal();\n             this.onLeave = createSignal();\n             this.onJoin = createSignal();\n             this.hasJoined = false;\n             this.onMessageHandlers = createNanoEvents();\n             this.roomId = null;\n             this.name = name;\n             this.packr = new Packr();\n             // msgpackr workaround: force buffer to be created.\n             this.packr.encode(undefined);\n             if (rootSchema) {\n                 this.serializer = new (getSerializer(\"schema\"));\n                 this.rootSchema = rootSchema;\n                 this.serializer.state = new rootSchema();\n             }\n             this.onError((code, message) => { var _a; return (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `colyseus.js - onError => (${code}) ${message}`); });\n             this.onLeave(() => this.removeAllListeners());\n         }\n         connect(endpoint, devModeCloseCallback, room = this, // when reconnecting on devMode, re-use previous room intance for handling events.\n         options, headers) {\n             const connection = new Connection(options.protocol);\n             room.connection = connection;\n             connection.events.onmessage = Room.prototype.onMessageCallback.bind(room);\n             connection.events.onclose = function (e) {\n                 var _a;\n                 if (!room.hasJoined) {\n                     (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `Room connection was closed unexpectedly (${e.code}): ${e.reason}`);\n                     room.onError.invoke(e.code, e.reason);\n                     return;\n                 }\n                 if (e.code === CloseCode.DEVMODE_RESTART && devModeCloseCallback) {\n                     devModeCloseCallback();\n                 }\n                 else {\n                     room.onLeave.invoke(e.code, e.reason);\n                     room.destroy();\n                 }\n             };\n             connection.events.onerror = function (e) {\n                 var _a;\n                 (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `Room, onError (${e.code}): ${e.reason}`);\n                 room.onError.invoke(e.code, e.reason);\n             };\n             // FIXME: refactor this.\n             if (options.protocol === \"h3\") {\n                 const url = new URL(endpoint);\n                 connection.connect(url.origin, options);\n             }\n             else {\n                 connection.connect(endpoint, headers);\n             }\n         }\n         leave(consented = true) {\n             return new Promise((resolve) => {\n                 this.onLeave((code) => resolve(code));\n                 if (this.connection) {\n                     if (consented) {\n                         this.packr.buffer[0] = exports.Protocol.LEAVE_ROOM;\n                         this.connection.send(this.packr.buffer.subarray(0, 1));\n                     }\n                     else {\n                         this.connection.close();\n                     }\n                 }\n                 else {\n                     this.onLeave.invoke(CloseCode.CONSENTED);\n                 }\n             });\n         }\n         onMessage(type, callback) {\n             return this.onMessageHandlers.on(this.getMessageHandlerKey(type), callback);\n         }\n         send(type, message) {\n             const it = { offset: 1 };\n             this.packr.buffer[0] = exports.Protocol.ROOM_DATA;\n             if (typeof (type) === \"string\") {\n                 umdExports.encode.string(this.packr.buffer, type, it);\n             }\n             else {\n                 umdExports.encode.number(this.packr.buffer, type, it);\n             }\n             // force packr to use beginning of the buffer\n             this.packr.position = 0;\n             const data = (message !== undefined)\n                 ? this.packr.pack(message, 2048 + it.offset) // 2048 = RESERVE_START_SPACE\n                 : this.packr.buffer.subarray(0, it.offset);\n             this.connection.send(data);\n         }\n         sendUnreliable(type, message) {\n             const it = { offset: 1 };\n             this.packr.buffer[0] = exports.Protocol.ROOM_DATA;\n             if (typeof (type) === \"string\") {\n                 umdExports.encode.string(this.packr.buffer, type, it);\n             }\n             else {\n                 umdExports.encode.number(this.packr.buffer, type, it);\n             }\n             // force packr to use beginning of the buffer\n             this.packr.position = 0;\n             const data = (message !== undefined)\n                 ? this.packr.pack(message, 2048 + it.offset) // 2048 = RESERVE_START_SPACE\n                 : this.packr.buffer.subarray(0, it.offset);\n             this.connection.sendUnreliable(data);\n         }\n         sendBytes(type, bytes) {\n             const it = { offset: 1 };\n             this.packr.buffer[0] = exports.Protocol.ROOM_DATA_BYTES;\n             if (typeof (type) === \"string\") {\n                 umdExports.encode.string(this.packr.buffer, type, it);\n             }\n             else {\n                 umdExports.encode.number(this.packr.buffer, type, it);\n             }\n             // check if buffer needs to be resized\n             // TODO: can we avoid this?\n             if (bytes.byteLength + it.offset > this.packr.buffer.byteLength) {\n                 const newBuffer = new Uint8Array(it.offset + bytes.byteLength);\n                 newBuffer.set(this.packr.buffer);\n                 this.packr.useBuffer(newBuffer);\n             }\n             this.packr.buffer.set(bytes, it.offset);\n             this.connection.send(this.packr.buffer.subarray(0, it.offset + bytes.byteLength));\n         }\n         get state() {\n             return this.serializer.getState();\n         }\n         removeAllListeners() {\n             this.onJoin.clear();\n             this.onStateChange.clear();\n             this.onError.clear();\n             this.onLeave.clear();\n             this.onMessageHandlers.events = {};\n             if (this.serializer instanceof SchemaSerializer) {\n                 // Remove callback references\n                 this.serializer.decoder.root.callbacks = {};\n             }\n         }\n         onMessageCallback(event) {\n             const buffer = new Uint8Array(event.data);\n             const it = { offset: 1 };\n             const code = buffer[0];\n             if (code === exports.Protocol.JOIN_ROOM) {\n                 const reconnectionToken = umdExports.decode.utf8Read(buffer, it, buffer[it.offset++]);\n                 this.serializerId = umdExports.decode.utf8Read(buffer, it, buffer[it.offset++]);\n                 // Instantiate serializer if not locally available.\n                 if (!this.serializer) {\n                     const serializer = getSerializer(this.serializerId);\n                     this.serializer = new serializer();\n                 }\n                 if (buffer.byteLength > it.offset && this.serializer.handshake) {\n                     this.serializer.handshake(buffer, it);\n                 }\n                 this.reconnectionToken = `${this.roomId}:${reconnectionToken}`;\n                 this.hasJoined = true;\n                 this.onJoin.invoke();\n                 // acknowledge successfull JOIN_ROOM\n                 this.packr.buffer[0] = exports.Protocol.JOIN_ROOM;\n                 this.connection.send(this.packr.buffer.subarray(0, 1));\n             }\n             else if (code === exports.Protocol.ERROR) {\n                 const code = umdExports.decode.number(buffer, it);\n                 const message = umdExports.decode.string(buffer, it);\n                 this.onError.invoke(code, message);\n             }\n             else if (code === exports.Protocol.LEAVE_ROOM) {\n                 this.leave();\n             }\n             else if (code === exports.Protocol.ROOM_STATE) {\n                 this.serializer.setState(buffer, it);\n                 this.onStateChange.invoke(this.serializer.getState());\n             }\n             else if (code === exports.Protocol.ROOM_STATE_PATCH) {\n                 this.serializer.patch(buffer, it);\n                 this.onStateChange.invoke(this.serializer.getState());\n             }\n             else if (code === exports.Protocol.ROOM_DATA) {\n                 const type = (umdExports.decode.stringCheck(buffer, it))\n                     ? umdExports.decode.string(buffer, it)\n                     : umdExports.decode.number(buffer, it);\n                 const message = (buffer.byteLength > it.offset)\n                     ? unpack(buffer, { start: it.offset })\n                     : undefined;\n                 this.dispatchMessage(type, message);\n             }\n             else if (code === exports.Protocol.ROOM_DATA_BYTES) {\n                 const type = (umdExports.decode.stringCheck(buffer, it))\n                     ? umdExports.decode.string(buffer, it)\n                     : umdExports.decode.number(buffer, it);\n                 this.dispatchMessage(type, buffer.subarray(it.offset));\n             }\n         }\n         dispatchMessage(type, message) {\n             var _a;\n             const messageType = this.getMessageHandlerKey(type);\n             if (this.onMessageHandlers.events[messageType]) {\n                 this.onMessageHandlers.emit(messageType, message);\n             }\n             else if (this.onMessageHandlers.events['*']) {\n                 this.onMessageHandlers.emit('*', type, message);\n             }\n             else {\n                 (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `colyseus.js: onMessage() not registered for type '${type}'.`);\n             }\n         }\n         destroy() {\n             if (this.serializer) {\n                 this.serializer.teardown();\n             }\n         }\n         getMessageHandlerKey(type) {\n             switch (typeof (type)) {\n                 // string\n                 case \"string\": return type;\n                 // number\n                 case \"number\": return `i${type}`;\n                 default: throw new Error(\"invalid message type.\");\n             }\n         }\n     }\n\n     var xhr = {};\n\n     var hasRequiredXhr;\n\n     function requireXhr () {\n     \tif (hasRequiredXhr) return xhr;\n     \thasRequiredXhr = 1;\n     \tfunction apply(src, tar) {\n     \t\ttar.headers = src.headers || {};\n     \t\ttar.statusMessage = src.statusText;\n     \t\ttar.statusCode = src.status;\n     \t\ttar.data = src.response;\n     \t}\n\n     \tfunction send(method, uri, opts) {\n     \t\treturn new Promise(function (res, rej) {\n     \t\t\topts = opts || {};\n     \t\t\tvar req = new XMLHttpRequest;\n     \t\t\tvar k, tmp, arr, str=opts.body;\n     \t\t\tvar headers = opts.headers || {};\n\n     \t\t\t// IE compatible\n     \t\t\tif (opts.timeout) req.timeout = opts.timeout;\n     \t\t\treq.ontimeout = req.onerror = function (err) {\n     \t\t\t\terr.timeout = err.type == 'timeout';\n     \t\t\t\trej(err);\n     \t\t\t};\n\n     \t\t\treq.open(method, uri.href || uri);\n\n     \t\t\treq.onload = function () {\n     \t\t\t\tarr = req.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n     \t\t\t\tapply(req, req); //=> req.headers\n\n     \t\t\t\twhile (tmp = arr.shift()) {\n     \t\t\t\t\ttmp = tmp.split(': ');\n     \t\t\t\t\treq.headers[tmp.shift().toLowerCase()] = tmp.join(': ');\n     \t\t\t\t}\n\n     \t\t\t\ttmp = req.headers['content-type'];\n     \t\t\t\tif (tmp && !!~tmp.indexOf('application/json')) {\n     \t\t\t\t\ttry {\n     \t\t\t\t\t\treq.data = JSON.parse(req.data, opts.reviver);\n     \t\t\t\t\t} catch (err) {\n     \t\t\t\t\t\tapply(req, err);\n     \t\t\t\t\t\treturn rej(err);\n     \t\t\t\t\t}\n     \t\t\t\t}\n\n     \t\t\t\t(req.status >= 400 ? rej : res)(req);\n     \t\t\t};\n\n     \t\t\tif (typeof FormData < 'u' && str instanceof FormData) ; else if (str && typeof str == 'object') {\n     \t\t\t\theaders['content-type'] = 'application/json';\n     \t\t\t\tstr = JSON.stringify(str);\n     \t\t\t}\n\n     \t\t\treq.withCredentials = !!opts.withCredentials;\n\n     \t\t\tfor (k in headers) {\n     \t\t\t\treq.setRequestHeader(k, headers[k]);\n     \t\t\t}\n\n     \t\t\treq.send(str);\n     \t\t});\n     \t}\n\n     \tvar get = /*#__PURE__*/ send.bind(send, 'GET');\n     \tvar post = /*#__PURE__*/ send.bind(send, 'POST');\n     \tvar patch = /*#__PURE__*/ send.bind(send, 'PATCH');\n     \tvar del = /*#__PURE__*/ send.bind(send, 'DELETE');\n     \tvar put = /*#__PURE__*/ send.bind(send, 'PUT');\n\n     \txhr.del = del;\n     \txhr.get = get;\n     \txhr.patch = patch;\n     \txhr.post = post;\n     \txhr.put = put;\n     \txhr.send = send;\n     \treturn xhr;\n     }\n\n     var xhrExports = requireXhr();\n     var index = /*@__PURE__*/getDefaultExportFromCjs(xhrExports);\n\n     var httpie = /*#__PURE__*/_mergeNamespaces({\n         __proto__: null,\n         default: index\n     }, [xhrExports]);\n\n     class HTTP {\n         constructor(client, headers = {}) {\n             this.client = client;\n             this.headers = headers;\n         }\n         get(path, options = {}) {\n             return this.request(\"get\", path, options);\n         }\n         post(path, options = {}) {\n             return this.request(\"post\", path, options);\n         }\n         del(path, options = {}) {\n             return this.request(\"del\", path, options);\n         }\n         put(path, options = {}) {\n             return this.request(\"put\", path, options);\n         }\n         request(method, path, options = {}) {\n             return httpie[method](this.client['getHttpEndpoint'](path), this.getOptions(options)).catch((e) => {\n                 var _a;\n                 const status = e.statusCode; //  || -1\n                 const message = ((_a = e.data) === null || _a === void 0 ? void 0 : _a.error) || e.statusMessage || e.message; //  || \"offline\"\n                 if (!status && !message) {\n                     throw e;\n                 }\n                 throw new ServerError(status, message);\n             });\n         }\n         getOptions(options) {\n             // merge default custom headers with user headers\n             options.headers = Object.assign({}, this.headers, options.headers);\n             if (this.authToken) {\n                 options.headers['Authorization'] = `Bearer ${this.authToken}`;\n             }\n             if (typeof (cc) !== 'undefined' && cc.sys && cc.sys.isNative) ;\n             else {\n                 // always include credentials\n                 options.withCredentials = true;\n             }\n             return options;\n         }\n     }\n\n     /// <reference path=\"../typings/cocos-creator.d.ts\" />\n     /**\n      * We do not assign 'storage' to window.localStorage immediatelly for React\n      * Native compatibility. window.localStorage is not present when this module is\n      * loaded.\n      */\n     let storage;\n     function getStorage() {\n         if (!storage) {\n             try {\n                 storage = (typeof (cc) !== 'undefined' && cc.sys && cc.sys.localStorage)\n                     ? cc.sys.localStorage // compatibility with cocos creator\n                     : window.localStorage; // RN does have window object at this point, but localStorage is not defined\n             }\n             catch (e) {\n                 // ignore error\n             }\n         }\n         if (!storage && typeof (globalThis.indexedDB) !== 'undefined') {\n             storage = new IndexedDBStorage();\n         }\n         if (!storage) {\n             // mock localStorage if not available (Node.js or RN environment)\n             storage = {\n                 cache: {},\n                 setItem: function (key, value) { this.cache[key] = value; },\n                 getItem: function (key) { this.cache[key]; },\n                 removeItem: function (key) { delete this.cache[key]; },\n             };\n         }\n         return storage;\n     }\n     function setItem(key, value) {\n         getStorage().setItem(key, value);\n     }\n     function removeItem(key) {\n         getStorage().removeItem(key);\n     }\n     function getItem(key, callback) {\n         const value = getStorage().getItem(key);\n         if (typeof (Promise) === 'undefined' || // old browsers\n             !(value instanceof Promise)) {\n             // browser has synchronous return\n             callback(value);\n         }\n         else {\n             // react-native is asynchronous\n             value.then((id) => callback(id));\n         }\n     }\n     /**\n      * When running in a Web Worker, we need to use IndexedDB to store data.\n      */\n     class IndexedDBStorage {\n         constructor() {\n             this.dbPromise = new Promise((resolve) => {\n                 const request = indexedDB.open('_colyseus_storage', 1);\n                 request.onupgradeneeded = () => request.result.createObjectStore('store');\n                 request.onsuccess = () => resolve(request.result);\n             });\n         }\n         tx(mode, fn) {\n             return __awaiter(this, void 0, void 0, function* () {\n                 const db = yield this.dbPromise;\n                 const store = db.transaction('store', mode).objectStore('store');\n                 return fn(store);\n             });\n         }\n         setItem(key, value) {\n             return this.tx('readwrite', store => store.put(value, key)).then();\n         }\n         getItem(key) {\n             return __awaiter(this, void 0, void 0, function* () {\n                 const request = yield this.tx('readonly', store => store.get(key));\n                 return new Promise((resolve) => {\n                     request.onsuccess = () => resolve(request.result);\n                 });\n             });\n         }\n         removeItem(key) {\n             return this.tx('readwrite', store => store.delete(key)).then();\n         }\n     }\n\n     var _Auth__initialized, _Auth__initializationPromise, _Auth__signInWindow, _Auth__events;\n     class Auth {\n         constructor(http) {\n             this.http = http;\n             this.settings = {\n                 path: \"/auth\",\n                 key: \"colyseus-auth-token\",\n             };\n             _Auth__initialized.set(this, false);\n             _Auth__initializationPromise.set(this, void 0);\n             _Auth__signInWindow.set(this, undefined);\n             _Auth__events.set(this, createNanoEvents());\n             getItem(this.settings.key, (token) => this.token = token);\n         }\n         set token(token) {\n             this.http.authToken = token;\n         }\n         get token() {\n             return this.http.authToken;\n         }\n         onChange(callback) {\n             const unbindChange = __classPrivateFieldGet(this, _Auth__events, \"f\").on(\"change\", callback);\n             if (!__classPrivateFieldGet(this, _Auth__initialized, \"f\")) {\n                 __classPrivateFieldSet(this, _Auth__initializationPromise, new Promise((resolve, reject) => {\n                     this.getUserData().then((userData) => {\n                         this.emitChange(Object.assign(Object.assign({}, userData), { token: this.token }));\n                     }).catch((e) => {\n                         // user is not logged in, or service is down\n                         this.emitChange({ user: null, token: undefined });\n                     }).finally(() => {\n                         resolve();\n                     });\n                 }), \"f\");\n             }\n             __classPrivateFieldSet(this, _Auth__initialized, true, \"f\");\n             return unbindChange;\n         }\n         getUserData() {\n             return __awaiter(this, void 0, void 0, function* () {\n                 if (this.token) {\n                     return (yield this.http.get(`${this.settings.path}/userdata`)).data;\n                 }\n                 else {\n                     throw new Error(\"missing auth.token\");\n                 }\n             });\n         }\n         registerWithEmailAndPassword(email, password, options) {\n             return __awaiter(this, void 0, void 0, function* () {\n                 const data = (yield this.http.post(`${this.settings.path}/register`, {\n                     body: { email, password, options, },\n                 })).data;\n                 this.emitChange(data);\n                 return data;\n             });\n         }\n         signInWithEmailAndPassword(email, password) {\n             return __awaiter(this, void 0, void 0, function* () {\n                 const data = (yield this.http.post(`${this.settings.path}/login`, {\n                     body: { email, password, },\n                 })).data;\n                 this.emitChange(data);\n                 return data;\n             });\n         }\n         signInAnonymously(options) {\n             return __awaiter(this, void 0, void 0, function* () {\n                 const data = (yield this.http.post(`${this.settings.path}/anonymous`, {\n                     body: { options, }\n                 })).data;\n                 this.emitChange(data);\n                 return data;\n             });\n         }\n         sendPasswordResetEmail(email) {\n             return __awaiter(this, void 0, void 0, function* () {\n                 return (yield this.http.post(`${this.settings.path}/forgot-password`, {\n                     body: { email, }\n                 })).data;\n             });\n         }\n         signInWithProvider(providerName_1) {\n             return __awaiter(this, arguments, void 0, function* (providerName, settings = {}) {\n                 return new Promise((resolve, reject) => {\n                     const w = settings.width || 480;\n                     const h = settings.height || 768;\n                     // forward existing token for upgrading\n                     const upgradingToken = this.token ? `?token=${this.token}` : \"\";\n                     // Capitalize first letter of providerName\n                     const title = `Login with ${(providerName[0].toUpperCase() + providerName.substring(1))}`;\n                     const url = this.http['client']['getHttpEndpoint'](`${(settings.prefix || `${this.settings.path}/provider`)}/${providerName}${upgradingToken}`);\n                     const left = (screen.width / 2) - (w / 2);\n                     const top = (screen.height / 2) - (h / 2);\n                     __classPrivateFieldSet(this, _Auth__signInWindow, window.open(url, title, 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left), \"f\");\n                     const onMessage = (event) => {\n                         // TODO: it is a good idea to check if event.origin can be trusted!\n                         // if (event.origin.indexOf(window.location.hostname) === -1) { return; }\n                         // require 'user' and 'token' inside received data.\n                         if (event.data.user === undefined && event.data.token === undefined) {\n                             return;\n                         }\n                         clearInterval(rejectionChecker);\n                         __classPrivateFieldGet(this, _Auth__signInWindow, \"f\").close();\n                         __classPrivateFieldSet(this, _Auth__signInWindow, undefined, \"f\");\n                         window.removeEventListener(\"message\", onMessage);\n                         if (event.data.error !== undefined) {\n                             reject(event.data.error);\n                         }\n                         else {\n                             resolve(event.data);\n                             this.emitChange(event.data);\n                         }\n                     };\n                     const rejectionChecker = setInterval(() => {\n                         if (!__classPrivateFieldGet(this, _Auth__signInWindow, \"f\") || __classPrivateFieldGet(this, _Auth__signInWindow, \"f\").closed) {\n                             __classPrivateFieldSet(this, _Auth__signInWindow, undefined, \"f\");\n                             reject(\"cancelled\");\n                             window.removeEventListener(\"message\", onMessage);\n                         }\n                     }, 200);\n                     window.addEventListener(\"message\", onMessage);\n                 });\n             });\n         }\n         signOut() {\n             return __awaiter(this, void 0, void 0, function* () {\n                 this.emitChange({ user: null, token: null });\n             });\n         }\n         emitChange(authData) {\n             if (authData.token !== undefined) {\n                 this.token = authData.token;\n                 if (authData.token === null) {\n                     removeItem(this.settings.key);\n                 }\n                 else {\n                     // store key in localStorage\n                     setItem(this.settings.key, authData.token);\n                 }\n             }\n             __classPrivateFieldGet(this, _Auth__events, \"f\").emit(\"change\", authData);\n         }\n     }\n     _Auth__initialized = new WeakMap(), _Auth__initializationPromise = new WeakMap(), _Auth__signInWindow = new WeakMap(), _Auth__events = new WeakMap();\n\n     /**\n      * Discord Embedded App SDK\n      * https://github.com/colyseus/colyseus/issues/707\n      *\n      * All URLs must go through the local proxy from\n      * https://<app_id>.discordsays.com/.proxy/<mapped_url>/...\n      *\n      * URL Mapping Examples:\n      *\n      * 1. Using Colyseus Cloud:\n      *   - /colyseus/{subdomain} -> {subdomain}.colyseus.cloud\n      *\n      *   Example:\n      *     const client = new Client(\"https://xxxx.colyseus.cloud\");\n      *\n      * -------------------------------------------------------------\n      *\n      * 2. Using `cloudflared` tunnel:\n      *   - /colyseus/ -> <your-cloudflared-url>.trycloudflare.com\n      *\n      *   Example:\n      *     const client = new Client(\"https://<your-cloudflared-url>.trycloudflare.com\");\n      *\n      * -------------------------------------------------------------\n      *\n      * 3. Providing a manual /.proxy/your-mapping:\n      *   - /your-mapping/ -> your-endpoint.com\n      *\n      *   Example:\n      *     const client = new Client(\"/.proxy/your-mapping\");\n      *\n      */\n     function discordURLBuilder(url) {\n         var _a;\n         const localHostname = ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) || \"localhost\";\n         const remoteHostnameSplitted = url.hostname.split('.');\n         const subdomain = (!url.hostname.includes(\"trycloudflare.com\") && // ignore cloudflared subdomains\n             !url.hostname.includes(\"discordsays.com\") && // ignore discordsays.com subdomains\n             remoteHostnameSplitted.length > 2)\n             ? `/${remoteHostnameSplitted[0]}`\n             : '';\n         return (url.pathname.startsWith(\"/.proxy\"))\n             ? `${url.protocol}//${localHostname}${subdomain}${url.pathname}${url.search}`\n             : `${url.protocol}//${localHostname}/.proxy/colyseus${subdomain}${url.pathname}${url.search}`;\n     }\n\n     var _a;\n     class MatchMakeError extends Error {\n         constructor(message, code) {\n             super(message);\n             this.code = code;\n             this.name = \"MatchMakeError\";\n             Object.setPrototypeOf(this, MatchMakeError.prototype);\n         }\n     }\n     // - React Native does not provide `window.location`\n     // - Cocos Creator (Native) does not provide `window.location.hostname`\n     const DEFAULT_ENDPOINT = (typeof (window) !== \"undefined\" && typeof ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) !== \"undefined\")\n         ? `${window.location.protocol.replace(\"http\", \"ws\")}//${window.location.hostname}${(window.location.port && `:${window.location.port}`)}`\n         : \"ws://127.0.0.1:2567\";\n     class Client {\n         constructor(settings = DEFAULT_ENDPOINT, options) {\n             var _a, _b;\n             if (typeof (settings) === \"string\") {\n                 //\n                 // endpoint by url\n                 //\n                 const url = (settings.startsWith(\"/\"))\n                     ? new URL(settings, DEFAULT_ENDPOINT)\n                     : new URL(settings);\n                 const secure = (url.protocol === \"https:\" || url.protocol === \"wss:\");\n                 const port = Number(url.port || (secure ? 443 : 80));\n                 this.settings = {\n                     hostname: url.hostname,\n                     pathname: url.pathname,\n                     port,\n                     secure\n                 };\n             }\n             else {\n                 //\n                 // endpoint by settings\n                 //\n                 if (settings.port === undefined) {\n                     settings.port = (settings.secure) ? 443 : 80;\n                 }\n                 if (settings.pathname === undefined) {\n                     settings.pathname = \"\";\n                 }\n                 this.settings = settings;\n             }\n             // make sure pathname does not end with \"/\"\n             if (this.settings.pathname.endsWith(\"/\")) {\n                 this.settings.pathname = this.settings.pathname.slice(0, -1);\n             }\n             this.http = new HTTP(this, (options === null || options === void 0 ? void 0 : options.headers) || {});\n             this.auth = new Auth(this.http);\n             this.urlBuilder = options === null || options === void 0 ? void 0 : options.urlBuilder;\n             //\n             // Discord Embedded SDK requires a custom URL builder\n             //\n             if (!this.urlBuilder &&\n                 typeof (window) !== \"undefined\" &&\n                 ((_b = (_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) === null || _b === void 0 ? void 0 : _b.includes(\"discordsays.com\"))) {\n                 this.urlBuilder = discordURLBuilder;\n                 console.log(\"Colyseus SDK: Discord Embedded SDK detected. Using custom URL builder.\");\n             }\n         }\n         joinOrCreate(roomName_1) {\n             return __awaiter(this, arguments, void 0, function* (roomName, options = {}, rootSchema) {\n                 return yield this.createMatchMakeRequest('joinOrCreate', roomName, options, rootSchema);\n             });\n         }\n         create(roomName_1) {\n             return __awaiter(this, arguments, void 0, function* (roomName, options = {}, rootSchema) {\n                 return yield this.createMatchMakeRequest('create', roomName, options, rootSchema);\n             });\n         }\n         join(roomName_1) {\n             return __awaiter(this, arguments, void 0, function* (roomName, options = {}, rootSchema) {\n                 return yield this.createMatchMakeRequest('join', roomName, options, rootSchema);\n             });\n         }\n         joinById(roomId_1) {\n             return __awaiter(this, arguments, void 0, function* (roomId, options = {}, rootSchema) {\n                 return yield this.createMatchMakeRequest('joinById', roomId, options, rootSchema);\n             });\n         }\n         /**\n          * Re-establish connection with a room this client was previously connected to.\n          *\n          * @param reconnectionToken The `room.reconnectionToken` from previously connected room.\n          * @param rootSchema (optional) Concrete root schema definition\n          * @returns Promise<Room>\n          */\n         reconnect(reconnectionToken, rootSchema) {\n             return __awaiter(this, void 0, void 0, function* () {\n                 if (typeof (reconnectionToken) === \"string\" && typeof (rootSchema) === \"string\") {\n                     throw new Error(\"DEPRECATED: .reconnect() now only accepts 'reconnectionToken' as argument.\\nYou can get this token from previously connected `room.reconnectionToken`\");\n                 }\n                 const [roomId, token] = reconnectionToken.split(\":\");\n                 if (!roomId || !token) {\n                     throw new Error(\"Invalid reconnection token format.\\nThe format should be roomId:reconnectionToken\");\n                 }\n                 return yield this.createMatchMakeRequest('reconnect', roomId, { reconnectionToken: token }, rootSchema);\n             });\n         }\n         consumeSeatReservation(response, rootSchema, reuseRoomInstance // used in devMode\n         ) {\n             return __awaiter(this, void 0, void 0, function* () {\n                 const room = this.createRoom(response.room.name, rootSchema);\n                 room.roomId = response.room.roomId;\n                 room.sessionId = response.sessionId;\n                 const options = { sessionId: room.sessionId };\n                 // forward \"reconnection token\" in case of reconnection.\n                 if (response.reconnectionToken) {\n                     options.reconnectionToken = response.reconnectionToken;\n                 }\n                 const targetRoom = reuseRoomInstance || room;\n                 room.connect(this.buildEndpoint(response.room, options, response.protocol), response.devMode && (() => __awaiter(this, void 0, void 0, function* () {\n                     console.info(`[Colyseus devMode]: ${String.fromCodePoint(0x1F504)} Re-establishing connection with room id '${room.roomId}'...`); // \n                     let retryCount = 0;\n                     let retryMaxRetries = 8;\n                     const retryReconnection = () => __awaiter(this, void 0, void 0, function* () {\n                         retryCount++;\n                         try {\n                             yield this.consumeSeatReservation(response, rootSchema, targetRoom);\n                             console.info(`[Colyseus devMode]: ${String.fromCodePoint(0x2705)} Successfully re-established connection with room '${room.roomId}'`); // \n                         }\n                         catch (e) {\n                             if (retryCount < retryMaxRetries) {\n                                 console.info(`[Colyseus devMode]: ${String.fromCodePoint(0x1F504)} retrying... (${retryCount} out of ${retryMaxRetries})`); // \n                                 setTimeout(retryReconnection, 2000);\n                             }\n                             else {\n                                 console.info(`[Colyseus devMode]: ${String.fromCodePoint(0x274C)} Failed to reconnect. Is your server running? Please check server logs.`); // \n                             }\n                         }\n                     });\n                     setTimeout(retryReconnection, 2000);\n                 })), targetRoom, response, this.http.headers);\n                 return new Promise((resolve, reject) => {\n                     const onError = (code, message) => reject(new ServerError(code, message));\n                     targetRoom.onError.once(onError);\n                     targetRoom['onJoin'].once(() => {\n                         targetRoom.onError.remove(onError);\n                         resolve(targetRoom);\n                     });\n                 });\n             });\n         }\n         createMatchMakeRequest(method_1, roomName_1) {\n             return __awaiter(this, arguments, void 0, function* (method, roomName, options = {}, rootSchema, reuseRoomInstance) {\n                 const response = (yield this.http.post(`matchmake/${method}/${roomName}`, {\n                     headers: {\n                         'Accept': 'application/json',\n                         'Content-Type': 'application/json'\n                     },\n                     body: JSON.stringify(options)\n                 })).data;\n                 // FIXME: HTTP class is already handling this as ServerError.\n                 // @ts-ignore\n                 if (response.error) {\n                     throw new MatchMakeError(response.error, response.code);\n                 }\n                 // forward reconnection token during \"reconnect\" methods.\n                 if (method === \"reconnect\") {\n                     response.reconnectionToken = options.reconnectionToken;\n                 }\n                 return yield this.consumeSeatReservation(response, rootSchema, reuseRoomInstance);\n             });\n         }\n         createRoom(roomName, rootSchema) {\n             return new Room(roomName, rootSchema);\n         }\n         buildEndpoint(room, options = {}, protocol = \"ws\") {\n             const params = [];\n             // forward authentication token\n             if (this.http.authToken) {\n                 options['_authToken'] = this.http.authToken;\n             }\n             // append provided options\n             for (const name in options) {\n                 if (!options.hasOwnProperty(name)) {\n                     continue;\n                 }\n                 params.push(`${name}=${options[name]}`);\n             }\n             if (protocol === \"h3\") {\n                 protocol = \"http\";\n             }\n             let endpoint = (this.settings.secure)\n                 ? `${protocol}s://`\n                 : `${protocol}://`;\n             if (room.publicAddress) {\n                 endpoint += `${room.publicAddress}`;\n             }\n             else {\n                 endpoint += `${this.settings.hostname}${this.getEndpointPort()}${this.settings.pathname}`;\n             }\n             const endpointURL = `${endpoint}/${room.processId}/${room.roomId}?${params.join('&')}`;\n             return (this.urlBuilder)\n                 ? this.urlBuilder(new URL(endpointURL))\n                 : endpointURL;\n         }\n         getHttpEndpoint(segments = '') {\n             const path = segments.startsWith(\"/\") ? segments : `/${segments}`;\n             const endpointURL = `${(this.settings.secure) ? \"https\" : \"http\"}://${this.settings.hostname}${this.getEndpointPort()}${this.settings.pathname}${path}`;\n             return (this.urlBuilder)\n                 ? this.urlBuilder(new URL(endpointURL))\n                 : endpointURL;\n         }\n         getEndpointPort() {\n             return (this.settings.port !== 80 && this.settings.port !== 443)\n                 ? `:${this.settings.port}`\n                 : \"\";\n         }\n     }\n     Client.VERSION = \"0.16.16\";\n\n     class NoneSerializer {\n         setState(rawState) { }\n         getState() { return null; }\n         patch(patches) { }\n         teardown() { }\n         handshake(bytes) { }\n     }\n\n     registerSerializer('schema', SchemaSerializer);\n     registerSerializer('none', NoneSerializer);\n\n     exports.Auth = Auth;\n     exports.Client = Client;\n     exports.MatchMakeError = MatchMakeError;\n     exports.Room = Room;\n     exports.SchemaSerializer = SchemaSerializer;\n     exports.ServerError = ServerError;\n     exports.getStateCallbacks = getStateCallbacks;\n     exports.registerSerializer = registerSerializer;\n\n }));\n //# sourceMappingURL=colyseus-cocos-creator.js.map\n\n\n// #endregion ORIGINAL CODE\n\n_cjsExports = module.exports;\n_OPERATION = module.exports.OPERATION;\n_$changes = module.exports.$changes;\n_$childType = module.exports.$childType;\n_$decoder = module.exports.$decoder;\n_$deleteByIndex = module.exports.$deleteByIndex;\n_$encoder = module.exports.$encoder;\n_$filter = module.exports.$filter;\n_$getByIndex = module.exports.$getByIndex;\n_$track = module.exports.$track;\n_ArraySchema = module.exports.ArraySchema;\n_ChangeTree = module.exports.ChangeTree;\n_CollectionSchema = module.exports.CollectionSchema;\n_Decoder = module.exports.Decoder;\n_Encoder = module.exports.Encoder;\n_MapSchema = module.exports.MapSchema;\n_Metadata = module.exports.Metadata;\n_Reflection = module.exports.Reflection;\n_ReflectionField = module.exports.ReflectionField;\n_ReflectionType = module.exports.ReflectionType;\n_Schema = module.exports.Schema;\n_SetSchema = module.exports.SetSchema;\n_StateView = module.exports.StateView;\n_TypeContext = module.exports.TypeContext;\n_decode = module.exports.decode;\n_decodeKeyValueOperation = module.exports.decodeKeyValueOperation;\n_decodeSchemaOperation = module.exports.decodeSchemaOperation;\n_defineCustomTypes = module.exports.defineCustomTypes;\n_defineTypes = module.exports.defineTypes;\n_deprecated = module.exports.deprecated;\n_dumpChanges = module.exports.dumpChanges;\n_encode = module.exports.encode;\n_encodeArray = module.exports.encodeArray;\n_encodeKeyValueOperation = module.exports.encodeKeyValueOperation;\n_encodeSchemaOperation = module.exports.encodeSchemaOperation;\n_entity = module.exports.entity;\n_getDecoderStateCallbacks = module.exports.getDecoderStateCallbacks;\n_getRawChangesCallback = module.exports.getRawChangesCallback;\n_registerType = module.exports.registerType;\n_schema = module.exports.schema;\n_type = module.exports.type;\n_view = module.exports.view;\n_Protocol = module.exports.Protocol;\n_ErrorCode = module.exports.ErrorCode;\n_Auth = module.exports.Auth;\n_Client = module.exports.Client;\n_MatchMakeError = module.exports.MatchMakeError;\n_Room = module.exports.Room;\n_SchemaSerializer = module.exports.SchemaSerializer;\n_ServerError = module.exports.ServerError;\n_getStateCallbacks = module.exports.getStateCallbacks;\n_registerSerializer = module.exports.registerSerializer;\n\n}, {});\nexport { _cjsExports as default };\nexport { __cjsMetaURL }\n"]}